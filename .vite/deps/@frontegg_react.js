import {
  require_react_dom
} from "./chunk-ELNDXDY2.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_react
} from "./chunk-UCCAB3TN.js";

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@frontegg/js/AppHolder/index.js
var AppHolder_exports = {};
__export(AppHolder_exports, {
  AppHolder: () => AppHolder
});
var AppHolder;
var init_AppHolder = __esm({
  "node_modules/@frontegg/js/AppHolder/index.js"() {
    init_classCallCheck();
    init_createClass();
    AppHolder = function() {
      function AppHolder2() {
        _classCallCheck(this, AppHolder2);
      }
      _createClass(AppHolder2, null, [{
        key: "setInstance",
        value: function setInstance(name, app) {
          AppHolder2._apps[name] = app;
        }
      }, {
        key: "getInstance",
        value: function getInstance(name) {
          var app = AppHolder2._apps[name];
          if (!app) {
            throw Error("[".concat(name, "] FronteggApp not found"));
          }
          return app;
        }
      }]);
      return AppHolder2;
    }();
    AppHolder._apps = {};
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
var init_arrayWithHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f2 = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f2 = false;
      } else for (; !(f2 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f2 = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f2 && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime5() {
      "use strict";
      module.exports = _regeneratorRuntime5 = function _regeneratorRuntime6() {
        return r;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t, r = {}, e = Object.prototype, n = e.hasOwnProperty, o = "function" == typeof Symbol ? Symbol : {}, i = o.iterator || "@@iterator", a = o.asyncIterator || "@@asyncIterator", u = o.toStringTag || "@@toStringTag";
      function c(t2, r2, e2, n2) {
        return Object.defineProperty(t2, r2, {
          value: e2,
          enumerable: !n2,
          configurable: !n2,
          writable: !n2
        });
      }
      try {
        c({}, "");
      } catch (t2) {
        c = function c2(t3, r2, e2) {
          return t3[r2] = e2;
        };
      }
      function h(r2, e2, n2, o2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype);
        return c(a2, "_invoke", /* @__PURE__ */ function(r3, e3, n3) {
          var o3 = 1;
          return function(i3, a3) {
            if (3 === o3) throw Error("Generator is already running");
            if (4 === o3) {
              if ("throw" === i3) throw a3;
              return {
                value: t,
                done: true
              };
            }
            for (n3.method = i3, n3.arg = a3; ; ) {
              var u2 = n3.delegate;
              if (u2) {
                var c2 = d(u2, n3);
                if (c2) {
                  if (c2 === f2) continue;
                  return c2;
                }
              }
              if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
              else if ("throw" === n3.method) {
                if (1 === o3) throw o3 = 4, n3.arg;
                n3.dispatchException(n3.arg);
              } else "return" === n3.method && n3.abrupt("return", n3.arg);
              o3 = 3;
              var h2 = s(r3, e3, n3);
              if ("normal" === h2.type) {
                if (o3 = n3.done ? 4 : 2, h2.arg === f2) continue;
                return {
                  value: h2.arg,
                  done: n3.done
                };
              }
              "throw" === h2.type && (o3 = 4, n3.method = "throw", n3.arg = h2.arg);
            }
          };
        }(r2, n2, new Context(o2 || [])), true), a2;
      }
      function s(t2, r2, e2) {
        try {
          return {
            type: "normal",
            arg: t2.call(r2, e2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      r.wrap = h;
      var f2 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var l = {};
      c(l, i, function() {
        return this;
      });
      var p = Object.getPrototypeOf, y = p && p(p(x([])));
      y && y !== e && n.call(y, i) && (l = y);
      var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);
      function g(t2) {
        ["next", "throw", "return"].forEach(function(r2) {
          c(t2, r2, function(t3) {
            return this._invoke(r2, t3);
          });
        });
      }
      function AsyncIterator(t2, r2) {
        function e2(o3, i2, a2, u2) {
          var c2 = s(t2[o3], t2, i2);
          if ("throw" !== c2.type) {
            var h2 = c2.arg, f3 = h2.value;
            return f3 && "object" == _typeof2(f3) && n.call(f3, "__await") ? r2.resolve(f3.__await).then(function(t3) {
              e2("next", t3, a2, u2);
            }, function(t3) {
              e2("throw", t3, a2, u2);
            }) : r2.resolve(f3).then(function(t3) {
              h2.value = t3, a2(h2);
            }, function(t3) {
              return e2("throw", t3, a2, u2);
            });
          }
          u2(c2.arg);
        }
        var o2;
        c(this, "_invoke", function(t3, n2) {
          function i2() {
            return new r2(function(r3, o3) {
              e2(t3, n2, r3, o3);
            });
          }
          return o2 = o2 ? o2.then(i2, i2) : i2();
        }, true);
      }
      function d(r2, e2) {
        var n2 = e2.method, o2 = r2.i[n2];
        if (o2 === t) return e2.delegate = null, "throw" === n2 && r2.i["return"] && (e2.method = "return", e2.arg = t, d(r2, e2), "throw" === e2.method) || "return" !== n2 && (e2.method = "throw", e2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), f2;
        var i2 = s(o2, r2.i, e2.arg);
        if ("throw" === i2.type) return e2.method = "throw", e2.arg = i2.arg, e2.delegate = null, f2;
        var a2 = i2.arg;
        return a2 ? a2.done ? (e2[r2.r] = a2.value, e2.next = r2.n, "return" !== e2.method && (e2.method = "next", e2.arg = t), e2.delegate = null, f2) : a2 : (e2.method = "throw", e2.arg = new TypeError("iterator result is not an object"), e2.delegate = null, f2);
      }
      function w(t2) {
        this.tryEntries.push(t2);
      }
      function m(r2) {
        var e2 = r2[4] || {};
        e2.type = "normal", e2.arg = t, r2[4] = e2;
      }
      function Context(t2) {
        this.tryEntries = [[-1]], t2.forEach(w, this), this.reset(true);
      }
      function x(r2) {
        if (null != r2) {
          var e2 = r2[i];
          if (e2) return e2.call(r2);
          if ("function" == typeof r2.next) return r2;
          if (!isNaN(r2.length)) {
            var o2 = -1, a2 = function e3() {
              for (; ++o2 < r2.length; ) if (n.call(r2, o2)) return e3.value = r2[o2], e3.done = false, e3;
              return e3.value = t, e3.done = true, e3;
            };
            return a2.next = a2;
          }
        }
        throw new TypeError(_typeof2(r2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, "GeneratorFunction"), r.isGeneratorFunction = function(t2) {
        var r2 = "function" == typeof t2 && t2.constructor;
        return !!r2 && (r2 === GeneratorFunction || "GeneratorFunction" === (r2.displayName || r2.name));
      }, r.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, c(t2, u, "GeneratorFunction")), t2.prototype = Object.create(v), t2;
      }, r.awrap = function(t2) {
        return {
          __await: t2
        };
      }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function() {
        return this;
      }), r.AsyncIterator = AsyncIterator, r.async = function(t2, e2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(h(t2, e2, n2, o2), i2);
        return r.isGeneratorFunction(e2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, g(v), c(v, u, "Generator"), c(v, i, function() {
        return this;
      }), c(v, "toString", function() {
        return "[object Generator]";
      }), r.keys = function(t2) {
        var r2 = Object(t2), e2 = [];
        for (var n2 in r2) e2.unshift(n2);
        return function t3() {
          for (; e2.length; ) if ((n2 = e2.pop()) in r2) return t3.value = n2, t3.done = false, t3;
          return t3.done = true, t3;
        };
      }, r.values = x, Context.prototype = {
        constructor: Context,
        reset: function reset(r2) {
          if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r2) for (var e2 in this) "t" === e2.charAt(0) && n.call(this, e2) && !isNaN(+e2.slice(1)) && (this[e2] = t);
        },
        stop: function stop() {
          this.done = true;
          var t2 = this.tryEntries[0][4];
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(r2) {
          if (this.done) throw r2;
          var e2 = this;
          function n2(t2) {
            a2.type = "throw", a2.arg = r2, e2.next = t2;
          }
          for (var o2 = e2.tryEntries.length - 1; o2 >= 0; --o2) {
            var i2 = this.tryEntries[o2], a2 = i2[4], u2 = this.prev, c2 = i2[1], h2 = i2[2];
            if (-1 === i2[0]) return n2("end"), false;
            if (!c2 && !h2) throw Error("try statement without catch or finally");
            if (null != i2[0] && i2[0] <= u2) {
              if (u2 < c2) return this.method = "next", this.arg = t, n2(c2), true;
              if (u2 < h2) return n2(h2), false;
            }
          }
        },
        abrupt: function abrupt(t2, r2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var n2 = this.tryEntries[e2];
            if (n2[0] > -1 && n2[0] <= this.prev && this.prev < n2[2]) {
              var o2 = n2;
              break;
            }
          }
          o2 && ("break" === t2 || "continue" === t2) && o2[0] <= r2 && r2 <= o2[2] && (o2 = null);
          var i2 = o2 ? o2[4] : {};
          return i2.type = t2, i2.arg = r2, o2 ? (this.method = "next", this.next = o2[2], f2) : this.complete(i2);
        },
        complete: function complete(t2, r2) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && r2 && (this.next = r2), f2;
        },
        finish: function finish(t2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var e2 = this.tryEntries[r2];
            if (e2[2] === t2) return this.complete(e2[4], e2[3]), m(e2), f2;
          }
        },
        "catch": function _catch(t2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var e2 = this.tryEntries[r2];
            if (e2[0] === t2) {
              var n2 = e2[4];
              if ("throw" === n2.type) {
                var o2 = n2.arg;
                m(e2);
              }
              return o2;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(r2, e2, n2) {
          return this.delegate = {
            i: x(r2),
            r: e2,
            n: n2
          }, "next" === this.method && (this.arg = t), f2;
        }
      }, r;
    }
    module.exports = _regeneratorRuntime5, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@frontegg/redux-store/toolkit/FronteggNativeModule.js
var FronteggNativeModule, FronteggNativeModule_default;
var init_FronteggNativeModule = __esm({
  "node_modules/@frontegg/redux-store/toolkit/FronteggNativeModule.js"() {
    FronteggNativeModule = class {
      constructor() {
        this.loginWithSSO = (email) => {
          if (this.isIOSNativeBridgeAvailable()) {
            var _window$webkit, _window$webkit$messag, _window$webkit$messag2;
            (_window$webkit = window.webkit) == null ? void 0 : (_window$webkit$messag = _window$webkit.messageHandlers) == null ? void 0 : (_window$webkit$messag2 = _window$webkit$messag.FronteggNativeBridge) == null ? void 0 : _window$webkit$messag2.postMessage(JSON.stringify({
              action: "loginWithSSO",
              payload: email
            }));
          } else if (this.isAndroidNativeBridgeAvailable()) {
            var _window$FronteggNativ;
            (_window$FronteggNativ = window.FronteggNativeBridge) == null ? void 0 : _window$FronteggNativ.loginWithSSO(email);
          } else {
            throw new Error("FronteggNativeBridge is not available");
          }
        };
        this.loginWithSocialLogin = (url) => {
          if (this.isIOSNativeBridgeAvailable()) {
            var _window$webkit2, _window$webkit2$messa, _window$webkit2$messa2;
            (_window$webkit2 = window.webkit) == null ? void 0 : (_window$webkit2$messa = _window$webkit2.messageHandlers) == null ? void 0 : (_window$webkit2$messa2 = _window$webkit2$messa.FronteggNativeBridge) == null ? void 0 : _window$webkit2$messa2.postMessage(JSON.stringify({
              action: "loginWithSocialLogin",
              payload: url
            }));
          } else if (this.isAndroidNativeBridgeAvailable()) {
            var _window$FronteggNativ2;
            (_window$FronteggNativ2 = window.FronteggNativeBridge) == null ? void 0 : _window$FronteggNativ2.loginWithSocialLogin(url);
          } else {
            throw new Error("FronteggNativeBridge is not available");
          }
        };
        this.loginWithSocialLoginProvider = (provider) => {
          if (this.isIOSNativeBridgeAvailable()) {
            var _window$webkit3, _window$webkit3$messa, _window$webkit3$messa2;
            (_window$webkit3 = window.webkit) == null ? void 0 : (_window$webkit3$messa = _window$webkit3.messageHandlers) == null ? void 0 : (_window$webkit3$messa2 = _window$webkit3$messa.FronteggNativeBridge) == null ? void 0 : _window$webkit3$messa2.postMessage(JSON.stringify({
              action: "loginWithSocialLoginProvider",
              payload: provider
            }));
          } else if (this.isAndroidNativeBridgeAvailable()) {
            var _window$FronteggNativ3;
            (_window$FronteggNativ3 = window.FronteggNativeBridge) == null ? void 0 : _window$FronteggNativ3.loginWithSocialLoginProvider(provider);
          } else {
            throw new Error("FronteggNativeBridge is not available");
          }
        };
        this.loginWithCustomSocialLoginProvider = (providerId) => {
          if (this.isIOSNativeBridgeAvailable()) {
            var _window$webkit4, _window$webkit4$messa, _window$webkit4$messa2;
            (_window$webkit4 = window.webkit) == null ? void 0 : (_window$webkit4$messa = _window$webkit4.messageHandlers) == null ? void 0 : (_window$webkit4$messa2 = _window$webkit4$messa.FronteggNativeBridge) == null ? void 0 : _window$webkit4$messa2.postMessage(JSON.stringify({
              action: "loginWithCustomSocialLoginProvider",
              payload: providerId
            }));
          } else if (this.isAndroidNativeBridgeAvailable()) {
            var _window$FronteggNativ4;
            (_window$FronteggNativ4 = window.FronteggNativeBridge) == null ? void 0 : _window$FronteggNativ4.loginWithCustomSocialLoginProvider(providerId);
          } else {
            throw new Error("FronteggNativeBridge is not available");
          }
        };
        this.suggestSavePassword = (email, password) => {
          if (this.isIOSNativeBridgeAvailable()) {
            var _window$webkit5, _window$webkit5$messa, _window$webkit5$messa2;
            (_window$webkit5 = window.webkit) == null ? void 0 : (_window$webkit5$messa = _window$webkit5.messageHandlers) == null ? void 0 : (_window$webkit5$messa2 = _window$webkit5$messa.FronteggNativeBridge) == null ? void 0 : _window$webkit5$messa2.postMessage(JSON.stringify({
              action: "suggestSavePassword",
              payload: JSON.stringify({
                email,
                password
              })
            }));
          } else if (this.isAndroidNativeBridgeAvailable()) {
            var _window$FronteggNativ5;
            (_window$FronteggNativ5 = window.FronteggNativeBridge) == null ? void 0 : _window$FronteggNativ5.suggestSavePassword(email, password);
          } else {
            throw new Error("FronteggNativeBridge is not available");
          }
        };
        this.promptSocialLoginConsent = () => {
          var _window$FronteggNativ6, _window$FronteggNativ7;
          return (_window$FronteggNativ6 = (_window$FronteggNativ7 = window.FronteggNativeBridgeFunctions) == null ? void 0 : _window$FronteggNativ7["shouldPromptSocialLoginConsent"]) != null ? _window$FronteggNativ6 : false;
        };
      }
      isIOSNativeBridgeAvailable() {
        var _window$webkit6, _window$webkit6$messa;
        return ((_window$webkit6 = window.webkit) == null ? void 0 : (_window$webkit6$messa = _window$webkit6.messageHandlers) == null ? void 0 : _window$webkit6$messa.FronteggNativeBridge) != null;
      }
      isAndroidNativeBridgeAvailable() {
        return window.FronteggNativeBridge != null;
      }
      /**
       * @deprecated use isSocialLoginProviderAvailable instead for pkce flow in mobile
       */
      isSocialLoginAvailable() {
        return this.isAvailable("loginWithSocialLogin");
      }
      isSocialLoginProviderAvailable() {
        return this.isAvailable("loginWithSocialLoginProvider");
      }
      isCustomSocialLoginProviderAvailable() {
        return this.isAvailable("loginWithCustomSocialLoginProvider");
      }
      isLoginWithSSOAvailable() {
        return this.isAvailable("loginWithSSO");
      }
      isSuggestSavePasswordAvailable() {
        return this.isAvailable("suggestSavePassword");
      }
      isAvailable(method) {
        if (this.isIOSNativeBridgeAvailable() || this.isAndroidNativeBridgeAvailable()) {
          var _window$FronteggNativ8, _window$FronteggNativ9;
          return (_window$FronteggNativ8 = (_window$FronteggNativ9 = window.FronteggNativeBridgeFunctions) == null ? void 0 : _window$FronteggNativ9[method]) != null ? _window$FronteggNativ8 : false;
        }
        return false;
      }
    };
    FronteggNativeModule_default = new FronteggNativeModule();
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var init_extends = __esm({
  "node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// node_modules/proxy-compare/dist/index.js
var TRACK_MEMO_SYMBOL, GET_ORIGINAL_SYMBOL, AFFECTED_PROPERTY, IS_TARGET_COPIED_PROPERTY, PROXY_PROPERTY, PROXY_CACHE_PROPERTY, TARGET_CACHE_PROPERTY, HAS_KEY_PROPERTY, ALL_OWN_KEYS_PROPERTY, HAS_OWN_KEY_PROPERTY, KEYS_PROPERTY, newProxy, getProto, objectsToTrack, isObjectToTrack, isObject, needsToCopyTargetObject, copyTargetObject, createProxyHandler, getOriginalObject, createProxy, isAllOwnKeysChanged, isChanged, getUntracked, markToTrack;
var init_dist = __esm({
  "node_modules/proxy-compare/dist/index.js"() {
    TRACK_MEMO_SYMBOL = Symbol();
    GET_ORIGINAL_SYMBOL = Symbol();
    AFFECTED_PROPERTY = "a";
    IS_TARGET_COPIED_PROPERTY = "f";
    PROXY_PROPERTY = "p";
    PROXY_CACHE_PROPERTY = "c";
    TARGET_CACHE_PROPERTY = "t";
    HAS_KEY_PROPERTY = "h";
    ALL_OWN_KEYS_PROPERTY = "w";
    HAS_OWN_KEY_PROPERTY = "o";
    KEYS_PROPERTY = "k";
    newProxy = (target, handler) => new Proxy(target, handler);
    getProto = Object.getPrototypeOf;
    objectsToTrack = /* @__PURE__ */ new WeakMap();
    isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
    isObject = (x) => typeof x === "object" && x !== null;
    needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
    copyTargetObject = (obj) => {
      if (Array.isArray(obj)) {
        return Array.from(obj);
      }
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      Object.values(descriptors).forEach((desc) => {
        desc.configurable = true;
      });
      return Object.create(getProto(obj), descriptors);
    };
    createProxyHandler = (origObj, isTargetCopied) => {
      const state = {
        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
      };
      let trackObject = false;
      const recordUsage = (type, key) => {
        if (!trackObject) {
          let used = state[AFFECTED_PROPERTY].get(origObj);
          if (!used) {
            used = {};
            state[AFFECTED_PROPERTY].set(origObj, used);
          }
          if (type === ALL_OWN_KEYS_PROPERTY) {
            used[ALL_OWN_KEYS_PROPERTY] = true;
          } else {
            let set = used[type];
            if (!set) {
              set = /* @__PURE__ */ new Set();
              used[type] = set;
            }
            set.add(key);
          }
        }
      };
      const recordObjectAsUsed = () => {
        trackObject = true;
        state[AFFECTED_PROPERTY].delete(origObj);
      };
      const handler = {
        get(target, key) {
          if (key === GET_ORIGINAL_SYMBOL) {
            return origObj;
          }
          recordUsage(KEYS_PROPERTY, key);
          return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);
        },
        has(target, key) {
          if (key === TRACK_MEMO_SYMBOL) {
            recordObjectAsUsed();
            return true;
          }
          recordUsage(HAS_KEY_PROPERTY, key);
          return Reflect.has(target, key);
        },
        getOwnPropertyDescriptor(target, key) {
          recordUsage(HAS_OWN_KEY_PROPERTY, key);
          return Reflect.getOwnPropertyDescriptor(target, key);
        },
        ownKeys(target) {
          recordUsage(ALL_OWN_KEYS_PROPERTY);
          return Reflect.ownKeys(target);
        }
      };
      if (isTargetCopied) {
        handler.set = handler.deleteProperty = () => false;
      }
      return [handler, state];
    };
    getOriginalObject = (obj) => (
      // unwrap proxy
      obj[GET_ORIGINAL_SYMBOL] || // otherwise
      obj
    );
    createProxy = (obj, affected, proxyCache, targetCache2) => {
      if (!isObjectToTrack(obj))
        return obj;
      let targetAndCopied = targetCache2 && targetCache2.get(obj);
      if (!targetAndCopied) {
        const target2 = getOriginalObject(obj);
        if (needsToCopyTargetObject(target2)) {
          targetAndCopied = [target2, copyTargetObject(target2)];
        } else {
          targetAndCopied = [target2];
        }
        targetCache2 === null || targetCache2 === void 0 ? void 0 : targetCache2.set(obj, targetAndCopied);
      }
      const [target, copiedTarget] = targetAndCopied;
      let handlerAndState = proxyCache && proxyCache.get(target);
      if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
        handlerAndState = createProxyHandler(target, !!copiedTarget);
        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
        if (proxyCache) {
          proxyCache.set(target, handlerAndState);
        }
      }
      handlerAndState[1][AFFECTED_PROPERTY] = affected;
      handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
      handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache2;
      return handlerAndState[1][PROXY_PROPERTY];
    };
    isAllOwnKeysChanged = (prevObj, nextObj) => {
      const prevKeys = Reflect.ownKeys(prevObj);
      const nextKeys = Reflect.ownKeys(nextObj);
      return prevKeys.length !== nextKeys.length || prevKeys.some((k, i) => k !== nextKeys[i]);
    };
    isChanged = (prevObj, nextObj, affected, cache, isEqual2 = Object.is) => {
      if (isEqual2(prevObj, nextObj)) {
        return false;
      }
      if (!isObject(prevObj) || !isObject(nextObj))
        return true;
      const used = affected.get(getOriginalObject(prevObj));
      if (!used)
        return true;
      if (cache) {
        const hit = cache.get(prevObj);
        if (hit === nextObj) {
          return false;
        }
        cache.set(prevObj, nextObj);
      }
      let changed = null;
      for (const key of used[HAS_KEY_PROPERTY] || []) {
        changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
        if (changed)
          return changed;
      }
      if (used[ALL_OWN_KEYS_PROPERTY] === true) {
        changed = isAllOwnKeysChanged(prevObj, nextObj);
        if (changed)
          return changed;
      } else {
        for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
          const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
          const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
          changed = hasPrev !== hasNext;
          if (changed)
            return changed;
        }
      }
      for (const key of used[KEYS_PROPERTY] || []) {
        changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual2);
        if (changed)
          return changed;
      }
      if (changed === null)
        throw new Error("invalid used");
      return changed;
    };
    getUntracked = (obj) => {
      if (isObjectToTrack(obj)) {
        return obj[GET_ORIGINAL_SYMBOL] || null;
      }
      return null;
    };
    markToTrack = (obj, mark = true) => {
      objectsToTrack.set(obj, mark);
    };
  }
});

// node_modules/@frontegg/redux-store/valtio/valtio.js
function buildProxyFunction(objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject2(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(snap, key)) {
      return;
    }
    const value = Reflect.get(target, key);
    const {
      enumerable
    } = Reflect.getOwnPropertyDescriptor(target, key);
    const desc = {
      value,
      enumerable,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      markToTrack(value, false);
    } else if (value instanceof Promise) {
      delete desc.value;
      desc.get = () => handlePromise(value);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(value);
      desc.value = createSnapshot(target2, ensureVersion(), handlePromise);
    }
    Object.defineProperty(snap, key, desc);
  });
  return Object.preventExtensions(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
  if (!isObject2(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    const entry = propProxyStates.get(prop);
    if (entry) {
      var _entry$;
      propProxyStates.delete(prop);
      (_entry$ = entry[1]) == null ? void 0 : _entry$.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject2(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if (value instanceof Promise) {
        value.then((v) => {
          value.status = "fulfilled";
          value.value = v;
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          value.status = "rejected";
          value.reason = e;
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxyFunction(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if ("value" in desc) {
      proxyObject[key] = initialObject[key];
      delete desc.value;
      delete desc.writable;
    }
    Object.defineProperty(baseObject, key, desc);
  });
  return proxyObject;
}) {
  return [
    // public functions
    proxyFunction,
    // shared state
    proxyStateMap,
    refSet,
    // internal things
    objectIs,
    newProxy2,
    canProxy,
    defaultHandlePromise,
    snapCache,
    createSnapshot,
    proxyCache,
    versionHolder
  ];
}
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
var isObject2, proxyStateMap, refSet, defaultProxyFunction;
var init_valtio = __esm({
  "node_modules/@frontegg/redux-store/valtio/valtio.js"() {
    init_dist();
    isObject2 = (x) => typeof x === "object" && x !== null;
    proxyStateMap = /* @__PURE__ */ new WeakMap();
    refSet = /* @__PURE__ */ new WeakSet();
    [defaultProxyFunction] = buildProxyFunction();
  }
});

// node_modules/@frontegg/redux-store/valtio/utils/subscribeKey.js
var init_subscribeKey = __esm({
  "node_modules/@frontegg/redux-store/valtio/utils/subscribeKey.js"() {
    init_valtio();
  }
});

// node_modules/@frontegg/redux-store/valtio/utils/watch.js
var init_watch = __esm({
  "node_modules/@frontegg/redux-store/valtio/utils/watch.js"() {
    init_valtio();
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
var init_objectWithoutPropertiesLoose = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"() {
  }
});

// node_modules/@frontegg/redux-store/valtio/utils/devtools.js
function devtools(proxyObject, options) {
  if (typeof options === "string") {
    options = {
      name: options
    };
  }
  const _ref = options || {}, {
    enabled,
    name = ""
  } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
  let extension;
  try {
    extension = enabled && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!extension) {
    return;
  }
  let isTimeTraveling = false;
  const devtools2 = extension.connect(_extends({
    name
  }, rest));
  const unsub1 = subscribe(proxyObject, (ops) => {
    const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(".")}`).join(", ");
    if (!action) {
      return;
    }
    if (isTimeTraveling) {
      isTimeTraveling = false;
    } else {
      const snapWithoutDevtools = Object.assign({}, snapshot(proxyObject));
      delete snapWithoutDevtools[DEVTOOLS];
      devtools2.send({
        type: action,
        updatedAt: (/* @__PURE__ */ new Date()).toLocaleString()
      }, snapWithoutDevtools);
    }
  });
  const unsub2 = devtools2.subscribe((message) => {
    var _message$payload3, _message$payload4;
    if (message.type === "ACTION" && message.payload) {
      try {
        Object.assign(proxyObject, JSON.parse(message.payload));
      } catch (e) {
        console.error("please dispatch a serializable value that JSON.parse() and proxy() support\n", e);
      }
    }
    if (message.type === "DISPATCH" && message.state) {
      var _message$payload, _message$payload2;
      if (((_message$payload = message.payload) == null ? void 0 : _message$payload.type) === "JUMP_TO_ACTION" || ((_message$payload2 = message.payload) == null ? void 0 : _message$payload2.type) === "JUMP_TO_STATE") {
        isTimeTraveling = true;
        const state = JSON.parse(message.state);
        Object.assign(proxyObject, state);
      }
      proxyObject[DEVTOOLS] = message;
    } else if (message.type === "DISPATCH" && ((_message$payload3 = message.payload) == null ? void 0 : _message$payload3.type) === "COMMIT") {
      devtools2.init(snapshot(proxyObject));
    } else if (message.type === "DISPATCH" && ((_message$payload4 = message.payload) == null ? void 0 : _message$payload4.type) === "IMPORT_STATE") {
      var _message$payload$next, _message$payload$next2;
      const actions = (_message$payload$next = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next.actionsById;
      const computedStates = ((_message$payload$next2 = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next2.computedStates) || [];
      isTimeTraveling = true;
      computedStates.forEach(({
        state
      }, index) => {
        const action = actions[index] || "No action found";
        Object.assign(proxyObject, state);
        if (index === 0) {
          devtools2.init(snapshot(proxyObject));
        } else {
          devtools2.send(action, snapshot(proxyObject));
        }
      });
    }
  });
  devtools2.init(snapshot(proxyObject));
  return () => {
    unsub1();
    unsub2 == null ? void 0 : unsub2();
  };
}
var _excluded, DEVTOOLS;
var init_devtools = __esm({
  "node_modules/@frontegg/redux-store/valtio/utils/devtools.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_valtio();
    _excluded = ["enabled", "name"];
    DEVTOOLS = Symbol();
  }
});

// node_modules/@frontegg/redux-store/valtio/utils/proxyWithComputed.js
var init_proxyWithComputed = __esm({
  "node_modules/@frontegg/redux-store/valtio/utils/proxyWithComputed.js"() {
    init_valtio();
  }
});

// node_modules/@frontegg/redux-store/valtio/utils/proxyWithHistory.js
var init_proxyWithHistory = __esm({
  "node_modules/@frontegg/redux-store/valtio/utils/proxyWithHistory.js"() {
    init_valtio();
  }
});

// node_modules/@frontegg/redux-store/valtio/utils/proxySet.js
var init_proxySet = __esm({
  "node_modules/@frontegg/redux-store/valtio/utils/proxySet.js"() {
    init_valtio();
  }
});

// node_modules/@frontegg/redux-store/valtio/utils/proxyMap.js
var init_proxyMap = __esm({
  "node_modules/@frontegg/redux-store/valtio/utils/proxyMap.js"() {
    init_valtio();
  }
});

// node_modules/@frontegg/redux-store/valtio/utils/index.js
var init_utils = __esm({
  "node_modules/@frontegg/redux-store/valtio/utils/index.js"() {
    init_subscribeKey();
    init_watch();
    init_devtools();
    init_proxyWithComputed();
    init_proxyWithHistory();
    init_proxySet();
    init_proxyMap();
  }
});

// node_modules/@frontegg/redux-store/valtio/index.js
var init_valtio2 = __esm({
  "node_modules/@frontegg/redux-store/valtio/index.js"() {
    init_utils();
    init_valtio();
  }
});

// node_modules/@frontegg/rest-api/ContextHolder/index.js
var ContextHolder, DEFAULT_APP_NAME, FronteggContext;
var init_ContextHolder = __esm({
  "node_modules/@frontegg/rest-api/ContextHolder/index.js"() {
    ContextHolder = class _ContextHolder {
      constructor() {
        this.context = null;
        this.accessToken = null;
        this.user = null;
        this.requestSource = null;
        this.onRedirectTo = (path) => window.location.href = path;
        this.logout = () => window.location.href = "/account/logout";
        this.entitlementsOptions = null;
        this.appName = null;
        this.sessionContext = void 0;
        this.basename = null;
        this.cdnUrl = null;
        this.assetsUrl = null;
        this.setContext = (context) => {
          this.context = context;
        };
        this.setAccessToken = (accessToken) => {
          this.accessToken = accessToken;
        };
        this.setUser = (user) => {
          this.user = user;
        };
        this.setRequestSource = (requestSource) => {
          this.requestSource = requestSource;
        };
        this.setOnRedirectTo = (onRedirectTo) => {
          this.onRedirectTo = onRedirectTo;
        };
        this.setLogout = (logout) => {
          this.logout = logout;
        };
        this.setEntitlementsOptions = (entitlementsOptions) => {
          this.entitlementsOptions = entitlementsOptions;
        };
        this.setSessionContext = (sessionContext) => {
          this.sessionContext = sessionContext;
        };
        this.setAppName = (appName) => {
          this.appName = appName;
        };
        this.getContext = () => {
          var _this$context;
          return (_this$context = this.context) != null ? _this$context : {
            baseUrl: window.location.href,
            tokenResolver: () => "my-authentication-token",
            logLevel: "error"
          };
        };
        this.getAccessToken = () => {
          return this.accessToken;
        };
        this.getRequestSource = () => {
          return this.requestSource;
        };
        this.getUser = () => {
          return this.user;
        };
        this.shouldLoadEntitlements = () => {
          var _this$entitlementsOpt;
          return ((_this$entitlementsOpt = this.entitlementsOptions) == null ? void 0 : _this$entitlementsOpt.enabled) || false;
        };
        this.isSessionPerTenantEnabled = () => {
          var _this$sessionContext;
          return ((_this$sessionContext = this.sessionContext) == null ? void 0 : _this$sessionContext.enableSessionPerTenant) || false;
        };
        this.shouldSkipUserLoad = () => {
          var _this$sessionContext2;
          return ((_this$sessionContext2 = this.sessionContext) == null ? void 0 : _this$sessionContext2.skipUserLoading) || false;
        };
        this.getAppName = () => {
          return this.appName;
        };
        this.setCdnUrl = (cdnUrl) => {
          this.cdnUrl = cdnUrl;
        };
        this.getCdnUrl = () => {
          return this.cdnUrl;
        };
        this.setAssetsUrl = (assets) => {
          this.assetsUrl = assets;
        };
        this.getAssetsUrl = () => {
          return this.assetsUrl;
        };
      }
      static default() {
        return _ContextHolder.getInstance(DEFAULT_APP_NAME);
      }
      static for(appName) {
        return _ContextHolder.getInstance(appName);
      }
      /**
       * @deprecated - use ContextHolder.for(appName) / ContextHolder.default()  instead
       * @param appName
       */
      static getInstance(appName = "default") {
        if (!_ContextHolder._apps) {
          _ContextHolder._apps = {};
        }
        if (_ContextHolder._apps[appName]) {
          return _ContextHolder._apps[appName];
        }
        _ContextHolder._apps[appName] = new _ContextHolder();
        return _ContextHolder._apps[appName];
      }
      static createInstance(appName = "default") {
        _ContextHolder._apps[appName] = new _ContextHolder();
        _ContextHolder._apps[appName].appName = appName;
        return _ContextHolder._apps[appName];
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setContext instead
       */
      static setContext(context, appName = "default") {
        _ContextHolder.for(appName).context = context;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setAccessToken instead
       */
      static setAccessToken(accessToken, appName = DEFAULT_APP_NAME) {
        _ContextHolder.for(appName).accessToken = accessToken;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setUser instead
       */
      static setUser(user, appName = "default") {
        _ContextHolder.for(appName).user = user;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setRequestSource instead
       */
      static setRequestSource(requestSource, appName = "default") {
        _ContextHolder.for(appName).requestSource = requestSource;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setOnRedirectTo instead
       */
      static setOnRedirectTo(onRedirectTo, appName = "default") {
        _ContextHolder.for(appName).onRedirectTo = onRedirectTo;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setLogout instead
       */
      static setLogout(logout, logoutUrl, appName = "default") {
        const context = _ContextHolder.for(appName);
        context.logout = (callback) => {
          if (!callback) {
            context.onRedirectTo(logoutUrl, void 0);
          } else {
            logout(callback);
          }
        };
      }
      /**
       * App name should also be set for entitlements
       * @deprecated - use ContextHolder.for(appName).setEntitlementsOptions instead
       * @param entitlementsOptions frontegg options entitlements config
       * @param appName - app name
       */
      static setEntitlementsOptions(entitlementsOptions, appName = "default") {
        _ContextHolder.for(appName).entitlementsOptions = entitlementsOptions;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setSessionContext instead
       * @param sessionContext frontegg options SessionContext config
       * @param appName - app name
       */
      static setSessionContext(sessionContext, appName = "default") {
        _ContextHolder.for(appName).sessionContext = sessionContext;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setAppName instead
       */
      static setAppName(appName) {
        _ContextHolder.for(appName).appName = appName;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).getContext instead
       */
      static getContext(appName = "default") {
        var _ContextHolder$for$co;
        return (_ContextHolder$for$co = _ContextHolder.for(appName).context) != null ? _ContextHolder$for$co : {
          baseUrl: window.location.href,
          tokenResolver: () => "my-authentication-token",
          logLevel: "error"
        };
      }
      /**
       * @deprecated - use ContextHolder.for(appName).getAccessToken instead
       */
      static getAccessToken(appName = "default") {
        return _ContextHolder.for(appName).accessToken;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).requestSource instead
       */
      static getRequestSource(appName = "default") {
        return _ContextHolder.for(appName).requestSource;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).getBasename instead
       */
      static getBasename(appName = "default") {
        return _ContextHolder.for(appName).basename;
      }
      getBasename() {
        return this.basename;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).setBasename instead
       */
      static setBasename(basename, appName = DEFAULT_APP_NAME) {
        _ContextHolder.for(appName).basename = basename;
      }
      setBasename(basename) {
        this.basename = basename;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).getUser instead
       */
      static getUser(appName = "default") {
        return _ContextHolder.for(appName).user;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).onRedirectTo instead
       */
      static onRedirectTo(path, opts, appName = "default") {
        return _ContextHolder.for(appName).onRedirectTo(path, opts);
      }
      /**
       * @deprecated - use ContextHolder.for(appName).logout instead
       */
      static logout(callback, appName = "default") {
        return _ContextHolder.for(appName).logout(callback);
      }
      /**
       * @deprecated - use ContextHolder.for(appName).shouldLoadEntitlements instead
       * @returns shouldLoadEntitlements. Default to false.
       */
      static shouldLoadEntitlements(appName = "default") {
        var _ContextHolder$for$en;
        return ((_ContextHolder$for$en = _ContextHolder.for(appName).entitlementsOptions) == null ? void 0 : _ContextHolder$for$en.enabled) || false;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).isSessionPerTenantEnabled instead
       * @returns isSessionPerTenantEnabled. Default to false.
       */
      static isSessionPerTenantEnabled(appName = "default") {
        var _ContextHolder$for$se;
        return ((_ContextHolder$for$se = _ContextHolder.for(appName).sessionContext) == null ? void 0 : _ContextHolder$for$se.enableSessionPerTenant) || false;
      }
      /**
       * @deprecated - use ContextHolder.for(appName).getAppName instead
       * @returns app name value
       */
      static getAppName(appName = "default") {
        return _ContextHolder.for(appName).appName;
      }
    };
    ContextHolder._apps = void 0;
    DEFAULT_APP_NAME = "default";
    FronteggContext = {
      getContext: () => ContextHolder.getContext(DEFAULT_APP_NAME),
      getAccessToken: () => ContextHolder.getAccessToken(DEFAULT_APP_NAME),
      setAccessToken: (accessToken) => ContextHolder.setAccessToken(accessToken, DEFAULT_APP_NAME),
      getUser: () => ContextHolder.getUser(DEFAULT_APP_NAME),
      setUser: (user) => ContextHolder.setUser(user, DEFAULT_APP_NAME),
      onRedirectTo: (path, opts) => ContextHolder.onRedirectTo(path, opts, DEFAULT_APP_NAME),
      setOnRedirectTo: (onRedirectTo) => ContextHolder.setOnRedirectTo(onRedirectTo, DEFAULT_APP_NAME),
      logout: (callback) => ContextHolder.logout(callback, DEFAULT_APP_NAME),
      getRequestSource: () => ContextHolder.getRequestSource(DEFAULT_APP_NAME),
      setRequestSource: (requestSource) => ContextHolder.setRequestSource(requestSource, DEFAULT_APP_NAME),
      isSessionPerTenantEnabled: () => ContextHolder.isSessionPerTenantEnabled(DEFAULT_APP_NAME),
      shouldLoadEntitlements: () => ContextHolder.shouldLoadEntitlements(DEFAULT_APP_NAME),
      getAppName: () => ContextHolder.getAppName(DEFAULT_APP_NAME),
      setEntitlementsOptions: (entitlementsOptions) => ContextHolder.setEntitlementsOptions(entitlementsOptions, DEFAULT_APP_NAME),
      setSessionContext: (sessionContext) => ContextHolder.setSessionContext(sessionContext, DEFAULT_APP_NAME),
      getBasename: () => ContextHolder.getBasename(DEFAULT_APP_NAME),
      setBasename: (basename) => ContextHolder.setBasename(basename, DEFAULT_APP_NAME)
    };
  }
});

// node_modules/@frontegg/rest-api/error.js
var FronteggApiError;
var init_error = __esm({
  "node_modules/@frontegg/rest-api/error.js"() {
    FronteggApiError = class extends Error {
      constructor(message, statusCode, traceId, errorCode, errorContext) {
        super(message);
        this._statusCode = void 0;
        this._traceId = void 0;
        this._errorCode = void 0;
        this._errorContext = void 0;
        this._statusCode = statusCode;
        this._traceId = traceId;
        this._errorCode = errorCode;
        this._errorContext = errorContext;
      }
      get statusCode() {
        return this._statusCode;
      }
      get traceId() {
        return this._traceId;
      }
      get errorCode() {
        return this._errorCode;
      }
      get errorContext() {
        return this._errorContext;
      }
    };
  }
});

// node_modules/@frontegg/rest-api/constants.js
var urls, GENERIC_ERROR_MESSAGE, GENERIC_ERROR_CODE, FRONTEGG_TRACE_ID;
var init_constants = __esm({
  "node_modules/@frontegg/rest-api/constants.js"() {
    urls = {
      vendor: "/vendors",
      identity: {
        signup: {
          v1: {
            strategies: "/identity/resources/configurations/v1/sign-up/strategies"
          }
        },
        webAuthnDevices: {
          v1: "/identity/resources/users/webauthn/v1/devices"
        },
        auth: {
          v1: "/identity/resources/auth/v1",
          v2: "/identity/resources/auth/v2"
        },
        users: {
          v1: "/identity/resources/users/v1",
          v2: "/identity/resources/users/v2",
          v3: "/identity/resources/users/v3",
          roles: {
            v3: "/identity/resources/users/v3/roles"
          },
          groups: {
            v3: "/identity/resources/users/v3/groups"
          },
          tenants: {
            me: {
              v1: "/identity/resources/users/v1/me/tenants",
              v3: "/identity/resources/users/v3/me/tenants"
            }
          },
          apiTokens: {
            v1: "/identity/resources/users/api-tokens/v1"
          },
          accessTokens: {
            v1: "/identity/resources/users/access-tokens/v1"
          },
          sessions: {
            v1: "/identity/resources/users/sessions/v1",
            currentUser: {
              v1: "/identity/resources/users/sessions/v1/me"
            },
            configurations: {
              v1: "/identity/resources/configurations/sessions/v1"
            }
          },
          invitation: {
            resendAll: {
              v1: "/identity/resources/users/v1/invitation/reset/all"
            }
          },
          passwords: {
            resetBreachedPasswords: {
              v1: "/identity/resources/users/v1/passwords/breached/reset/bulk"
            }
          },
          authorization: {
            v1: "/identity/resources/users/v1/me/authorization"
          },
          temporary: {
            v1: "/identity/resources/users/temporary/v1",
            configuration: {
              v1: "/identity/resources/users/temporary/v1/configuration"
            }
          }
        },
        configurations: {
          v1: "/identity/resources/configurations/v1"
        },
        restrictions: {
          emailDomain: {
            v1: "/identity/resources/configurations/restrictions/v1/email-domain"
          },
          ip: {
            v1: "/identity/resources/configurations/v1/restrictions/ip"
          }
        },
        sso: {
          v1: "/identity/resources/sso/v1",
          v2: "/identity/resources/sso/v2",
          custom: {
            v1: "/identity/resources/sso/custom/v1"
          }
        },
        permissions: {
          v1: "/identity/resources/permissions/v1"
        },
        tenants: {
          apiTokens: {
            v1: "/identity/resources/tenants/api-tokens/v1",
            v2: "/identity/resources/tenants/api-tokens/v2"
          },
          accessTokens: {
            v1: "/identity/resources/tenants/access-tokens/v1"
          },
          invites: {
            user: {
              v1: "/identity/resources/tenants/invites/v1/user"
            },
            verify: {
              v1: "/identity/resources/tenants/invites/v1/verify"
            },
            configuration: {
              v1: "/identity/resources/tenants/invites/v1/configuration"
            }
          },
          users: {
            v1: "/identity/resources/tenants/users/v1"
          }
        },
        roles: {
          v1: "/identity/resources/roles/v1",
          v2: "/identity/resources/roles/v2"
        },
        subTenants: {
          v1: "/identity/resources/sub-tenants/users/v1",
          v2: "/identity/resources/sub-tenants/users/v2"
        },
        impersonate: {
          v1: "/identity/resources/impersonation/v1"
        },
        applications: {
          v1: "/identity/resources/applications/v1"
        },
        groups: {
          v1: "/identity/resources/groups/v1",
          configurations: {
            v1: "/identity/resources/groups/v1/config"
          },
          getByIds: {
            v1: "/identity/resources/groups/v1/bulkGet"
          }
        },
        phoneNumbers: {
          v1: "/identity/resources/users/phone-numbers/v1"
        }
      },
      team: {
        sso: {
          v1: "/team/resources/sso/v1",
          v2: "/team/resources/sso/v2"
        },
        members: {
          v1: "/team/resources/members/v1"
        },
        roles: {
          v1: "/team/resources/roles/v1"
        },
        stats: {
          v1: "/team/resources/stats/v1"
        },
        profile: {
          v1: "/team/resources/profile"
          // no versioning in backend
        }
      },
      tenants: {
        accountSettings: {
          v1: "/tenants/resources/account-settings/v1"
        },
        hierarchy: {
          v1: "/tenants/resources/hierarchy/v1",
          tree: {
            v1: "/tenants/resources/hierarchy/v1/tree"
          },
          parents: {
            v1: "/tenants/resources/hierarchy/v1/parents"
          },
          v2: "/tenants/resources/hierarchy/v2",
          metadata: {
            v2: "/tenants/resources/hierarchy/v2/metadata"
          }
        },
        subTenants: {
          v1: "/tenants/resources/sub-tenants/v1"
        }
      },
      integrations: {
        configurations: {
          v1: "/integrations/resources/configurations/v1",
          v2: "/integrations/resources/configurations/v2"
        }
      },
      subscriptions: {
        billing: {
          subscriptions: {
            v1: "/subscriptions/resources/billing/subscriptions/v1"
          },
          plans: {
            v1: "/subscriptions/resources/billing/plans/v1"
          },
          invoices: {
            v1: "/subscriptions/resources/billing/invoices/v1"
          },
          paymentMethods: {
            v1: "/subscriptions/resources/billing/payment-methods/v1"
          },
          summaries: {
            v1: "/subscriptions/resources/billing/summaries/v1"
          },
          tenantConfiguration: {
            v1: "/subscriptions/resources/billing/tenant-configurations/v1"
          },
          configurations: {
            vendorPublicConfigurations: {
              v1: "/subscriptions/resources/billing/configurations/vendor-public-configurations/v1"
            }
          },
          paymentProviders: {
            stripe: {
              customers: {
                v1: "/subscriptions/resources/billing/payment-providers/stripe/customers/v1"
              },
              publicConfigurations: {
                v1: "/subscriptions/resources/billing/payment-providers/stripe/public-configurations/v1"
              },
              subscriptions: {
                v1: "/subscriptions/resources/billing/payment-providers/stripe/subscriptions/v1"
              },
              setupIntents: {
                v1: "/subscriptions/resources/billing/payment-providers/stripe/setup-intents/v1"
              }
            }
          }
        },
        paymentProviders: {
          v1: "/subscriptions/resources/payment-providers/v1"
        },
        managedSubscriptions: {
          v1: "/subscriptions/resources/subscriptions/v1"
        }
      },
      reports: {
        service: {
          v1: "/reports/resources/reports/v1",
          v2: "/reports/resources/reports/v2"
        },
        trigger: {
          v1: "/reports/engine/resources/triggers/v1"
        }
      },
      notifications: {
        v1: "/notification"
      },
      audits: {
        v1: "/audits"
      },
      events: {
        configurations: {
          v1: "/event/resources/configurations/v1"
        }
      },
      webhooks: {
        v1: "/webhook"
      },
      oauth: {
        v1: "/oauth"
      },
      featureFlags: {
        v1: "/flags"
      },
      directory: {
        v1: "/directory/resources/v1/configurations/scim2",
        temp: "/directory/resources/scim/temp"
      },
      entitlements: {
        v1: "/entitlements/api/v1/user-entitlements",
        v2: "/entitlements/api/v2/user-entitlements"
      },
      securityCenter: {
        recommendations: {
          v1: "/security-center/resources/recommendations/v1"
        },
        insights: {
          v1: "/security-center/resources/insights/v1"
        }
      },
      applications: {
        v1: "/applications/resources/applications/v1",
        tenant: {
          v1: "/applications/resources/applications/tenant-assignments/v1"
        }
      },
      velo: {
        // v1: '/nlp-execution-assistant/resources/velo/v1'
        v1: "http://localhost:3037/resources/velo/v1"
      }
    };
    GENERIC_ERROR_MESSAGE = `We're facing some difficulties, Please try again`;
    GENERIC_ERROR_CODE = "ER-ADMIN-PORTAL-GENERIC-ERROR";
    FRONTEGG_TRACE_ID = "frontegg-trace-id";
  }
});

// node_modules/@frontegg/rest-api/interfaces.js
var fronteggHeaders, RequestSource, FronteggFrameworks, PaginationOrderEnum;
var init_interfaces = __esm({
  "node_modules/@frontegg/rest-api/interfaces.js"() {
    fronteggHeaders = {
      frameWork: "x-frontegg-framework",
      fronteggSdkVersion: "x-frontegg-sdk",
      contentType: "Content-Type",
      source: "frontegg-source",
      scopedTenant: "frontegg-scoped-tenant"
    };
    (function(RequestSource2) {
      RequestSource2["AdminPortal"] = "admin-portal";
      RequestSource2["LoginBox"] = "login-box";
    })(RequestSource || (RequestSource = {}));
    (function(FronteggFrameworks2) {
      FronteggFrameworks2["Nextjs"] = "nextjs";
      FronteggFrameworks2["React"] = "react";
      FronteggFrameworks2["Angular"] = "angular";
      FronteggFrameworks2["Vuejs"] = "vuejs";
      FronteggFrameworks2["Flutter"] = "flutter";
      FronteggFrameworks2["Ios"] = "ios";
      FronteggFrameworks2["Android"] = "android";
      FronteggFrameworks2["Vanillajs"] = "vanillajs";
    })(FronteggFrameworks || (FronteggFrameworks = {}));
    (function(PaginationOrderEnum2) {
      PaginationOrderEnum2["ASC"] = "ASC";
      PaginationOrderEnum2["DESC"] = "DESC";
    })(PaginationOrderEnum || (PaginationOrderEnum = {}));
  }
});

// node_modules/@frontegg/rest-api/FetchClient.js
var FetchClient, FetchClient_default;
var init_FetchClient = __esm({
  "node_modules/@frontegg/rest-api/FetchClient.js"() {
    init_extends();
    init_ContextHolder();
    init_error();
    init_constants();
    init_interfaces();
    FetchClient = class _FetchClient {
      constructor(appName) {
        this.appName = void 0;
        this.getFronteggContext = () => {
          return ContextHolder.for(this.appName);
        };
        this.prepareUrl = async (url, params) => {
          const context = this.getFronteggContext().getContext();
          const baseUrl = this.getContextBaseUrl(url);
          const paramsToSend = await this.buildQueryParams(context, params);
          let finalUrl = url.startsWith("http") ? url : `${baseUrl}${url}`;
          const hasKeys = Object.keys(paramsToSend).length > 0;
          if (paramsToSend && hasKeys) {
            const urlParams = new URLSearchParams(paramsToSend);
            finalUrl += `?${urlParams}`;
          }
          return finalUrl;
        };
        this.buildQueryParams = async (context, params) => {
          if (!params) {
            params = {};
          }
          const additionalQueryParams = await this.getAdditionalQueryParams(context);
          for (const queryParam of additionalQueryParams) {
            params[queryParam.key] = queryParam.value;
          }
          const keys = Object.keys(params);
          for (const key of keys) {
            const value = params[key];
            params[key] = typeof value === "object" ? JSON.stringify(value) : value;
          }
          return params;
        };
        this.getAdditionalQueryParams = async (context) => {
          let output = [];
          if (context.additionalQueryParamsResolver) {
            output = await context.additionalQueryParamsResolver();
          }
          return output;
        };
        this.getAdditionalHeaders = async (context) => {
          let output = [];
          if (context.additionalHeadersResolver) {
            output = await context.additionalHeadersResolver();
          }
          if (context.tenantResolver) {
            const resolvedTenantResult = await context.tenantResolver();
            if (!!(resolvedTenantResult != null && resolvedTenantResult.tenant)) {
              output.push({
                key: "frontegg-login-alias",
                value: resolvedTenantResult.tenant
              });
            }
          }
          if (context.appId) {
            output.push({
              key: "frontegg-requested-application-id",
              value: context.appId
            });
          }
          return output;
        };
        this.buildRequestHeaders = async (contentType) => {
          var _context$tokenResolve;
          const fronteggContext = this.getFronteggContext();
          const context = fronteggContext.getContext();
          const headers = _FetchClient.getMetadataHeaders(context);
          const authToken = await ((_context$tokenResolve = context == null ? void 0 : context.tokenResolver) != null ? _context$tokenResolve : fronteggContext.getAccessToken)();
          const requestSource = fronteggContext.getRequestSource();
          const scopedTenant = _FetchClient.getScopedTenant();
          if (contentType) {
            headers[fronteggHeaders.contentType] = contentType;
          }
          if (requestSource) {
            headers[fronteggHeaders.source] = requestSource;
          }
          if (authToken) {
            headers.Authorization = `Bearer ${authToken}`;
          }
          if (scopedTenant) {
            headers[fronteggHeaders.scopedTenant] = scopedTenant;
          }
          for (const additionalHeader of await this.getAdditionalHeaders(context)) {
            headers[`${additionalHeader.key}`] = `${additionalHeader.value}`;
          }
          return headers;
        };
        this.getResponseTraceId = (response) => {
          var _response$headers, _response$headers$get;
          return response == null ? void 0 : (_response$headers = response.headers) == null ? void 0 : (_response$headers$get = _response$headers.get) == null ? void 0 : _response$headers$get.call(_response$headers, FRONTEGG_TRACE_ID);
        };
        this.sendRequest = async (opts) => {
          var _opts$method, _ref, _opts$credentials;
          const context = this.getFronteggContext().getContext();
          const headers = await this.buildRequestHeaders(opts.contentType);
          const url = await this.prepareUrl(opts.url, opts.params);
          const interceptor = context.beforeRequestInterceptor;
          const initialRequestOptions = {
            body: opts.body ? opts.contentType === "application/json" ? JSON.stringify(opts.body) : opts.body : null,
            method: (_opts$method = opts.method) != null ? _opts$method : "GET",
            headers: _extends({}, headers, opts.headers),
            credentials: (_ref = (_opts$credentials = opts.credentials) != null ? _opts$credentials : context.requestCredentials) != null ? _ref : "same-origin"
          };
          const requestOptions = interceptor ? interceptor(initialRequestOptions, url) : initialRequestOptions;
          const response = await fetch(url, requestOptions);
          if (response.status === 302) {
            window.location.href = await response.text();
            return new Promise(() => {
            });
          }
          if (!response.ok) {
            var _errorMessage, _errorMessage2, _context$logLevel, _context$logLevel2, _errorCode;
            if (response.status === 413) {
              throw new FronteggApiError("Error request is too large", response.status, this.getResponseTraceId(response), void 0);
            }
            let errorMessage;
            let errorCode;
            let errorContext;
            let isJsonResponse = true;
            try {
              errorMessage = await response.text();
              errorMessage = JSON.parse(errorMessage);
            } catch (e) {
              isJsonResponse = false;
            }
            if ((_errorMessage = errorMessage) != null && _errorMessage.errorCode) {
              errorCode = errorMessage.errorCode;
            }
            if ((_errorMessage2 = errorMessage) != null && _errorMessage2.context && typeof errorMessage.context === "object") {
              errorContext = errorMessage.context;
            }
            if (errorMessage.errors) {
              errorMessage = errorMessage.errors.join(", ");
            } else if (typeof errorMessage !== "string") {
              errorMessage = `Error ${response.status} - ${response.statusText}`;
            }
            if (response.status >= 400 && response.status < 500 && ["warn"].includes((_context$logLevel = context.logLevel) != null ? _context$logLevel : "")) console.warn(errorMessage);
            else if (response.status === 500 && ["warn", "error"].includes((_context$logLevel2 = context.logLevel) != null ? _context$logLevel2 : "")) console.error(errorMessage);
            throw new FronteggApiError(isJsonResponse ? errorMessage : GENERIC_ERROR_MESSAGE, response.status, this.getResponseTraceId(response), (_errorCode = errorCode) != null ? _errorCode : GENERIC_ERROR_CODE, errorContext);
          }
          if (opts.responseType === "stream") {
            return response.body;
          }
          if (!opts.responseType || opts.responseType === "json") {
            try {
              return await response.json();
            } catch (e) {
              return {};
            }
          } else if (opts.responseType === "blob") {
            const {
              outputFileName
            } = opts.params;
            return await response.blob().then((blob) => URL.createObjectURL(blob)).then((url2) => {
              const tempLink = document.createElement("a");
              tempLink.href = url2;
              tempLink.setAttribute("download", outputFileName || "output");
              tempLink.click();
            });
          } else {
            return await response.text();
          }
        };
        this.get = async (url, params, opts) => this.sendRequest(_extends({
          url,
          method: "GET",
          contentType: "application/json",
          params
        }, opts));
        this.post = async (url, body, opts) => this.sendRequest(_extends({
          url,
          method: "POST",
          contentType: "application/json",
          body
        }, opts));
        this.patch = async (url, body, opts) => this.sendRequest(_extends({
          url,
          method: "PATCH",
          contentType: "application/json",
          body
        }, opts));
        this.put = async (url, body, opts) => this.sendRequest(_extends({
          url,
          method: "PUT",
          contentType: "application/json",
          body
        }, opts));
        this.delete = async (url, body, opts) => this.sendRequest(_extends({
          url,
          method: "DELETE",
          contentType: "application/json",
          body
        }, opts));
        this.postDownload = async (url, body, params, opts) => this.sendRequest(_extends({
          url,
          method: "POST",
          contentType: "application/json",
          responseType: "blob",
          body,
          params
        }, opts));
        this.extractHeadersFromOptions = (options = {}) => _extends({}, options.jwt ? {
          Authorization: options.jwt
        } : {});
        this.getBaseUrl = (context, url, withFronteggPrefix = true) => {
          return _FetchClient.getBaseUrl(context, url, withFronteggPrefix);
        };
        this.getContextBaseUrl = (url, withFronteggPrefix = true) => {
          const context = this.getFronteggContext().getContext();
          return this.getBaseUrl(context, url, withFronteggPrefix);
        };
        this.getMetadataHeaders = (context) => {
          return _FetchClient.getMetadataHeaders(context);
        };
        this.getContextMetadataHeaders = () => {
          const context = this.getFronteggContext().getContext();
          return _FetchClient.getMetadataHeaders(context);
        };
        this.appName = appName;
      }
    };
    FetchClient.getBaseUrl = (context, url, withFronteggPrefix = true) => {
      let baseUrl;
      if (typeof context.baseUrl === "function") {
        baseUrl = context.baseUrl(url);
      } else {
        baseUrl = context.baseUrl;
      }
      const prefix = context.urlPrefix || "frontegg";
      const removePrefix = prefix === "frontegg" && !withFronteggPrefix;
      if (!baseUrl.endsWith("/")) {
        baseUrl += "/";
      }
      if (!baseUrl.endsWith(prefix) && !removePrefix) {
        baseUrl += prefix;
      }
      return baseUrl;
    };
    FetchClient.getMetadataHeaders = (context) => {
      var _context$metadataHead, _context$metadataHead2;
      const headers = {};
      if (context != null && (_context$metadataHead = context.metadataHeaders) != null && _context$metadataHead.fronteggSdkVersion) {
        headers[fronteggHeaders.fronteggSdkVersion] = context.metadataHeaders.fronteggSdkVersion;
      }
      if (context != null && (_context$metadataHead2 = context.metadataHeaders) != null && _context$metadataHead2.framework) {
        headers[fronteggHeaders.frameWork] = context.metadataHeaders.framework;
      }
      return headers;
    };
    FetchClient.getScopedTenant = () => {
      const urlParams = new URLSearchParams(window.location.search);
      const scopedTenant = urlParams.get("tenantId");
      if (scopedTenant) {
        return scopedTenant;
      }
      return null;
    };
    FetchClient_default = new FetchClient("default");
  }
});

// node_modules/@frontegg/rest-api/BaseApiClient.js
var BaseApiClient;
var init_BaseApiClient = __esm({
  "node_modules/@frontegg/rest-api/BaseApiClient.js"() {
    init_FetchClient();
    BaseApiClient = class {
      constructor(appName) {
        this.appName = void 0;
        this.fetchClient = void 0;
        this.get = async (url, params, opts) => {
          return this.fetchClient.get(url, params, opts);
        };
        this.post = async (url, body, opts) => {
          return this.fetchClient.post(url, body, opts);
        };
        this.patch = async (url, body, opts) => {
          return this.fetchClient.patch(url, body, opts);
        };
        this.put = async (url, body, opts) => {
          return this.fetchClient.put(url, body, opts);
        };
        this.delete = async (url, body, opts) => {
          return this.fetchClient.delete(url, body, opts);
        };
        this.postDownload = async (url, body, params, opts) => {
          return this.fetchClient.postDownload(url, body, params, opts);
        };
        this.extractHeadersFromOptions = (options = {}) => {
          return this.fetchClient.extractHeadersFromOptions(options);
        };
        this.appName = appName;
        this.fetchClient = new FetchClient(appName);
      }
    };
  }
});

// node_modules/@frontegg/rest-api/auth/secutiry-poilicy/index.js
var SecurityPolicyApi, secutiry_poilicy_default;
var init_secutiry_poilicy = __esm({
  "node_modules/@frontegg/rest-api/auth/secutiry-poilicy/index.js"() {
    init_BaseApiClient();
    init_constants();
    SecurityPolicyApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getGlobalSecurityPolicy = async () => {
          return this.get(urls.identity.configurations.v1);
        };
        this.getMfaPolicy = async () => {
          return this.get(`${urls.identity.configurations.v1}/mfa-policy`);
        };
        this.getVendorMfaPolicy = async () => {
          return this.get(`${urls.identity.configurations.v1}/mfa-policy/vendor`);
        };
        this.saveMfaPolicy = async (body) => {
          if (body.id) {
            return this.patch(`${urls.identity.configurations.v1}/mfa-policy`, body);
          } else {
            return this.post(`${urls.identity.configurations.v1}/mfa-policy`, body);
          }
        };
        this.getLockoutPolicy = async () => {
          return this.get(`${urls.identity.configurations.v1}/lockout-policy`);
        };
        this.getVendorLockoutPolicy = async () => {
          return this.get(`${urls.identity.configurations.v1}/lockout-policy/vendor`);
        };
        this.saveLockoutPolicy = async (body) => {
          if (body.id) {
            return this.patch(`${urls.identity.configurations.v1}/lockout-policy`, body);
          } else {
            return this.post(`${urls.identity.configurations.v1}/lockout-policy`, body);
          }
        };
        this.getCaptchaPolicy = async () => {
          try {
            return await this.get(`${urls.identity.configurations.v1}/captcha-policy/public`);
          } catch {
            return null;
          }
        };
        this.getPasswordHistoryPolicy = async () => {
          return this.get(`${urls.identity.configurations.v1}/password-history-policy`);
        };
        this.getVendorPasswordHistoryPolicy = async () => {
          return this.get(`${urls.identity.configurations.v1}/password-history-policy/vendor`);
        };
        this.savePasswordHistoryPolicy = async (body) => {
          if (body.id) {
            return this.patch(`${urls.identity.configurations.v1}/password-history-policy`, body);
          } else {
            return this.post(`${urls.identity.configurations.v1}/password-history-policy`, body);
          }
        };
        this.getPasswordRotationPolicy = async () => {
          try {
            return await this.get(`${urls.identity.configurations.v1}/password-rotation`);
          } catch (e) {
            return {};
          }
        };
        this.getVendorPasswordRotationPolicy = async () => {
          try {
            return await this.get(`${urls.identity.configurations.v1}/password-rotation/vendor`);
          } catch (e) {
            return {};
          }
        };
        this.savePasswordRotationPolicy = async (body) => {
          return this.post(`${urls.identity.configurations.v1}/password-rotation`, body);
        };
        this.getPasswordConfigPolicy = async () => {
          return this.get(`${urls.identity.configurations.v1}/password`);
        };
        this.getDomainRestrictions = async () => {
          return this.get(`${urls.identity.restrictions.emailDomain.v1}`);
        };
        this.getDomainRestrictionsConfig = async () => {
          return this.get(`${urls.identity.restrictions.emailDomain.v1}/config`);
        };
        this.createDomainRestriction = async (body) => {
          return this.post(`${urls.identity.restrictions.emailDomain.v1}`, body);
        };
        this.updateDomainRestrictionConfig = async (body) => {
          return this.post(`${urls.identity.restrictions.emailDomain.v1}/config`, body);
        };
        this.deleteDomainRestriction = async (id) => {
          return this.delete(`${urls.identity.restrictions.emailDomain.v1}/${id}`);
        };
        this.getIPRestrictions = async (params) => {
          return this.get(`${urls.identity.restrictions.ip.v1}`, params);
        };
        this.getIPRestrictionsConfig = async () => {
          return this.get(`${urls.identity.restrictions.ip.v1}/config`);
        };
        this.createIPRestriction = async (body) => {
          return this.post(`${urls.identity.restrictions.ip.v1}`, body);
        };
        this.bulkCreateIPRestriction = async (body) => {
          return this.post(`${urls.identity.restrictions.ip.v1}/bulk`, body);
        };
        this.updateIPRestrictionConfig = async (body) => {
          return this.post(`${urls.identity.restrictions.ip.v1}/config`, body);
        };
        this.deleteIPRestriction = async (id) => {
          return this.delete(`${urls.identity.restrictions.ip.v1}/${id}`);
        };
        this.testCurrentIp = async () => {
          return this.post(`${urls.identity.restrictions.ip.v1}/verify`);
        };
        this.testCurrentIpInAllowList = async () => {
          return this.post(`${urls.identity.restrictions.ip.v1}/verify/allow`);
        };
      }
      /** Get global secure access configuration */
    };
    secutiry_poilicy_default = new SecurityPolicyApi("default");
  }
});

// node_modules/@frontegg/rest-api/auth/enums.js
var SocialLoginProviders, AuthStrategyEnum, MachineToMachineAuthStrategy, SignUpStrategyEnum;
var init_enums = __esm({
  "node_modules/@frontegg/rest-api/auth/enums.js"() {
    (function(SocialLoginProviders2) {
      SocialLoginProviders2["Microsoft"] = "microsoft";
      SocialLoginProviders2["Facebook"] = "facebook";
      SocialLoginProviders2["Google"] = "google";
      SocialLoginProviders2["Github"] = "github";
      SocialLoginProviders2["Slack"] = "slack";
      SocialLoginProviders2["Apple"] = "apple";
      SocialLoginProviders2["Linkedin"] = "linkedin";
    })(SocialLoginProviders || (SocialLoginProviders = {}));
    (function(AuthStrategyEnum2) {
      AuthStrategyEnum2["EmailAndPassword"] = "EmailAndPassword";
      AuthStrategyEnum2["MagicLink"] = "MagicLink";
      AuthStrategyEnum2["Code"] = "Code";
      AuthStrategyEnum2["NoLocalAuthentication"] = "NoLocalAuthentication";
      AuthStrategyEnum2["SmsCode"] = "SmsCode";
    })(AuthStrategyEnum || (AuthStrategyEnum = {}));
    (function(MachineToMachineAuthStrategy2) {
      MachineToMachineAuthStrategy2["ClientCredentials"] = "ClientCredentials";
      MachineToMachineAuthStrategy2["AccessToken"] = "AccessToken";
    })(MachineToMachineAuthStrategy || (MachineToMachineAuthStrategy = {}));
    (function(SignUpStrategyEnum2) {
      SignUpStrategyEnum2["Email"] = "email";
      SignUpStrategyEnum2["PhoneNumber"] = "phoneNumber";
    })(SignUpStrategyEnum || (SignUpStrategyEnum = {}));
  }
});

// node_modules/@frontegg/rest-api/auth/constants.js
var FRONTEGG_SEPARATE_TABS_BY_TENANT, USE_CURRENT_USER_TENANTS_V1_ENDPOINT_FF;
var init_constants2 = __esm({
  "node_modules/@frontegg/rest-api/auth/constants.js"() {
    FRONTEGG_SEPARATE_TABS_BY_TENANT = "FRONTEGG_SEPARATE_TABS_BY_TENANT";
    USE_CURRENT_USER_TENANTS_V1_ENDPOINT_FF = "admin_portal_use_current_user_tenants_v1_endpoint";
  }
});

// node_modules/@frontegg/rest-api/feature-flags/index.js
var defaultFeatureFlags, FeatureFlags, FeatureFlagsApi, feature_flags_default;
var init_feature_flags = __esm({
  "node_modules/@frontegg/rest-api/feature-flags/index.js"() {
    init_extends();
    init_constants();
    init_BaseApiClient();
    defaultFeatureFlags = {
      flags: {}
    };
    FeatureFlags = class _FeatureFlags {
      constructor() {
        var _defaultFeatureFlags$;
        this._flags = {};
        this._flags = (_defaultFeatureFlags$ = defaultFeatureFlags.flags) != null ? _defaultFeatureFlags$ : {};
      }
      static getInstance(name = "default") {
        return this._instances[name];
      }
      static set(featureFlags, name = "default") {
        const featureFlagsInstance = new _FeatureFlags();
        featureFlagsInstance.set(featureFlags);
        _FeatureFlags._instances[name] = featureFlagsInstance;
        return featureFlagsInstance;
      }
      static getFeatureFlags(flags, name) {
        const featureFlagsInstance = this.getInstance(name);
        return flags.map((flag) => (featureFlagsInstance == null ? void 0 : featureFlagsInstance._flags[flag]) === "on");
      }
      get flags() {
        var _this$flags;
        return (_this$flags = this.flags) != null ? _this$flags : {};
      }
      set(featureFlags) {
        var _defaultFeatureFlags$2;
        this._flags = _extends({}, (_defaultFeatureFlags$2 = defaultFeatureFlags == null ? void 0 : defaultFeatureFlags.flags) != null ? _defaultFeatureFlags$2 : {}, featureFlags != null ? featureFlags : {});
      }
    };
    FeatureFlags._instances = {};
    FeatureFlagsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.loadFeatureFlags = async () => {
          return this.get(urls.featureFlags.v1);
        };
      }
    };
    feature_flags_default = new FeatureFlagsApi("default");
  }
});

// node_modules/@frontegg/rest-api/users/index.js
var UsersApi, users_default;
var init_users = __esm({
  "node_modules/@frontegg/rest-api/users/index.js"() {
    init_extends();
    init_constants();
    init_BaseApiClient();
    UsersApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.GetUserJwt = async (body) => {
          return this.post(`${urls.identity.users.v3}/me/token`, body);
        };
        this.getUsersV2 = async (queryParams, options) => {
          return this.get(urls.identity.users.v2, queryParams, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getUsersV3 = async (queryParams, options) => {
          return this.get(urls.identity.users.v3, queryParams, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getUsersRoles = async (queryParams, options) => {
          return this.get(urls.identity.users.roles.v3, _extends({}, queryParams, {
            ids: queryParams.ids.join(",")
          }), {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getUsersGroups = async (queryParams, options) => {
          return this.get(urls.identity.users.groups.v3, _extends({}, queryParams, {
            ids: queryParams.ids.join(",")
          }), {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getCurrentUserTenantsV3 = async (options) => {
          return this.get(urls.identity.users.tenants.me.v3, void 0, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getCurrentUserTenantsV1 = async (options) => {
          return this.get(urls.identity.users.tenants.me.v1, void 0, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.sendResetBreachedPasswordEmails = async () => {
          return this.post(urls.identity.users.passwords.resetBreachedPasswords.v1);
        };
        this.updateUserProfileV2 = async (body) => {
          return this.put(`${urls.identity.users.v2}/me`, body);
        };
        this.unlockMe = async (body) => {
          return this.post(`${urls.identity.users.v3}/me/unlock`, body);
        };
      }
    };
    users_default = new UsersApi("default");
  }
});

// node_modules/@frontegg/rest-api/auth/utils.js
async function executeConditionalPromise({
  shouldLoad,
  action
}) {
  if (!shouldLoad) return;
  return await action();
}
function setTabTenantInSessionStorage(tenantId) {
  if (!tenantId) {
    return;
  }
  sessionStorage.setItem(FRONTEGG_SEPARATE_TABS_BY_TENANT, tenantId);
}
function removeTabTenantFromSessionStorage() {
  sessionStorage.removeItem(FRONTEGG_SEPARATE_TABS_BY_TENANT);
}
function getTabTenantFromSessionStorage(appName) {
  if (!ContextHolder.for(appName).isSessionPerTenantEnabled()) {
    return null;
  }
  return sessionStorage.getItem(FRONTEGG_SEPARATE_TABS_BY_TENANT);
}
function getCurrentUserTenantsFunction(appName) {
  const skipUserLoading = ContextHolder.for(appName).shouldSkipUserLoad();
  if (skipUserLoading) {
    return async () => ({
      tenants: [],
      activeTenant: {}
    });
  }
  const usersApi = new UsersApi(appName);
  const [useCurrentUserTenantsV1] = FeatureFlags.getFeatureFlags([USE_CURRENT_USER_TENANTS_V1_ENDPOINT_FF], appName);
  if (ContextHolder.for(appName).isSessionPerTenantEnabled()) {
    return usersApi.getCurrentUserTenantsV1;
  }
  return useCurrentUserTenantsV1 ? usersApi.getCurrentUserTenantsV1 : usersApi.getCurrentUserTenantsV3;
}
var init_utils2 = __esm({
  "node_modules/@frontegg/rest-api/auth/utils.js"() {
    init_ContextHolder();
    init_constants2();
    init_feature_flags();
    init_users();
    init_constants2();
  }
});

// node_modules/@frontegg/rest-api/jwt.js
function polyfill(input) {
  const str = String(input).replace(/=+$/, "");
  if (str.length % 4 === 1) {
    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
  }
  let output = "";
  for (
    let bc = 0, bs, buffer, idx = 0;
    // get next character
    // tslint:disable-next-line:no-conditional-assignment
    buffer = str.charAt(idx++);
    // character found in table? initialize bit storage and add its ascii value;
    // tslint:disable-next-line:no-conditional-assignment
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,
    // convert the first 8 bits to one ascii character
    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
  ) {
    buffer = chars.indexOf(buffer);
  }
  return output;
}
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob2(str).replace(/(.)/g, (m, p) => {
    let code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
var chars, InvalidCharacterError, atob2, base64UrlDecode, InvalidTokenError, jwtDecode;
var init_jwt = __esm({
  "node_modules/@frontegg/rest-api/jwt.js"() {
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    InvalidCharacterError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    atob2 = typeof window !== "undefined" && window.atob && window.atob.bind(window) || polyfill;
    base64UrlDecode = (str) => {
      let output = str.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
        case 0:
          break;
        case 2:
          output += "==";
          break;
        case 3:
          output += "=";
          break;
        default:
          throw new Error("Illegal base64url string!");
      }
      try {
        return b64DecodeUnicode(output);
      } catch (err) {
        return atob2(output);
      }
    };
    InvalidTokenError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    jwtDecode = (token, options = {}) => {
      const pos = !!options.header ? 0 : 1;
      try {
        return JSON.parse(base64UrlDecode(token.split(".")[pos]));
      } catch (e) {
        throw new InvalidTokenError("Invalid token specified: " + e.message);
      }
    };
  }
});

// node_modules/@frontegg/rest-api/auth/secutiry-poilicy/interfaces.js
var RestrictionType;
var init_interfaces2 = __esm({
  "node_modules/@frontegg/rest-api/auth/secutiry-poilicy/interfaces.js"() {
    (function(RestrictionType2) {
      RestrictionType2["ALLOW"] = "ALLOW";
      RestrictionType2["BLOCK"] = "BLOCK";
    })(RestrictionType || (RestrictionType = {}));
  }
});

// node_modules/@frontegg/rest-api/auth/interfaces.js
var SecondaryAuthStrategy, WebAuthnDeviceType, MFAStrategyEnum, LOAD_AUTHORIZATION_FF;
var init_interfaces3 = __esm({
  "node_modules/@frontegg/rest-api/auth/interfaces.js"() {
    init_interfaces2();
    (function(SecondaryAuthStrategy2) {
      SecondaryAuthStrategy2["WebAuthnPlatform"] = "WebAuthnPlatform";
      SecondaryAuthStrategy2["WebAuthnCrossPlatform"] = "WebAuthnCrossPlatform";
      SecondaryAuthStrategy2["SmsCode"] = "SmsCode";
      SecondaryAuthStrategy2["SmsCodeV2"] = "SmsCodeV2";
      SecondaryAuthStrategy2["Passkeys"] = "Passkeys";
    })(SecondaryAuthStrategy || (SecondaryAuthStrategy = {}));
    (function(WebAuthnDeviceType2) {
      WebAuthnDeviceType2["Platform"] = "Platform";
      WebAuthnDeviceType2["CrossPlatform"] = "CrossPlatform";
    })(WebAuthnDeviceType || (WebAuthnDeviceType = {}));
    (function(MFAStrategyEnum2) {
      MFAStrategyEnum2["AuthenticatorApp"] = "AuthenticatorApp";
      MFAStrategyEnum2["WebAuthnPlatform"] = "WebAuthnPlatform";
      MFAStrategyEnum2["WebAuthnCrossPlatform"] = "WebAuthnCrossPlatform";
      MFAStrategyEnum2["SMS"] = "SMS";
      MFAStrategyEnum2["EmailCode"] = "EmailCode";
    })(MFAStrategyEnum || (MFAStrategyEnum = {}));
    LOAD_AUTHORIZATION_FF = "admin_portal_should_load_authorization";
  }
});

// node_modules/@frontegg/rest-api/tenants/index.js
var TenantsApi, tenants_default;
var init_tenants = __esm({
  "node_modules/@frontegg/rest-api/tenants/index.js"() {
    init_extends();
    init_constants();
    init_utils2();
    init_ContextHolder();
    init_BaseApiClient();
    TenantsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.switchTenant = async (body) => {
          if (ContextHolder.for(this.appName).isSessionPerTenantEnabled()) {
            setTabTenantInSessionStorage(body.tenantId);
          }
          return this.put(`${urls.identity.users.v1}/tenant`, body);
        };
        this.getTenants = async () => {
          return this.get(`${urls.identity.users.v2}/me/tenants`);
        };
        this.getSubTenants = async (options) => {
          return this.get(urls.tenants.hierarchy.v1, void 0, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getSubTenantsAsTree = async (options) => {
          return this.get(urls.tenants.hierarchy.tree.v1, void 0, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getParentTenants = async (options) => {
          return this.get(urls.tenants.hierarchy.parents.v1, void 0, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getParentTenantsById = async (tenantId, options) => {
          return this.get(`${urls.tenants.hierarchy.parents.v1}/${tenantId}`, void 0, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getTenantsUsersCount = async (body, options) => {
          return this.post(`${urls.identity.tenants.users.v1}/count`, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.searchSubTenants = async (params, options) => {
          return this.get(urls.tenants.hierarchy.v2, params, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getHierarchyMetadata = async (params, options) => {
          return this.get(urls.tenants.hierarchy.metadata.v2, _extends({}, params, {
            _tenantIds: params._tenantIds.join(",")
          }), {
            headers: this.extractHeadersFromOptions(options)
          });
        };
      }
      /**
       * Switch logged in user to specific tenant by providing tenantId.
       * @throws exception if invalid tenantId.
       */
    };
    tenants_default = new TenantsApi("default");
  }
});

// node_modules/@frontegg/rest-api/entitlements/index.js
var EntitlementsApi, entitlements_default;
var init_entitlements = __esm({
  "node_modules/@frontegg/rest-api/entitlements/index.js"() {
    init_constants();
    init_BaseApiClient();
    EntitlementsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.loadEntitlementsV2 = async () => {
          return this.get(urls.entitlements.v2);
        };
      }
      /**
       * Load user entitlements data v2.
       * Including all user permissions and features data.
       * Now the final isEntitled response is not part of it, but includes the data needed to calculate it.
       *
       * `authorized user`
       */
    };
    entitlements_default = new EntitlementsApi("default");
  }
});

// node_modules/@frontegg/rest-api/auth/index.js
var _excluded2, _excluded22, _excluded3, AuthenticationApi, auth_default;
var init_auth = __esm({
  "node_modules/@frontegg/rest-api/auth/index.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_secutiry_poilicy();
    init_enums();
    init_constants2();
    init_utils2();
    init_constants();
    init_jwt();
    init_interfaces3();
    init_feature_flags();
    init_utils2();
    init_tenants();
    init_BaseApiClient();
    init_entitlements();
    init_ContextHolder();
    init_secutiry_poilicy();
    _excluded2 = ["type"];
    _excluded22 = ["type"];
    _excluded3 = ["type"];
    AuthenticationApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.tenantsApi = new TenantsApi(this.appName);
        this.entitlementsApi = new EntitlementsApi(this.appName);
        this.securityPolicy = new SecurityPolicyApi(this.appName);
        this.generateLoginResponse = async (loginResponse) => {
          if (!loginResponse.accessToken) {
            return loginResponse;
          }
          const contextHolder = ContextHolder.for(this.appName);
          contextHolder.setAccessToken(loginResponse.accessToken);
          const me = await this.getMeAndEntitlements();
          const decodedContent = loginResponse.accessToken ? jwtDecode(loginResponse.accessToken) : {};
          const user = _extends({}, loginResponse, decodedContent, me);
          contextHolder.setUser(user);
          return user;
        };
        this.generateLoginResponseV2 = async (loginResponse) => {
          if (!loginResponse.accessToken) {
            return {
              user: loginResponse
            };
          }
          const contextHolder = ContextHolder.for(this.appName);
          contextHolder.setAccessToken(loginResponse.accessToken);
          const [me, tenants] = await Promise.all([this.getMeAndEntitlements(), this.tenantsApi.getTenants()]);
          const decodedContent = loginResponse.accessToken ? jwtDecode(loginResponse.accessToken) : {};
          const user = _extends({}, loginResponse, decodedContent, me);
          contextHolder.setUser(user);
          return {
            user,
            tenants
          };
        };
        this.generateLoginResponseV3 = async (loginResponse) => {
          const {
            accessToken
          } = loginResponse;
          if (!accessToken) {
            return {
              user: loginResponse
            };
          }
          const contextHolder = ContextHolder.for(this.appName);
          contextHolder.setAccessToken(accessToken);
          const [me, currentUserTenants] = await Promise.all([this.getMeAndEntitlements(), getCurrentUserTenantsFunction(this.appName)()]);
          const decodedContent = accessToken ? jwtDecode(accessToken) : {};
          const user = _extends({}, loginResponse, decodedContent, me);
          if (contextHolder.isSessionPerTenantEnabled()) {
            setTabTenantInSessionStorage(user.tenantId);
          }
          contextHolder.setUser(user);
          return {
            user,
            tenants: currentUserTenants.tenants,
            activeTenant: currentUserTenants.activeTenant
          };
        };
        this.generateLoginResponseFromOAuthResponse = async (oauthResponse) => {
          const contextHolder = ContextHolder.for(this.appName);
          contextHolder.setAccessToken(oauthResponse.id_token);
          const me = await this.getMeAndEntitlements();
          const decodedContent = oauthResponse.id_token ? jwtDecode(oauthResponse.id_token) : {};
          const user = _extends({
            mfaRequired: false,
            accessToken: oauthResponse.id_token,
            refreshToken: oauthResponse.refresh_token
          }, decodedContent, me, {
            expiresIn: oauthResponse.expires_in || 300
          });
          contextHolder.setUser(user);
          return user;
        };
        this.generateLoginResponseFromOAuthResponseV2 = async (oauthResponse) => {
          const contextHolder = ContextHolder.for(this.appName);
          contextHolder.setAccessToken(oauthResponse.id_token);
          const [me, currentUserTenants] = await Promise.all([this.getMeAndEntitlements(), getCurrentUserTenantsFunction(this.appName)()]);
          const decodedContent = oauthResponse.id_token ? jwtDecode(oauthResponse.id_token) : {};
          const user = _extends({
            mfaRequired: false,
            accessToken: oauthResponse.id_token,
            refreshToken: oauthResponse.refresh_token
          }, decodedContent, me, {
            expiresIn: oauthResponse.expires_in || 300
          });
          if (contextHolder.isSessionPerTenantEnabled()) {
            setTabTenantInSessionStorage(user.tenantId);
          }
          contextHolder.setUser(user);
          return {
            user,
            tenants: currentUserTenants.tenants,
            activeTenant: currentUserTenants.activeTenant
          };
        };
        this.preLogin = async (body) => {
          try {
            const {
              address
            } = await this.post(`${urls.identity.auth.v1}/user/saml/prelogin`, body);
            return address;
          } catch {
            return null;
          }
        };
        this.preLoginWithIdpType = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/saml/prelogin`, body);
        };
        this.postLogin = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/saml/postlogin`, body);
          return this.generateLoginResponse(data);
        };
        this.oidcPostLogin = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/oidc/postlogin`, body);
          return this.generateLoginResponse(data);
        };
        this.login = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user`, body);
          return this.generateLoginResponse(data);
        };
        this.loginv2 = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user`, body);
          return this.generateLoginResponseV3(data);
        };
        this.loginWithMfa = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/mfa/verify`, body);
          return this.generateLoginResponse(data);
        };
        this.loginWithMfaV2 = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/mfa/verify`, body);
          return this.generateLoginResponseV3(data);
        };
        this.activateAccount = async (body) => {
          return this.post(`${urls.identity.users.v1}/activate`, body);
        };
        this.activateAccountV2 = async (body) => {
          const data = await this.post(`${urls.identity.users.v1}/activate`, body);
          return this.generateLoginResponseV3(data);
        };
        this.activateAccountWithOTC = async (body) => {
          const data = await this.post(`${urls.identity.users.v1}/activate/code`, body);
          return this.generateLoginResponseV3(data);
        };
        this.getActivateAccountStrategy = async (params) => {
          return this.get(`${urls.identity.users.v1}/activate/strategy`, params);
        };
        this.resendActivationEmail = async (body) => {
          return this.post(`${urls.identity.users.v1}/activate/reset`, body);
        };
        this.resendInvitationEmail = async (body) => {
          return this.post(`${urls.identity.users.v1}/invitation/reset`, body);
        };
        this.acceptInvitation = async (body) => {
          return this.post(`${urls.identity.users.v1}/invitation/accept`, body);
        };
        this.acceptInvitationWithOTC = async (body) => {
          return this.post(`${urls.identity.users.v1}/invitation/accept/code`, body);
        };
        this.refreshToken = async () => {
          const tabTenantId = getTabTenantFromSessionStorage(this.appName);
          const data = await this.post(`${urls.identity.auth.v1}/user/token/refresh`, {
            tenantId: tabTenantId
          });
          return this.generateLoginResponse(data);
        };
        this.refreshTokenV2 = async () => {
          const tabTenantId = getTabTenantFromSessionStorage(this.appName);
          const data = await this.post(`${urls.identity.auth.v1}/user/token/refresh`, {
            tenantId: tabTenantId
          });
          return this.generateLoginResponseV2(data);
        };
        this.refreshTokenV3 = async () => {
          const tabTenantId = getTabTenantFromSessionStorage(this.appName);
          const data = await this.post(`${urls.identity.auth.v1}/user/token/refresh`, {
            tenantId: tabTenantId
          });
          return this.generateLoginResponseV3(data);
        };
        this.logout = async () => {
          return this.post(`${urls.identity.auth.v1}/logout`);
        };
        this.OAuthLogout = async (params) => {
          return this.get(`${urls.oauth.v1}/logout`, params);
        };
        this.forgotPassword = async (body) => {
          return this.post(`${urls.identity.users.v1}/passwords/reset`, body);
        };
        this.resetPassword = async (body) => {
          return this.post(`${urls.identity.users.v1}/passwords/reset/verify`, body);
        };
        this.loadPasswordConfig = async (params) => {
          return this.get(`${urls.identity.users.v1}/passwords/config`, params);
        };
        this.getSignUpStrategies = async () => {
          return this.get(`${urls.identity.signup.v1.strategies}`);
        };
        this.recoverMfaToken = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/recover`, body);
        };
        this.enrollMfa = async () => {
          return this.post(`${urls.identity.users.v1}/mfa/enroll`);
        };
        this.preEnrollMFAAuthenticatorApp = async () => {
          return this.post(`${urls.identity.users.v1}/mfa/authenticator/enroll`);
        };
        this.enrollMFAAuthenticatorApp = async (body) => {
          return this.post(`${urls.identity.users.v1}/mfa/authenticator/enroll/verify`, body);
        };
        this.preEnrollMFASMS = async (body) => {
          return this.post(`${urls.identity.users.v1}/mfa/sms/enroll`, body);
        };
        this.enrollMFASMS = async (body) => {
          return this.post(`${urls.identity.users.v1}/mfa/sms/enroll/verify`, body);
        };
        this.preEnrollMFAWebAuthn = async () => {
          return this.post(`${urls.identity.users.v1}/mfa/webauthn/enroll`);
        };
        this.enrollMFAWebAuthn = async (body) => {
          return this.post(`${urls.identity.users.v1}/mfa/webauthn/enroll/verify`, body);
        };
        this.verifyMfa = async (body) => {
          return this.post(`${urls.identity.users.v1}/mfa/enroll/verify`, body);
        };
        this.disableMfa = async (body) => {
          return this.post(`${urls.identity.users.v1}/mfa/disable`, body);
        };
        this.disableMFAAuthenticatorApp = async (deviceId, body) => {
          return this.post(`${urls.identity.users.v1}/mfa/authenticator/${deviceId}/disable/verify`, body);
        };
        this.preDisableMFASMS = async (deviceId) => {
          return this.post(`${urls.identity.users.v1}/mfa/sms/${deviceId}/disable`);
        };
        this.disableMFASMS = async (deviceId, body) => {
          return this.post(`${urls.identity.users.v1}/mfa/sms/${deviceId}/disable/verify`, body);
        };
        this.preDisableMFAWebAuthn = async (deviceId) => {
          return this.post(`${urls.identity.users.v1}/mfa/webauthn/${deviceId}/disable`);
        };
        this.disableMFAWebAuthn = async (deviceId, body) => {
          return this.post(`${urls.identity.users.v1}/mfa/webauthn/${deviceId}/disable/verify`, body);
        };
        this.getMFADevices = async () => {
          return this.get(`${urls.identity.users.v1}/mfa/devices`);
        };
        this.preEnrollMFAAuthenticatorAppForLogin = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/authenticator/enroll`, body);
        };
        this.enrollMFAAuthenticatorAppForLogin = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/authenticator/enroll/verify`, body);
        };
        this.enrollMFAAuthenticatorAppForLoginV2 = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/mfa/authenticator/enroll/verify`, body);
          return this.generateLoginResponseV3(data);
        };
        this.verifyMFAAuthenticatorAppForLogin = async (deviceId, body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/authenticator/${deviceId}/verify`, body);
        };
        this.preVerifyMFAEmailCode = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/emailcode`, body);
        };
        this.verifyMFAEmailCode = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/emailcode/verify`, body);
        };
        this.verifyMFAEmailCodeV2 = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/mfa/emailcode/verify`, body);
          return this.generateLoginResponseV3(data);
        };
        this.preEnrollMFASMSForLogin = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/sms/enroll`, body);
        };
        this.enrollMFASMSForLogin = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/sms/enroll/verify`, body);
        };
        this.enrollMFASMSForLoginV2 = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/mfa/sms/enroll/verify`, body);
          return this.generateLoginResponseV3(data);
        };
        this.preVerifyMFASMSForLogin = async (deviceId, body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/sms/${deviceId}`, body);
        };
        this.verifyMFASMSForLogin = async (deviceId, body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/sms/${deviceId}/verify`, body);
        };
        this.verifyMFASMSForLoginV2 = async (deviceId, body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/mfa/sms/${deviceId}/verify`, body);
          return this.generateLoginResponseV3(data);
        };
        this.preEnrollMFAWebAuthnForLogin = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/webauthn/enroll`, body);
        };
        this.enrollMFAWebAuthnForLogin = async (body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/webauthn/enroll/verify`, body);
        };
        this.enrollMFAWebAuthnForLoginV2 = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/mfa/webauthn/enroll/verify`, body);
          return this.generateLoginResponseV3(data);
        };
        this.preVerifyMFAWebAuthnForLogin = async (deviceId, body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/webauthn/${deviceId}`, body);
        };
        this.verifyMFAWebAuthnForLogin = async (deviceId, body) => {
          return this.post(`${urls.identity.auth.v1}/user/mfa/webauthn/${deviceId}/verify`, body);
        };
        this.verifyMFAWebAuthnForLoginV2 = async (deviceId, body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/mfa/webauthn/${deviceId}/verify`, body);
          return this.generateLoginResponseV3(data);
        };
        this.getSamlConfiguration = async () => {
          return this.get(`${urls.team.sso.v1}/saml/configurations`);
        };
        this.updateSamlConfiguration = async (body) => {
          return this.post(`${urls.team.sso.v1}/saml/configurations`, body);
        };
        this.getSamlVendorConfiguration = async () => {
          return this.get(`${urls.team.sso.v1}/saml/configurations/vendor-config`);
        };
        this.updateSamlVendorMetadata = async (body) => {
          return this.put(`${urls.team.sso.v1}/saml/configurations/metadata`, body);
        };
        this.validateSamlDomain = async () => {
          return this.put(`${urls.team.sso.v1}/saml/validations/domain`);
        };
        this.getSamlRoles = async () => {
          return this.get(`${urls.team.sso.v1}/saml/configurations/roles/default`);
        };
        this.getSamlRolesGroups = async () => {
          return this.get(`${urls.team.sso.v2}/saml/configurations/groups`);
        };
        this.updateSamlRoles = async ({
          roleIds
        }) => {
          return this.post(`${urls.team.sso.v1}/saml/configurations/roles/default`, {
            roleIds
          });
        };
        this.createSamlGroup = async ({
          roleIds,
          group
        }) => {
          return this.post(`${urls.team.sso.v2}/saml/configurations/groups`, {
            group,
            roleIds
          });
        };
        this.updateSamlGroup = async ({
          roleIds,
          group,
          id
        }) => {
          return this.patch(`${urls.team.sso.v2}/saml/configurations/groups/${id}`, {
            group,
            roleIds
          });
        };
        this.deleteSamlGroup = async ({
          id
        }) => {
          return this.delete(`${urls.team.sso.v2}/saml/configurations/groups/${id}`);
        };
        this.getOidcConfiguration = async () => {
          return this.get(`${urls.team.sso.v1}/oidc/configurations`);
        };
        this.getSSOPublicConfiguration = async () => {
          return this.get(`${urls.team.sso.v2}/configurations/public`);
        };
        this.getSocialLoginProviders = async () => {
          return this.get(urls.identity.sso.v1);
        };
        this.getSocialLoginProvidersV2 = async () => {
          return this.get(urls.identity.sso.v2);
        };
        this.getSocialLoginProvidersV2ForAuthenticatedUser = async () => {
          return this.get(`${urls.identity.sso.v2}/authenticated`);
        };
        this.getCustomSocialLoginProvidersV1 = async () => {
          return this.get(urls.identity.sso.custom.v1);
        };
        this.loginViaSocialLogin = async (params) => {
          const queryParams = {};
          if (params.code) {
            queryParams.code = params.code;
          }
          if (params.idToken) {
            queryParams.id_token = params.idToken;
          }
          if (params.redirectUri) {
            queryParams.redirectUri = params.redirectUri;
          }
          if (params.codeVerifier) {
            queryParams.code_verifier = params.codeVerifier;
          }
          if (params.codeVerifierPkce) {
            queryParams.code_verifier_pkce = params.codeVerifierPkce;
          }
          if (params.state) {
            queryParams.state = params.state;
          }
          return this.post(`${urls.identity.auth.v1}/user/sso/${params.provider}/postlogin`, {
            metadata: params.metadata,
            invitationToken: params.invitationToken
          }, {
            params: queryParams
          });
        };
        this.getVendorConfig = async () => {
          return this.get(`${urls.identity.configurations.v1}/public`);
        };
        this.signUpUser = async (body) => {
          const {
            shouldActivate,
            authResponse,
            userId,
            tenantId,
            activationToken
          } = await this.post(`${urls.identity.users.v1}/signUp`, body);
          const response = {
            shouldActivate,
            userId,
            tenantId
          };
          if (!shouldActivate && authResponse) {
            const {
              user,
              tenants,
              activeTenant
            } = await this.generateLoginResponseV3(authResponse);
            return _extends({}, response, {
              user,
              tenants,
              activeTenant
            });
          }
          return _extends({}, response, {
            activationToken
          });
        };
        this.signUpUserWithPhoneNumber = async (body) => {
          const {
            shouldActivate,
            authResponse,
            userId,
            tenantId,
            activationToken
          } = await this.post(`${urls.identity.users.v1}/signUp/phoneNumber`, body);
          const response = {
            shouldActivate,
            userId,
            tenantId
          };
          if (!shouldActivate && authResponse) {
            const {
              user,
              tenants,
              activeTenant
            } = await this.generateLoginResponseV3(authResponse);
            return _extends({}, response, {
              user,
              tenants,
              activeTenant
            });
          }
          return _extends({}, response, {
            activationToken
          });
        };
        this.getCurrentUserSessions = async () => {
          return this.get(urls.identity.users.sessions.currentUser.v1);
        };
        this.getCurrentUserSession = async () => {
          return this.get(`${urls.identity.users.sessions.currentUser.v1}/current`);
        };
        this.revokeSessionsForUser = async (userId) => {
          return this.post(`${urls.identity.users.sessions.v1}/revoke`, {
            userId
          });
        };
        this.getSessionConfigurations = async () => {
          return this.get(urls.identity.users.sessions.configurations.v1);
        };
        this.createOrUpdateSessionConfigrations = async (body) => {
          await this.post(urls.identity.users.sessions.configurations.v1, body);
        };
        this.deleteSessionForUser = async (id) => {
          await this.delete(`${urls.identity.users.sessions.currentUser.v1}/${id}`);
        };
        this.deleteAllSessionsForUser = async () => {
          await this.delete(`${urls.identity.users.sessions.currentUser.v1}/all`);
        };
        this.getUserAccessTokensData = async () => {
          return this.get(urls.identity.users.accessTokens.v1);
        };
        this.getTenantAccessTokensData = async () => {
          return this.get(urls.identity.tenants.accessTokens.v1);
        };
        this.deleteTenantAccessToken = async ({
          id
        }) => {
          await this.delete(`${urls.identity.tenants.accessTokens.v1}/${id}`);
        };
        this.deleteUserAccessToken = async ({
          id
        }) => {
          await this.delete(`${urls.identity.users.accessTokens.v1}/${id}`);
        };
        this.createUserAccessToken = async (body) => {
          return this.post(urls.identity.users.accessTokens.v1, body);
        };
        this.createTenantAccessToken = async (body) => {
          return this.post(urls.identity.tenants.accessTokens.v1, body);
        };
        this.getUserApiTokensData = async () => {
          return this.get(urls.identity.users.apiTokens.v1);
        };
        this.getTenantApiTokensData = async () => {
          return this.get(urls.identity.tenants.apiTokens.v1);
        };
        this.updateUserApiTokensData = async (body) => {
          return this.post(urls.identity.users.apiTokens.v1, body);
        };
        this.updateTenantApiTokensData = async (body) => {
          return this.post(urls.identity.tenants.apiTokens.v2, body);
        };
        this.deleteTenantApiToken = async ({
          tokenId
        }) => {
          await this.delete(`${urls.identity.tenants.apiTokens.v1}/${tokenId}`);
        };
        this.deleteUserApiToken = async ({
          tokenId
        }) => {
          await this.delete(`${urls.identity.users.apiTokens.v1}/${tokenId}`);
        };
        this.getUserById = async ({
          userId
        }) => {
          return this.get(`${urls.identity.users.v1}/${userId}`);
        };
        this.checkIfAllowToRememberMfaDevice = async (mfaToken) => {
          return this.get(`${urls.identity.configurations.v1}/mfa-policy/allow-remember-device`, {
            mfaToken
          });
        };
        this.passwordlessPreLogin = async (_ref) => {
          let {
            type
          } = _ref, body = _objectWithoutPropertiesLoose(_ref, _excluded2);
          return this.post(`${urls.identity.auth.v1}/passwordless/${type.toLocaleLowerCase()}/prelogin`, body);
        };
        this.passwordlessPostLoginV2 = async (_ref2) => {
          let {
            type
          } = _ref2, body = _objectWithoutPropertiesLoose(_ref2, _excluded22);
          const data = await this.post(`${urls.identity.auth.v1}/passwordless/${type.toLocaleLowerCase()}/postlogin`, body);
          return this.generateLoginResponseV3(data);
        };
        this.passwordlessPostLogin = async (_ref3) => {
          let {
            type
          } = _ref3, body = _objectWithoutPropertiesLoose(_ref3, _excluded3);
          return this.post(`${urls.identity.auth.v1}/passwordless/${type.toLocaleLowerCase()}/postlogin`, body);
        };
        this.verifyInviteToken = async ({
          token
        }) => {
          return this.post(urls.identity.tenants.invites.verify.v1, {
            token
          });
        };
        this.getSSOConfigurations = async () => {
          return this.get(`${urls.team.sso.v1}/configurations`);
        };
        this.createSSOConfiguration = async (body) => {
          return this.post(`${urls.team.sso.v1}/configurations`, body);
        };
        this.updateSSOConfiguration = async (ssoConfigId, body) => {
          return this.patch(`${urls.team.sso.v1}/configurations/${ssoConfigId}`, body);
        };
        this.deleteSSOConfiguration = async (ssoConfigId) => {
          await this.delete(`${urls.team.sso.v1}/configurations/${ssoConfigId}`);
        };
        this.createSSOConfigurationByMetadata = async (body) => {
          return this.post(`${urls.team.sso.v1}/configurations/metadata`, body);
        };
        this.updateSSOConfigurationByMetadata = async (ssoConfigId, body) => {
          return this.put(`${urls.team.sso.v1}/configurations/${ssoConfigId}/metadata`, body);
        };
        this.createSSOConfigurationByMetadataUrl = async (body) => {
          return this.post(`${urls.team.sso.v1}/configurations/metadata-url`, body);
        };
        this.updateSSOConfigurationByMetadataUrl = async (ssoConfigId, body) => {
          return this.put(`${urls.team.sso.v1}/configurations/${ssoConfigId}/metadata-url`, body);
        };
        this.createSSODomain = async (ssoConfigId, body) => {
          return this.post(`${urls.team.sso.v1}/configurations/${ssoConfigId}/domains`, body);
        };
        this.deleteSSODomain = async (ssoConfigId, domainId) => {
          return this.delete(`${urls.team.sso.v1}/configurations/${ssoConfigId}/domains/${domainId}`);
        };
        this.validateSSODomain = async (ssoConfigId, domainId) => {
          return this.put(`${urls.team.sso.v1}/configurations/${ssoConfigId}/domains/${domainId}/validate`);
        };
        this.validateSSODomainV2 = async (ssoConfigId, domainId) => {
          return this.put(`${urls.team.sso.v2}/configurations/${ssoConfigId}/domains/${domainId}/validate`);
        };
        this.getSSODefaultRoles = async (ssoConfigId) => {
          return this.get(`${urls.team.sso.v1}/configurations/${ssoConfigId}/roles`);
        };
        this.setSSODefaultRoles = async (ssoConfigId, body) => {
          return this.put(`${urls.team.sso.v1}/configurations/${ssoConfigId}/roles`, body);
        };
        this.createSSOGroup = async (ssoConfigId, body) => {
          return this.post(`${urls.team.sso.v1}/configurations/${ssoConfigId}/groups`, body);
        };
        this.updateSSOGroup = async (ssoConfigId, {
          roleIds,
          group,
          id
        }) => {
          return this.patch(`${urls.team.sso.v1}/configurations/${ssoConfigId}/groups/${id}`, {
            group,
            roleIds
          });
        };
        this.deleteSSOGroup = async (ssoConfigId, groupId) => {
          return this.delete(`${urls.team.sso.v1}/configurations/${ssoConfigId}/groups/${groupId}`);
        };
        this.getSSOGroups = async (ssoConfigId) => {
          return this.get(`${urls.team.sso.v1}/configurations/${ssoConfigId}/groups`);
        };
        this.preLoginV2 = async (body) => {
          return this.post(`${urls.identity.auth.v2}/user/sso/prelogin`, body);
        };
        this.oidcPostLoginV2 = async (body) => {
          const data = await this.post(`${urls.identity.auth.v2}/user/oidc/postlogin`, body);
          return this.generateLoginResponse(data);
        };
        this.exchangeOAuthTokensV2 = async (body) => {
          const data = await this.post(`${urls.oauth.v1}/token`, body);
          return this.generateLoginResponseFromOAuthResponseV2(data);
        };
        this.silentOAuthRefreshTokenV2 = async () => {
          const tabTenantId = getTabTenantFromSessionStorage(this.appName);
          const data = await this.post(`${urls.oauth.v1}/authorize/silent`, {
            tenantId: tabTenantId
          });
          return this.generateLoginResponseFromOAuthResponseV2(data);
        };
        this.exchangeOAuthTokens = async (body) => {
          const data = await this.post(`${urls.oauth.v1}/token`, body);
          return this.generateLoginResponseFromOAuthResponse(data);
        };
        this.silentOAuthRefreshToken = async () => {
          const tabTenantId = getTabTenantFromSessionStorage(this.appName);
          const data = await this.post(`${urls.oauth.v1}/authorize/silent`, {
            tenantId: tabTenantId
          });
          return this.generateLoginResponseFromOAuthResponse(data);
        };
        this.resetPhoneNumber = async (body) => {
          return this.post(`${urls.identity.users.v1}/phone/reset`, body);
        };
        this.verifyResetPhoneNumber = async (body) => {
          return this.post(`${urls.identity.users.v1}/phone/reset/verify`, body);
        };
        this.changePhoneNumberWithVerification = async (body) => {
          return this.post(`${urls.identity.users.v1}/phone`, body);
        };
        this.verifyChangePhoneNumber = async (body) => {
          return this.post(`${urls.identity.users.v1}/phone/verify`, body);
        };
        this.changePhoneNumber = async (body) => {
          return this.put(`${urls.identity.users.v1}/phone/change`, body);
        };
        this.webAuthnPreLogin = async (body) => {
          return this.post(`${urls.identity.auth.v1}/webauthn/prelogin`, body);
        };
        this.webAuthnPostLogin = async (body) => {
          return this.post(`${urls.identity.auth.v1}/webauthn/postlogin`, body);
        };
        this.webAuthnPostLoginV2 = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/webauthn/postlogin`, body);
          return this.generateLoginResponseV3(data);
        };
        this.webAuthnCreateNewDeviceSession = async () => {
          return this.post(urls.identity.webAuthnDevices.v1);
        };
        this.getWebAuthnDevices = async () => {
          return this.get(urls.identity.webAuthnDevices.v1);
        };
        this.deleteWebAuthnDevice = async (deviceId) => {
          return this.delete(`${urls.identity.webAuthnDevices.v1}/${deviceId}`);
        };
        this.verifyNewDeviceSession = async (body) => {
          return this.post(`${urls.identity.webAuthnDevices.v1}/verify`, body);
        };
        this.getVendorPublicAuthStrategiesConfig = async () => {
          return this.get(`${urls.identity.configurations.v1}/auth/strategies/public`);
        };
        this.getPublicAuthStrategiesConfigForAuthenticatedUser = async () => {
          return this.get(`${urls.identity.configurations.v1}/auth/strategies`);
        };
        this.getMFAStrategiesConfig = async () => {
          return this.get(`${urls.identity.configurations.v1}/mfa/strategies`);
        };
        this.getUserAuthorization = async () => {
          return this.get(`${urls.identity.users.authorization.v1}`);
        };
        this.getMeV2 = async () => {
          return this.get(`${urls.identity.users.v2}/me`);
        };
        this.noThrowLoadEntitlements = async () => {
          try {
            return await this.entitlementsApi.loadEntitlementsV2();
          } catch (e) {
          }
        };
        this.getMeAndEntitlements = async () => {
          const shouldSkipUserLoad = ContextHolder.for(this.appName).shouldSkipUserLoad();
          if (shouldSkipUserLoad) {
            return {
              roles: [],
              permissions: [],
              groups: [],
              tenants: []
            };
          }
          const actions = [{
            action: this.getMeV2,
            shouldLoad: true
          }, {
            action: this.noThrowLoadEntitlements,
            shouldLoad: this.shouldLoadEntitlements()
          }, {
            action: this.getUserAuthorization,
            shouldLoad: this.shouldLoadMeAuthorization()
          }];
          const promises = actions.map((action) => executeConditionalPromise(action));
          const [me, entitlements, authorization] = await Promise.all(promises);
          const tabTenant = getTabTenantFromSessionStorage(this.appName);
          if (tabTenant) {
            me.tenantId = tabTenant;
          }
          return _extends({}, me, authorization != null ? authorization : {}, {
            entitlements
          });
        };
        this.generateStepupSession = async (body) => {
          const data = await this.post(`${urls.identity.auth.v1}/user/step-up/generate`, body);
          if (!data.accessToken) {
            return data;
          }
          return this.generateLoginResponseV3(data);
        };
        this.getGlobalSecurityPolicy = this.securityPolicy.getGlobalSecurityPolicy.bind(this.securityPolicy);
        this.getMfaPolicy = this.securityPolicy.getMfaPolicy.bind(this.securityPolicy);
        this.getVendorMfaPolicy = this.securityPolicy.getVendorMfaPolicy.bind(this.securityPolicy);
        this.saveMfaPolicy = this.securityPolicy.saveMfaPolicy.bind(this.securityPolicy);
        this.getLockoutPolicy = this.securityPolicy.getLockoutPolicy.bind(this.securityPolicy);
        this.getVendorLockoutPolicy = this.securityPolicy.getVendorLockoutPolicy.bind(this.securityPolicy);
        this.saveLockoutPolicy = this.securityPolicy.saveLockoutPolicy.bind(this.securityPolicy);
        this.getCaptchaPolicy = this.securityPolicy.getCaptchaPolicy.bind(this.securityPolicy);
        this.getPasswordHistoryPolicy = this.securityPolicy.getPasswordHistoryPolicy.bind(this.securityPolicy);
        this.getVendorPasswordHistoryPolicy = this.securityPolicy.getVendorPasswordHistoryPolicy.bind(this.securityPolicy);
        this.savePasswordHistoryPolicy = this.securityPolicy.savePasswordHistoryPolicy.bind(this.securityPolicy);
        this.getPasswordConfigPolicy = this.securityPolicy.getPasswordConfigPolicy.bind(this.securityPolicy);
        this.getDomainRestrictions = this.securityPolicy.getDomainRestrictions.bind(this.securityPolicy);
        this.getDomainRestrictionsConfig = this.securityPolicy.getDomainRestrictionsConfig.bind(this.securityPolicy);
        this.createDomainRestriction = this.securityPolicy.createDomainRestriction.bind(this.securityPolicy);
        this.updateDomainRestrictionConfig = this.securityPolicy.updateDomainRestrictionConfig.bind(this.securityPolicy);
        this.deleteDomainRestriction = this.securityPolicy.deleteDomainRestriction.bind(this.securityPolicy);
        this.getIPRestrictions = this.securityPolicy.getIPRestrictions.bind(this.securityPolicy);
        this.getIPRestrictionsConfig = this.securityPolicy.getIPRestrictionsConfig.bind(this.securityPolicy);
        this.createIPRestriction = this.securityPolicy.createIPRestriction.bind(this.securityPolicy);
        this.bulkCreateIPRestriction = this.securityPolicy.bulkCreateIPRestriction.bind(this.securityPolicy);
        this.updateIPRestrictionConfig = this.securityPolicy.updateIPRestrictionConfig.bind(this.securityPolicy);
        this.deleteIPRestriction = this.securityPolicy.deleteIPRestriction.bind(this.securityPolicy);
        this.testCurrentIp = this.securityPolicy.testCurrentIp.bind(this.securityPolicy);
        this.testCurrentIpInAllowList = this.securityPolicy.testCurrentIpInAllowList.bind(this.securityPolicy);
      }
      /**
       * @returns true if entitlements load should be done
       */
      shouldLoadEntitlements() {
        return ContextHolder.for(this.appName).shouldLoadEntitlements();
      }
      /**
       * @returns true if me authorization load should be done
       */
      shouldLoadMeAuthorization() {
        const [shouldLoadAuthorization] = FeatureFlags.getFeatureFlags([LOAD_AUTHORIZATION_FF], this.appName);
        return shouldLoadAuthorization;
      }
    };
    auth_default = new AuthenticationApi("default");
  }
});

// node_modules/@frontegg/rest-api/subscriptions/invoices.js
var InvoicesApi;
var init_invoices = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/invoices.js"() {
    init_constants();
    init_BaseApiClient();
    InvoicesApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getSubscriptionInvoices = async () => {
          return this.get(urls.subscriptions.billing.invoices.v1);
        };
        this.getSubscriptionInvoice = async (invoiceId) => {
          return this.get(`${urls.subscriptions.billing.invoices.v1}/${invoiceId}`);
        };
        this.getSubscriptionInvoicePdf = async (invoiceId, outputFileName) => {
          return this.get(`${urls.subscriptions.billing.invoices.v1}/${invoiceId}/pdf`, {
            outputFileName
          }, {
            responseType: "blob"
          });
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/managedSubscriptions.js
var ManagedSubscriptionApi;
var init_managedSubscriptions = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/managedSubscriptions.js"() {
    init_constants();
    init_BaseApiClient();
    ManagedSubscriptionApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getManagedSubscription = async (subscriptionId) => {
          return this.get(`${urls.subscriptions.managedSubscriptions.v1}/${subscriptionId}`);
        };
        this.getManagedSubscriptions = async () => {
          return this.get(urls.subscriptions.managedSubscriptions.v1);
        };
        this.cancelManagedSubscription = async (subscriptionId) => {
          return this.put(`${urls.subscriptions.managedSubscriptions.v1}/${subscriptionId}/cancellations/`, {});
        };
        this.renewManagedSubscription = async (subscriptionId) => {
          return this.put(`${urls.subscriptions.managedSubscriptions.v1}/${subscriptionId}/renewals/`, {});
        };
        this.updateManagedSubscription = async (subscriptionId, {
          paymentMethodId,
          planId
        }) => {
          return this.put(`${urls.subscriptions.managedSubscriptions.v1}/${subscriptionId}`, {
            paymentMethodId,
            planId
          });
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/paymentMethods.js
var _excluded4, PaymentMethodsApi;
var init_paymentMethods = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/paymentMethods.js"() {
    init_objectWithoutPropertiesLoose();
    init_constants();
    init_BaseApiClient();
    _excluded4 = ["email"];
    PaymentMethodsApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getPaymentMethods = async () => {
          return this.get(urls.subscriptions.billing.paymentMethods.v1);
        };
        this.getPaymentMethod = async (paymentMethodId) => {
          return this.get(`${urls.subscriptions.billing.paymentMethods.v1}/${paymentMethodId}`);
        };
        this.updatePaymentMethodBillingDetails = async (paymentMethodId, _ref) => {
          let {
            email
          } = _ref, address = _objectWithoutPropertiesLoose(_ref, _excluded4);
          return this.patch(`${urls.subscriptions.billing.paymentMethods.v1}/${paymentMethodId}/billing-details`, {
            email,
            address
          });
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/paymentProviders.js
var PaymentProvidersApi;
var init_paymentProviders = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/paymentProviders.js"() {
    init_constants();
    init_BaseApiClient();
    PaymentProvidersApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getPaymentProviders = async () => {
          return this.get(urls.subscriptions.paymentProviders.v1);
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/plans.js
var PlansApi;
var init_plans = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/plans.js"() {
    init_constants();
    init_BaseApiClient();
    PlansApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getSubscriptionPlans = async () => {
          return this.get(urls.subscriptions.billing.plans.v1);
        };
        this.getSubscriptionPlan = async (planId) => {
          return this.get(`${urls.subscriptions.billing.plans.v1}/${planId}`);
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/subscriptions.js
var SubscriptionApi;
var init_subscriptions = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/subscriptions.js"() {
    init_constants();
    init_BaseApiClient();
    SubscriptionApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getSubscriptions = async () => {
          return this.get(urls.subscriptions.billing.subscriptions.v1);
        };
        this.getSubscription = async (subscriptionId) => {
          return this.get(`${urls.subscriptions.billing.subscriptions.v1}/${subscriptionId}`);
        };
        this.cancelSubscription = async (subscriptionId) => {
          return this.put(`${urls.subscriptions.billing.subscriptions.v1}/${subscriptionId}/cancellations/`, {});
        };
        this.renewSubscription = async (subscriptionId) => {
          return this.put(`${urls.subscriptions.billing.subscriptions.v1}/${subscriptionId}/renewals/`, {});
        };
        this.updateSubscription = async (subscriptionId, {
          paymentMethodId,
          planId
        }) => {
          return this.put(`${urls.subscriptions.billing.subscriptions.v1}/${subscriptionId}`, {
            paymentMethodId,
            planId
          });
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/summaries.js
var SummariesApi;
var init_summaries = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/summaries.js"() {
    init_constants();
    init_BaseApiClient();
    SummariesApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getSubscriptionSummaries = async (tenantId) => {
          return this.get(`${urls.subscriptions.billing.summaries.v1}/${tenantId}`);
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/tenantConfiguration.js
var SubscriptionTenantConfigApi;
var init_tenantConfiguration = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/tenantConfiguration.js"() {
    init_constants();
    init_BaseApiClient();
    SubscriptionTenantConfigApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getTenantConfiguration = async (tenantId) => {
          return this.get(`${urls.subscriptions.billing.tenantConfiguration.v1}/${tenantId}`);
        };
        this.createTenantConfiguration = async (request) => {
          return this.post(urls.subscriptions.billing.tenantConfiguration.v1, request);
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/vendorPublicConfigurations.js
var VendorPublicConfigApi;
var init_vendorPublicConfigurations = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/vendorPublicConfigurations.js"() {
    init_constants();
    init_BaseApiClient();
    VendorPublicConfigApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.getVendorPublicConfigurations = async () => {
          return this.get(urls.subscriptions.billing.configurations.vendorPublicConfigurations.v1);
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/providers/stripe/index.js
var StripeProviderApi;
var init_stripe = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/providers/stripe/index.js"() {
    init_constants();
    init_BaseApiClient();
    StripeProviderApi = class extends BaseApiClient {
      constructor(...args) {
        super(...args);
        this.createSubscription = async (request) => {
          return this.post(urls.subscriptions.billing.paymentProviders.stripe.subscriptions.v1, request);
        };
        this.getStripeCustomer = async (tenantId) => {
          return this.get(`${urls.subscriptions.billing.paymentProviders.stripe.customers.v1}/${tenantId}`);
        };
        this.createStripeCustomer = async (request) => {
          return this.post(urls.subscriptions.billing.paymentProviders.stripe.customers.v1, request);
        };
        this.getStripePaymentProviderConfiguration = async () => {
          return this.get(urls.subscriptions.billing.paymentProviders.stripe.publicConfigurations.v1);
        };
        this.createStripePaymentMethodSetupIntentSecret = async (request) => {
          return this.post(urls.subscriptions.billing.paymentProviders.stripe.setupIntents.v1, request);
        };
      }
    };
  }
});

// node_modules/@frontegg/rest-api/subscriptions/providers/stripe/interfaces.js
var init_interfaces4 = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/providers/stripe/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/subscriptions/interfaces.js
var init_interfaces5 = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/interfaces.js"() {
    init_interfaces4();
  }
});

// node_modules/@frontegg/rest-api/subscriptions/enums.js
var ISubscriptionStatus, PaymentMethodType, ISubscriptionCancellationPolicy, ProviderType, TrialEndAction, TenantCreatedAction;
var init_enums2 = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/enums.js"() {
    (function(ISubscriptionStatus2) {
      ISubscriptionStatus2["ACTIVE"] = "active";
      ISubscriptionStatus2["CANCELED"] = "canceled";
      ISubscriptionStatus2["INCOMPLETE"] = "incomplete";
      ISubscriptionStatus2["EXPIRED"] = "expired";
      ISubscriptionStatus2["TRIALING"] = "trialing";
      ISubscriptionStatus2["TRIAL_ENDED"] = "trialEnded";
    })(ISubscriptionStatus || (ISubscriptionStatus = {}));
    (function(PaymentMethodType3) {
      PaymentMethodType3["UNKNWON"] = "unknown";
      PaymentMethodType3["CARD"] = "card";
    })(PaymentMethodType || (PaymentMethodType = {}));
    (function(ISubscriptionCancellationPolicy2) {
      ISubscriptionCancellationPolicy2["AT_PERIOD_END"] = "atPeriodEnd";
    })(ISubscriptionCancellationPolicy || (ISubscriptionCancellationPolicy = {}));
    (function(ProviderType2) {
      ProviderType2["Stripe"] = "Stripe";
    })(ProviderType || (ProviderType = {}));
    (function(TrialEndAction2) {
      TrialEndAction2["CHANGE_TO_DEFAULT"] = "change_to_default";
      TrialEndAction2["RETAIN_TRIAL"] = "retain_trial";
    })(TrialEndAction || (TrialEndAction = {}));
    (function(TenantCreatedAction2) {
      TenantCreatedAction2["CREATE"] = "create_customer";
    })(TenantCreatedAction || (TenantCreatedAction = {}));
  }
});

// node_modules/@frontegg/rest-api/subscriptions/index.js
var SubscriptionsApi, subscriptions_default;
var init_subscriptions2 = __esm({
  "node_modules/@frontegg/rest-api/subscriptions/index.js"() {
    init_BaseApiClient();
    init_invoices();
    init_managedSubscriptions();
    init_paymentMethods();
    init_paymentProviders();
    init_plans();
    init_subscriptions();
    init_summaries();
    init_tenantConfiguration();
    init_vendorPublicConfigurations();
    init_stripe();
    init_interfaces5();
    init_enums2();
    SubscriptionsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.invoicesApi = new InvoicesApi(this.appName);
        this.managedSubscriptionApi = new ManagedSubscriptionApi(this.appName);
        this.paymentMethodsApi = new PaymentMethodsApi(this.appName);
        this.paymentProvidersApi = new PaymentProvidersApi(this.appName);
        this.plansApi = new PlansApi(this.appName);
        this.subscriptionApi = new SubscriptionApi(this.appName);
        this.summariesApi = new SummariesApi(this.appName);
        this.subscriptionTenantConfigApi = new SubscriptionTenantConfigApi(this.appName);
        this.vendorPublicConfigApi = new VendorPublicConfigApi(this.appName);
        this.stripeProviderApi = new StripeProviderApi(this.appName);
        this.getSubscriptionInvoices = this.invoicesApi.getSubscriptionInvoices.bind(this.invoicesApi);
        this.getSubscriptionInvoice = this.invoicesApi.getSubscriptionInvoice.bind(this.invoicesApi);
        this.getSubscriptionInvoicePdf = this.invoicesApi.getSubscriptionInvoicePdf.bind(this.invoicesApi);
        this.getManagedSubscription = this.managedSubscriptionApi.getManagedSubscription.bind(this.managedSubscriptionApi);
        this.getManagedSubscriptions = this.managedSubscriptionApi.getManagedSubscriptions.bind(this.managedSubscriptionApi);
        this.cancelManagedSubscription = this.managedSubscriptionApi.cancelManagedSubscription.bind(this.managedSubscriptionApi);
        this.renewManagedSubscription = this.managedSubscriptionApi.renewManagedSubscription.bind(this.managedSubscriptionApi);
        this.updateManagedSubscription = this.managedSubscriptionApi.updateManagedSubscription.bind(this.managedSubscriptionApi);
        this.getPaymentMethods = this.paymentMethodsApi.getPaymentMethods.bind(this.paymentMethodsApi);
        this.getPaymentMethod = this.paymentMethodsApi.getPaymentMethod.bind(this.paymentMethodsApi);
        this.updatePaymentMethodBillingDetails = this.paymentMethodsApi.updatePaymentMethodBillingDetails.bind(this.paymentMethodsApi);
        this.getPaymentProviders = this.paymentProvidersApi.getPaymentProviders.bind(this.paymentProvidersApi);
        this.getSubscriptionPlans = this.plansApi.getSubscriptionPlans.bind(this.plansApi);
        this.getSubscriptionPlan = this.plansApi.getSubscriptionPlan.bind(this.plansApi);
        this.getSubscriptions = this.subscriptionApi.getSubscriptions.bind(this.subscriptionApi);
        this.getSubscription = this.subscriptionApi.getSubscription.bind(this.subscriptionApi);
        this.cancelSubscription = this.subscriptionApi.cancelSubscription.bind(this.subscriptionApi);
        this.renewSubscription = this.subscriptionApi.renewSubscription.bind(this.subscriptionApi);
        this.updateSubscription = this.subscriptionApi.updateSubscription.bind(this.subscriptionApi);
        this.getSubscriptionSummaries = this.summariesApi.getSubscriptionSummaries.bind(this.summariesApi);
        this.getTenantConfiguration = this.subscriptionTenantConfigApi.getTenantConfiguration.bind(this.subscriptionTenantConfigApi);
        this.createTenantConfiguration = this.subscriptionTenantConfigApi.createTenantConfiguration.bind(this.subscriptionTenantConfigApi);
        this.getVendorPublicConfigurations = this.vendorPublicConfigApi.getVendorPublicConfigurations.bind(this.vendorPublicConfigApi);
        this.createSubscription = this.stripeProviderApi.createSubscription.bind(this.stripeProviderApi);
        this.getStripeCustomer = this.stripeProviderApi.getStripeCustomer.bind(this.stripeProviderApi);
        this.createStripeCustomer = this.stripeProviderApi.createStripeCustomer.bind(this.stripeProviderApi);
        this.getStripePaymentProviderConfiguration = this.stripeProviderApi.getStripePaymentProviderConfiguration.bind(this.stripeProviderApi);
        this.createStripePaymentMethodSetupIntentSecret = this.stripeProviderApi.createStripePaymentMethodSetupIntentSecret.bind(this.stripeProviderApi);
      }
    };
    subscriptions_default = new SubscriptionsApi("default");
  }
});

// node_modules/@frontegg/rest-api/teams/index.js
var TeamsApi, teams_default;
var init_teams = __esm({
  "node_modules/@frontegg/rest-api/teams/index.js"() {
    init_extends();
    init_constants();
    init_BaseApiClient();
    TeamsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getProfile = async (params) => {
          return this.get(`${urls.identity.users.v2}/me`, params != null ? params : {
            addRoles: true
          });
        };
        this.updateProfile = async (body) => {
          return this.put(`${urls.identity.users.v2}/me`, body);
        };
        this.updateProfileImage = async (body) => {
          return this.put(`${urls.team.profile.v1}/me/image/v1`, body, {
            responseType: "plain",
            contentType: void 0
          });
        };
        this.changePassword = async (body) => {
          return this.post(`${urls.identity.users.v1}/passwords/change`, body);
        };
        this.loadUsers = async (params) => {
          var _params$sort, _params$sort$0$id, _params$sort2, _params$sort2$, _params$sort3, _params$sort3$;
          const filters = (params.filter || []).reduce((p, n) => _extends({}, p, {
            [n.id]: n.value
          }), {});
          const sorts = (_params$sort = params.sort) != null && _params$sort.length ? {
            sortBy: (_params$sort$0$id = (_params$sort2 = params.sort) == null ? void 0 : (_params$sort2$ = _params$sort2[0]) == null ? void 0 : _params$sort2$.id) != null ? _params$sort$0$id : "name",
            sortDirection: (_params$sort3 = params.sort) != null && (_params$sort3$ = _params$sort3[0]) != null && _params$sort3$.desc ? "desc" : "asc"
          } : null;
          return this.get(urls.team.members.v1, _extends({
            pageOffset: params.pageOffset,
            pageSize: params.pageSize
          }, filters, sorts));
        };
        this.addUser = async (body) => {
          return this.post(urls.identity.users.v2, _extends({}, body, {
            provider: "local"
          }));
        };
        this.deleteUser = async (body) => {
          return this.delete(`${urls.team.members.v1}/${body.userId}`);
        };
        this.updateUser = async (body) => {
          return this.put(urls.team.members.v1, body);
        };
        this.updateUserExpirationTime = async (body) => {
          const {
            userId,
            expirationInSeconds
          } = body;
          return this.put(`${urls.identity.users.temporary.v1}/${userId}`, {
            expirationInSeconds
          });
        };
        this.setPermanentUser = async (userId) => {
          return this.delete(`${urls.identity.users.temporary.v1}/${userId}`);
        };
        this.getTemporaryUserConfiguration = async () => {
          return this.get(urls.identity.users.temporary.configuration.v1);
        };
        this.createInviteUserLink = async (body) => {
          return this.post(urls.identity.tenants.invites.user.v1, _extends({}, body));
        };
        this.updateInviteUserLink = async (body) => {
          return this.patch(urls.identity.tenants.invites.user.v1, _extends({}, body));
        };
        this.deleteInviteUserLink = async () => {
          return this.delete(urls.identity.tenants.invites.user.v1);
        };
        this.getInviteUserLink = async () => {
          return this.get(urls.identity.tenants.invites.user.v1);
        };
        this.getInviteLinkConfiguration = async () => {
          return this.get(urls.identity.tenants.invites.configuration.v1);
        };
        this.loadAvailableRoles = async () => {
          return this.get(urls.team.roles.v1);
        };
        this.loadAvailablePermissions = async () => {
          return this.get(urls.identity.permissions.v1);
        };
        this.loadStats = async () => {
          return this.get(`${urls.team.stats.v1}/members`);
        };
        this.resendActivationLink = async (body) => {
          return this.post(`${urls.team.members.v1}/${body.userId}/resendActivationEmail`, {});
        };
        this.resendInvitationLink = async (body) => {
          return this.post(urls.identity.users.v2, _extends({}, body, {
            provider: "local"
          }));
        };
        this.resendInvitationLinkToAllTenants = async (body) => {
          return this.post(urls.identity.users.invitation.resendAll.v1, _extends({}, body));
        };
        this.disableUser = async (userId) => {
          return this.post(`${urls.identity.tenants.users.v1}/${userId}/disable`);
        };
        this.enableUser = async (userId) => {
          return this.post(`${urls.identity.tenants.users.v1}/${userId}/enable`);
        };
      }
    };
    teams_default = new TeamsApi("default");
  }
});

// node_modules/@frontegg/rest-api/metadata/index.js
var MetadataApi, metadata_default;
var init_metadata = __esm({
  "node_modules/@frontegg/rest-api/metadata/index.js"() {
    init_BaseApiClient();
    MetadataApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getMetadata = async (body) => {
          var _data$rows, _data$rows2;
          const data = await this.get("/metadata", body);
          if (data != null && (_data$rows = data.rows) != null && _data$rows[0]) return data == null ? void 0 : (_data$rows2 = data.rows) == null ? void 0 : _data$rows2[0];
          throw new Error(`metadata not found: ${body.entityName}`);
        };
        this.getAdminBoxMetadata = async () => {
          return this.get("/metadata/admin-box");
        };
        this.updateAdminBoxMetadata = async (body) => {
          return this.post("/metadata/admin-box", body);
        };
        this.getIpMetadata = async (ip) => {
          const data = await this.get(`/metadata/ip/${ip}`);
          if (data) return data;
          throw new Error(`ip metadata not found`);
        };
        this.getCurrentUserIpMetadata = async () => {
          const data = await this.get(`/metadata/ipme`);
          if (data) return data;
          throw new Error(`ip metadata not found`);
        };
        this.getNotificationsMetadata = async () => {
          return this.getMetadata({
            entityName: "notifications"
          });
        };
        this.getSamlMetadata = async () => {
          return this.getMetadata({
            entityName: "saml"
          });
        };
        this.getAuditsMetadata = async () => {
          return this.getMetadata({
            entityName: "audits"
          });
        };
        this.getIpAdressMetadata = async (ip) => {
          return this.getIpMetadata(ip);
        };
      }
      /**
       * Retrieves metadata based on the given criteria.
       *
       * @param body - Metadata request parameters.
       * @returns Metadata matching the criteria.
       * @throws Will throw an error if metadata is not found.
       */
    };
    metadata_default = new MetadataApi("default");
  }
});

// node_modules/@frontegg/rest-api/reports/index.js
var _excluded5, _excluded23, _excluded32, ReportsApi, reports_default;
var init_reports = __esm({
  "node_modules/@frontegg/rest-api/reports/index.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_constants();
    init_BaseApiClient();
    _excluded5 = ["dataFilters"];
    _excluded23 = ["templateId", "dataFilters"];
    _excluded32 = ["dataFilters"];
    ReportsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getReports = async (body) => {
          return this.get(`${urls.reports.service.v2}/tenant-reports`, body);
        };
        this.getReport = async (body) => {
          return this.get(`${urls.reports.service.v2}/${body.id}/tenant-reports`);
        };
        this.renderReport = async (_ref) => {
          let {
            dataFilters
          } = _ref, body = _objectWithoutPropertiesLoose(_ref, _excluded5);
          const html = await this.get(`${urls.reports.trigger.v1}/preview-report`, _extends({}, body, {
            dataFilters: btoa(JSON.stringify(dataFilters || {})),
            responseType: "html"
          }), {
            responseType: "plain"
          });
          return {
            html
          };
        };
        this.scheduleReport = async (_ref2) => {
          let {
            templateId,
            dataFilters
          } = _ref2, body = _objectWithoutPropertiesLoose(_ref2, _excluded23);
          return this.post(`${urls.reports.service.v2}/${templateId}/tenant-reports`, _extends({}, body, {
            dataFilters: btoa(JSON.stringify(dataFilters || {}))
          }));
        };
        this.downloadReport = async (_ref3) => {
          let {
            dataFilters
          } = _ref3, body = _objectWithoutPropertiesLoose(_ref3, _excluded32);
          const blob = await this.get(`${urls.reports.trigger.v1}/preview-report`, _extends({}, body, {
            dataFilters: btoa(JSON.stringify(dataFilters || {}))
          }), {
            responseType: "blob"
          });
          let contentType = "text/html";
          let contentExt = "html";
          if (body.responseType === "pdf") {
            contentType = "application/pdf";
            contentExt = "pdf";
          } else if (body.responseType === "image") {
            contentType = "image/jpeg";
            contentExt = "jpg";
          }
          const newBlob = new Blob([blob], {
            type: contentType
          });
          const fileURL = URL.createObjectURL(newBlob);
          const tempLink = document.createElement("a");
          tempLink.href = fileURL;
          tempLink.setAttribute("download", `report_${body.name || ""}.${contentExt}`);
          tempLink.click();
          setTimeout(tempLink.remove.bind(tempLink));
        };
        this.sendReport = async (body) => {
          return this.post(`${urls.reports.trigger.v1}/tenant-reports`, body);
        };
      }
      /**
       * Get all active tenant reports from reports service by active vendor.
       * Optional: pass filters and sort options to reports.
       *
       * @returns list of reports objects
       */
    };
    reports_default = new ReportsApi("default");
  }
});

// node_modules/@frontegg/rest-api/connectivity/index.js
var _excluded6, _excluded24, ConnectivityApi, connectivity_default;
var init_connectivity = __esm({
  "node_modules/@frontegg/rest-api/connectivity/index.js"() {
    init_objectWithoutPropertiesLoose();
    init_constants();
    init_BaseApiClient();
    _excluded6 = ["eventKey"];
    _excluded24 = ["eventKey"];
    ConnectivityApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getSlackConfiguration = () => {
          return this.get(`${urls.integrations.configurations.v1}/slack`);
        };
        this.getSlackScope = () => {
          return this.get(`${urls.integrations.configurations.v1}/slack/applications`);
        };
        this.getSlackChannels = () => {
          return this.get(`${urls.integrations.configurations.v1}/slack/channels`);
        };
        this.postSlackConfiguration = (data) => {
          if (data.id) {
            return this.patch(`${urls.integrations.configurations.v1}/slack/subscription/${data.id}`, data);
          }
          return this.post(`${urls.integrations.configurations.v1}/slack/subscriptions`, data);
        };
        this.deleteSlackConfiguration = (data) => {
          return this.delete(`${urls.integrations.configurations.v1}/slack/subscriptions/${data.id}`);
        };
        this.postSlackCode = (code) => {
          return this.post(`${urls.integrations.configurations.v1}/slack/applications/registrations`, {
            code
          });
        };
        this.getEmailConfiguration = () => {
          return this.get(`${urls.integrations.configurations.v1}/emails`);
        };
        this.postEmailConfiguration = (_ref) => {
          let {
            eventKey
          } = _ref, data = _objectWithoutPropertiesLoose(_ref, _excluded6);
          return this.post(`${urls.integrations.configurations.v1}/emails/${eventKey}`, data);
        };
        this.patchEmailConfiguration = ({
          eventKey,
          enabled
        }) => {
          return this.patch(`${urls.integrations.configurations.v1}/emails/${eventKey}`, {
            enabled
          });
        };
        this.deleteEmailSubscriptions = (eventKey, subscriptionId) => {
          return this.delete(`${urls.integrations.configurations.v1}/emails/${eventKey}/subscriptions/${subscriptionId}`);
        };
        this.putEmailSubscriptions = (subscriptionId, eventKey, data) => {
          return this.put(`${urls.integrations.configurations.v1}/emails/${eventKey}/subscriptions/${subscriptionId}`, data);
        };
        this.deleteEmailConfiguration = (eventKey) => {
          return this.delete(`${urls.integrations.configurations.v1}/emails/${eventKey}`);
        };
        this.getSMSConfiguration = () => {
          return this.get(`${urls.integrations.configurations.v2}/sms`);
        };
        this.postSMSConfiguration = (_ref2) => {
          let {
            eventKey
          } = _ref2, data = _objectWithoutPropertiesLoose(_ref2, _excluded24);
          return this.post(`${urls.integrations.configurations.v2}/sms/${eventKey}`, data);
        };
        this.patchSMSConfiguration = ({
          eventKey,
          enabled
        }) => {
          return this.patch(`${urls.integrations.configurations.v2}/sms/${eventKey}`, {
            enabled
          });
        };
        this.deleteSMSSubscriptions = (eventKey, subscriptionId) => {
          return this.delete(`${urls.integrations.configurations.v2}/sms/${eventKey}/subscriptions/${subscriptionId}`);
        };
        this.putSMSSubscriptions = (subscriptionId, eventKey, data) => {
          return this.put(`${urls.integrations.configurations.v2}/sms/${eventKey}/subscriptions/${subscriptionId}`, data);
        };
        this.deleteSMSConfiguration = (eventKey) => {
          return this.delete(`${urls.integrations.configurations.v2}/sms/${eventKey}`);
        };
        this.getWebhooksConfigurations = () => {
          return this.get(urls.webhooks.v1);
        };
        this.postWebhooksConfiguration = (data) => {
          if (data._id) {
            return this.patch(`${urls.webhooks.v1}/${data._id}`, data);
          } else {
            return this.post(`${urls.webhooks.v1}/custom`, data);
          }
        };
        this.deleteWebhooksConfiguration = (id) => {
          return this.delete(`${urls.webhooks.v1}/${id}`);
        };
        this.getWebhookLog = (id, offset = 0, limit = 10) => {
          const query = new URLSearchParams({
            id,
            offset: `${offset}`,
            limit: `${limit}`
          });
          return this.get(`${urls.webhooks.v1}/logs/?${query.toString()}`);
        };
        this.postWebhookTest = (data) => {
          return this.post(`${urls.webhooks.v1}/test`, data);
        };
        this.postWebhookRetry = (id) => {
          return this.post(`${urls.webhooks.v1}/logs/${id}/retries`);
        };
        this.getCategories = () => {
          return this.get(`${urls.events.configurations.v1}/categories`);
        };
        this.getChannelMaps = (channels2) => {
          return this.get(urls.events.configurations.v1, {
            channels: channels2
          });
        };
      }
      /** Get Slack configuration */
    };
    connectivity_default = new ConnectivityApi("default");
  }
});

// node_modules/@frontegg/rest-api/notifications/index.js
var NotificationsApi, notifications_default;
var init_notifications = __esm({
  "node_modules/@frontegg/rest-api/notifications/index.js"() {
    init_constants();
    init_BaseApiClient();
    NotificationsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getNotifications = async (params) => {
          return this.get(urls.notifications.v1, {
            params
          });
        };
        this.updateNotificationStatus = async (params) => {
          return this.put(`${urls.notifications.v1}/status`, {
            params
          });
        };
        this.updateNotificationIsPinned = async (params) => {
          const {
            notificationId,
            pinStatus
          } = params;
          return this.put(`${urls.notifications.v1}/${pinStatus}`, {
            notificationId
          });
        };
        this.markAllAsRead = async () => {
          return this.post(`${urls.notifications.v1}/status/mark-all-read`);
        };
      }
      /**
       * Get notifications
       */
    };
    notifications_default = new NotificationsApi("default");
  }
});

// node_modules/@frontegg/rest-api/audits/index.js
var _excluded7, AuditsApi, audits_default;
var init_audits = __esm({
  "node_modules/@frontegg/rest-api/audits/index.js"() {
    init_objectWithoutPropertiesLoose();
    init_constants();
    init_BaseApiClient();
    _excluded7 = ["endpoint", "headerProps"];
    AuditsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getAudits = async (params) => {
          return this.get(urls.audits.v1, params);
        };
        this.getAuditsStats = async (params) => {
          return this.get(`${urls.audits.v1}/stats`, params);
        };
        this.exportAudits = async (params) => {
          const {
            endpoint,
            headerProps
          } = params, restParams = _objectWithoutPropertiesLoose(params, _excluded7);
          return this.postDownload(`${urls.audits.v1}/export/${endpoint}`, {
            properties: headerProps
          }, restParams);
        };
      }
      /**
       * Fetches audit logs based on the provided parameters.
       *
       * @param params - Parameters to filter and paginate audits.
       * @returns A promise that resolves to the list of audits.
       */
    };
    audits_default = new AuditsApi("default");
  }
});

// node_modules/@frontegg/rest-api/account-settings/index.js
var AccountSettingsApi, account_settings_default;
var init_account_settings = __esm({
  "node_modules/@frontegg/rest-api/account-settings/index.js"() {
    init_constants();
    init_BaseApiClient();
    AccountSettingsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.updateSettings = async (body, options) => {
          return this.put(urls.tenants.accountSettings.v1, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getSettings = async (options) => {
          return this.get(urls.tenants.accountSettings.v1, void 0, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.getPublicSettings = async () => {
          return this.get(`${urls.tenants.accountSettings.v1}/public`);
        };
      }
      /**
       * Update account settings for a tenant.
       * TenantId is calculated in the backend from context of the `authorized user`.
       */
    };
    account_settings_default = new AccountSettingsApi("default");
  }
});

// node_modules/@frontegg/rest-api/roles/index.js
var _excluded8, _excluded25, _excluded33, RolesApi, roles_default;
var init_roles = __esm({
  "node_modules/@frontegg/rest-api/roles/index.js"() {
    init_objectWithoutPropertiesLoose();
    init_constants();
    init_BaseApiClient();
    _excluded8 = ["roleId"];
    _excluded25 = ["roleId"];
    _excluded33 = ["permissionId"];
    RolesApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getRoles = async () => {
          return this.get(urls.identity.roles.v1);
        };
        this.addRole = async (body) => {
          return this.post(urls.identity.roles.v1, body);
        };
        this.deleteRole = async ({
          roleId
        }) => {
          return this.delete(`${urls.identity.roles.v1}/${roleId}`);
        };
        this.updateRole = async (_ref) => {
          let {
            roleId
          } = _ref, body = _objectWithoutPropertiesLoose(_ref, _excluded8);
          return this.patch(`${urls.identity.roles.v1}/${roleId}`, body);
        };
        this.attachPermissionsToRole = async (_ref2) => {
          let {
            roleId
          } = _ref2, body = _objectWithoutPropertiesLoose(_ref2, _excluded25);
          return this.put(`${urls.identity.roles.v1}/${roleId}/permissions`, body);
        };
        this.getPermissions = async () => {
          return this.get(urls.identity.permissions.v1);
        };
        this.attachPermissionToRoles = async (_ref3) => {
          let {
            permissionId
          } = _ref3, body = _objectWithoutPropertiesLoose(_ref3, _excluded33);
          return this.put(`${urls.identity.permissions.v1}/${permissionId}/roles`, body);
        };
        this.getPermissionCategories = async () => {
          return this.get(`${urls.identity.permissions.v1}/categories`);
        };
        this.addRoleV2 = async (body) => {
          return this.post(urls.identity.roles.v2, body);
        };
      }
      /**
       * Gets tenant related roles
       */
    };
    roles_default = new RolesApi("default");
  }
});

// node_modules/@frontegg/rest-api/vendor/index.js
var VendorApi, vendor_default;
var init_vendor = __esm({
  "node_modules/@frontegg/rest-api/vendor/index.js"() {
    init_constants();
    init_BaseApiClient();
    VendorApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getVendorPublicInfo = async () => {
          return this.get(`${urls.vendor}/public`);
        };
      }
      /**
       * Provide vendor public info by providing the vendor context.
       * @returns {Promise<IVendorPublicInfoResponse>}
       */
    };
    vendor_default = new VendorApi("default");
  }
});

// node_modules/@frontegg/rest-api/sub-tenants/index.js
var SubTenantsApi, sub_tenants_default;
var init_sub_tenants = __esm({
  "node_modules/@frontegg/rest-api/sub-tenants/index.js"() {
    init_constants();
    init_BaseApiClient();
    SubTenantsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.loadAllUsers = async (params) => {
          return this.get(urls.identity.subTenants.v1, params);
        };
        this.addUserToTenantAndSubTenants = async (body) => {
          return this.post(urls.identity.subTenants.v1, body);
        };
        this.removeUserFromTenantAndSubTenants = async (body, options) => {
          return this.delete(urls.identity.subTenants.v1, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.addUserRolesForSubTenants = async (userId, body, options) => {
          return this.post(`${urls.identity.subTenants.v1}/${userId}/roles`, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.removeUserRolesFromSubTenants = async (userId, body, options) => {
          return this.delete(`${urls.identity.subTenants.v1}/${userId}/roles`, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.setUserRolesForSubTenants = async (userId, body, options) => {
          return this.patch(`${urls.identity.subTenants.v1}/${userId}/roles`, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.createSubTenant = async (body, options) => {
          return this.post(urls.tenants.subTenants.v1, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.deleteSubTenant = async (tenantId, options) => {
          return this.delete(`${urls.tenants.subTenants.v1}/${tenantId}`, void 0, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.updateSubTenant = async ({
          tenantId
        }, body, options) => {
          return this.patch(`${urls.tenants.subTenants.v1}/${tenantId}`, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.updateSubTenantManagement = async ({
          tenantId
        }, body, options) => {
          return this.put(`${urls.tenants.subTenants.v1}/${tenantId}/management`, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.updateSubAccountAccess = async (userId, body, options) => {
          return this.put(`${urls.identity.subTenants.v1}/${userId}/access`, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
        this.addUsersToSubTenant = async (body, options) => {
          return this.post(`${urls.identity.subTenants.v2}/`, body, {
            headers: this.extractHeadersFromOptions(options)
          });
        };
      }
      /**
       * Loads all users based on given parameters.
       */
      updateSubTenantHierarchySettings({
        tenantId
      }, body, options) {
        return this.put(`${urls.tenants.subTenants.v1}/${tenantId}/hierarchy-settings`, body, {
          headers: this.extractHeadersFromOptions(options)
        });
      }
      /**
       * Updates sub-account access.
       */
    };
    sub_tenants_default = new SubTenantsApi("default");
  }
});

// node_modules/@frontegg/rest-api/directory/index.js
var DirectoryApi, directory_default;
var init_directory = __esm({
  "node_modules/@frontegg/rest-api/directory/index.js"() {
    init_constants();
    init_BaseApiClient();
    DirectoryApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getConfigs = async () => {
          return this.get(`${urls.directory.v1}`);
        };
        this.updateConfiguration = async (id, body) => {
          return this.patch(`${urls.directory.v1}/${id}`, body);
        };
        this.createConfiguration = async (body) => {
          return this.post(`${urls.directory.v1}`, body);
        };
        this.deleteConfiguration = async (id, deleteAll) => {
          return this.delete(`${urls.directory.v1}/${id}`, {
            deleteAll
          });
        };
        this.countConfigurationUsers = async (id) => {
          return this.get(`${urls.directory.temp}/${id}/Users/count`);
        };
      }
      /**
       * Returns all SCIM2 configurations
       *
       * ``authorized user``
       */
    };
    directory_default = new DirectoryApi("default");
  }
});

// node_modules/@frontegg/rest-api/impersonate/index.js
var ImpersonateApi, impersonate_default;
var init_impersonate = __esm({
  "node_modules/@frontegg/rest-api/impersonate/index.js"() {
    init_constants();
    init_BaseApiClient();
    ImpersonateApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.impersonate = async (body) => {
          return this.post(`${urls.identity.impersonate.v1}`, body);
        };
      }
      /**
       * Impersonating user should be called after creating actor token that contains information about impersonation.
       * `impersonate` should contain impersonated user info (userId, tenantId, and vendorId) and the actor token that was created for him to perform impersonation.
       *
       * @throws exception if impersonation failed
       */
    };
    impersonate_default = new ImpersonateApi("default");
  }
});

// node_modules/@frontegg/rest-api/groups/index.js
var _excluded9, GroupsApi, groups_default;
var init_groups = __esm({
  "node_modules/@frontegg/rest-api/groups/index.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_constants();
    init_BaseApiClient();
    _excluded9 = ["groupId"];
    GroupsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getGroupById = async ({
          groupId
        }, query) => {
          return this.get(`${urls.identity.groups.v1}/${groupId}`, _extends({}, query));
        };
        this.getGroups = async (query) => {
          return this.get(`${urls.identity.groups.v1}`, _extends({}, query));
        };
        this.getGroupsByIds = async (body, params) => {
          return this.post(`${urls.identity.groups.getByIds.v1}`, body, {
            params
          });
        };
        this.createGroup = async (body) => {
          return this.post(`${urls.identity.groups.v1}`, body);
        };
        this.updateGroup = async (_ref) => {
          let {
            groupId
          } = _ref, body = _objectWithoutPropertiesLoose(_ref, _excluded9);
          return this.patch(`${urls.identity.groups.v1}/${groupId}`, body);
        };
        this.deleteGroup = async (groupId) => {
          return this.delete(`${urls.identity.groups.v1}/${groupId}`);
        };
        this.addRolesToGroup = async (groupId, body) => {
          return this.post(`${urls.identity.groups.v1}/${groupId}/roles`, body);
        };
        this.deleteRolesFromGroup = async (groupId, body) => {
          return this.delete(`${urls.identity.groups.v1}/${groupId}/roles`, body);
        };
        this.addUsersToGroup = async (groupId, body) => {
          return this.post(`${urls.identity.groups.v1}/${groupId}/users`, body);
        };
        this.deleteUsersFromGroup = async (groupId, body) => {
          return this.delete(`${urls.identity.groups.v1}/${groupId}/users`, body);
        };
        this.getGroupConfiguration = async () => {
          return this.get(`${urls.identity.groups.configurations.v1}`);
        };
        this.updateGroupConfiguration = async (body) => {
          return this.post(`${urls.identity.groups.configurations.v1}`, body);
        };
      }
      /**
       * Get group by given id
       * @param groupId - The ID of the group to retrieve
       * @param query - Optional query parameters
       */
    };
    groups_default = new GroupsApi("default");
  }
});

// node_modules/@frontegg/rest-api/security-center/index.js
var SecurityCenterApi, security_center_default;
var init_security_center = __esm({
  "node_modules/@frontegg/rest-api/security-center/index.js"() {
    init_constants();
    init_BaseApiClient();
    SecurityCenterApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getRecommendations = async () => {
          return this.get(urls.securityCenter.recommendations.v1);
        };
        this.getInsights = async () => {
          return this.get(urls.securityCenter.insights.v1);
        };
      }
      /**
       * Get security center recommendations.
       */
    };
    security_center_default = new SecurityCenterApi("default");
  }
});

// node_modules/@frontegg/rest-api/user-phone-numbers/index.js
var PhoneNumbersApi, user_phone_numbers_default;
var init_user_phone_numbers = __esm({
  "node_modules/@frontegg/rest-api/user-phone-numbers/index.js"() {
    init_constants();
    init_BaseApiClient();
    PhoneNumbersApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getUserPhoneNumbers = async (queryParams) => {
          return this.get(`${urls.identity.phoneNumbers.v1}`, queryParams);
        };
        this.getUserOwnPhoneNumbers = async () => {
          return this.get(`${urls.identity.phoneNumbers.v1}/me`);
        };
        this.createPhoneNumber = async (body) => {
          return this.post(`${urls.identity.phoneNumbers.v1}`, body);
        };
        this.deletePhoneNumber = async (phoneId) => {
          return this.delete(`${urls.identity.phoneNumbers.v1}/${phoneId}`);
        };
        this.preVerifyPhoneNumber = async (body) => {
          return this.post(`${urls.identity.phoneNumbers.v1}/preverify`, body);
        };
        this.verifyPhoneNumber = async (body) => {
          return this.post(`${urls.identity.phoneNumbers.v1}/verify`, body);
        };
        this.verifyDeletePhoneNumber = async (phoneId, body) => {
          return this.post(`${urls.identity.phoneNumbers.v1}/${phoneId}/delete/verify`, body);
        };
      }
      /**
       * Get phone numbers of user
       */
    };
    user_phone_numbers_default = new PhoneNumbersApi("default");
  }
});

// node_modules/@frontegg/rest-api/applications/index.js
var ApplicationsApi, applications_default;
var init_applications = __esm({
  "node_modules/@frontegg/rest-api/applications/index.js"() {
    init_constants();
    init_BaseApiClient();
    ApplicationsApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getUserApplicationsId = async ({
          userId
        }) => {
          return this.get(`${urls.identity.applications.v1}/${userId}/apps`);
        };
        this.getUsersApplicationsId = async ({
          userIds
        }) => {
          return this.get(`${urls.identity.applications.v1}/users-apps`, {
            userIds: userIds.join(",")
          });
        };
        this.getTenantsApplications = async () => {
          return this.get(urls.applications.tenant.v1);
        };
        this.getApplicationsData = async ({
          appIds,
          includeFreeAccess = true
        }) => {
          return this.get(urls.applications.v1, {
            ids: appIds.join(","),
            _includeFreeAccess: includeFreeAccess
          });
        };
        this.assignUserToApplications = async (body) => {
          return this.post(`${urls.identity.applications.v1}/apps-user`, body);
        };
        this.unassignUserFromApplications = async (body) => {
          return this.delete(`${urls.identity.applications.v1}/user-apps`, body);
        };
        this.getUsersOfApplications = async ({
          appIds
        }) => {
          return this.get(`${urls.identity.applications.v1}/apps-users`, {
            appIds: appIds.join(",")
          });
        };
      }
      /**
       * Get applications id array for a single user by user id.
       * @param {IUserApplicationsIdPayload} param0 - user id to find their applications id array.
       * @returns {Promise<string[]>} all app ids as string[].
       */
    };
    applications_default = new ApplicationsApi("default");
  }
});

// node_modules/@frontegg/rest-api/velo/index.js
var VeloDebugHeaders, VeloApi, velo_default;
var init_velo = __esm({
  "node_modules/@frontegg/rest-api/velo/index.js"() {
    init_constants();
    init_BaseApiClient();
    VeloDebugHeaders = {
      "x-frontegg-api-key": "my-frontegg-api-key",
      "frontegg-vendor-id": "04ae2174-d8d9-4a90-8bab-2548e210a508",
      "frontegg-tenant-id": "02e6ab6f-8b25-48e4-b06d-2c53745ce213",
      "frontegg-user-id": "e5c397a1-7120-4753-9216-e5d7f35d1f2d"
    };
    VeloApi = class extends BaseApiClient {
      constructor(appName) {
        super(appName);
        this.getAgentsConfig = async () => {
          return this.get(`${urls.velo.v1}/config`, void 0, {
            headers: VeloDebugHeaders
          });
        };
        this.getConversations = async () => {
          return this.get(`${urls.velo.v1}/conversations`, void 0, {
            headers: VeloDebugHeaders
          });
        };
        this.getConversationById = async (payload) => {
          return this.get(`${urls.velo.v1}/conversation/${payload.id}`, void 0, {
            headers: VeloDebugHeaders
          });
        };
        this.createConversation = async (payload) => {
          return this.post(`${urls.velo.v1}/conversations`, {
            message: payload.message,
            stream: payload.stream
          }, {
            responseType: payload.stream === false ? "json" : "stream",
            headers: VeloDebugHeaders
          });
        };
        this.sendMessage = async (payload) => {
          return this.post(`${urls.velo.v1}/conversation/${payload.conversationId}/messages`, {
            message: payload.message,
            stream: payload.stream
          }, {
            responseType: payload.stream === false ? "json" : "stream",
            headers: VeloDebugHeaders
          });
        };
        this.sendApiResponse = async (payload) => {
          return this.post(`${urls.velo.v1}/conversation/${payload.conversationId}/response/${payload.callId}`, {
            data: payload.data,
            status: payload.status,
            stream: payload.stream
          }, {
            responseType: payload.stream === false ? "json" : "stream",
            headers: VeloDebugHeaders
          });
        };
        this.getConversationResource = async (payload) => {
          return this.get(`${urls.velo.v1}/conversation/${payload.conversationId}/resource/${payload.resourceId}`, void 0, {
            headers: VeloDebugHeaders
          });
        };
      }
      /**
       * Get Velo agents config
       * @returns {Promise<IVeloAgentConfigResponse[]>}
       */
    };
    velo_default = new VeloApi("default");
  }
});

// node_modules/@frontegg/rest-api/teams/interfaces.js
var UserManagedByEnum;
var init_interfaces6 = __esm({
  "node_modules/@frontegg/rest-api/teams/interfaces.js"() {
    (function(UserManagedByEnum2) {
      UserManagedByEnum2["FRONTEGG"] = "frontegg";
      UserManagedByEnum2["SCIM2"] = "scim2";
    })(UserManagedByEnum || (UserManagedByEnum = {}));
  }
});

// node_modules/@frontegg/rest-api/metadata/interfaces.js
var init_interfaces7 = __esm({
  "node_modules/@frontegg/rest-api/metadata/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/reports/interfaces.js
var init_interfaces8 = __esm({
  "node_modules/@frontegg/rest-api/reports/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/connectivity/interfaces.js
var init_interfaces9 = __esm({
  "node_modules/@frontegg/rest-api/connectivity/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/notifications/interfaces.js
var init_interfaces10 = __esm({
  "node_modules/@frontegg/rest-api/notifications/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/audits/interfaces.js
var init_interfaces11 = __esm({
  "node_modules/@frontegg/rest-api/audits/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/tenants/interfaces.js
var TenantSortByEnum, TenantType;
var init_interfaces12 = __esm({
  "node_modules/@frontegg/rest-api/tenants/interfaces.js"() {
    (function(TenantSortByEnum2) {
      TenantSortByEnum2["createdAt"] = "createdAt";
      TenantSortByEnum2["name"] = "name";
      TenantSortByEnum2["tenantId"] = "tenantId";
    })(TenantSortByEnum || (TenantSortByEnum = {}));
    (function(TenantType2) {
      TenantType2["CUSTOMER"] = "customer";
      TenantType2["SPAM"] = "spam";
      TenantType2["TEST"] = "test";
      TenantType2["RESELLER"] = "reseller";
      TenantType2["HEADQUARTER"] = "headquarter";
    })(TenantType || (TenantType = {}));
  }
});

// node_modules/@frontegg/rest-api/account-settings/interfaces.js
var init_interfaces13 = __esm({
  "node_modules/@frontegg/rest-api/account-settings/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/roles/interfaces.js
var PermissionAssignmentTypeEnum;
var init_interfaces14 = __esm({
  "node_modules/@frontegg/rest-api/roles/interfaces.js"() {
    (function(PermissionAssignmentTypeEnum2) {
      PermissionAssignmentTypeEnum2["NEVER"] = "NEVER";
      PermissionAssignmentTypeEnum2["ALWAYS"] = "ALWAYS";
      PermissionAssignmentTypeEnum2["ASSIGNABLE"] = "ASSIGNABLE";
    })(PermissionAssignmentTypeEnum || (PermissionAssignmentTypeEnum = {}));
  }
});

// node_modules/@frontegg/rest-api/vendor/interfaces.js
var init_interfaces15 = __esm({
  "node_modules/@frontegg/rest-api/vendor/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/sub-tenants/interfaces.js
var SubAccountAccessTypeEnum;
var init_interfaces16 = __esm({
  "node_modules/@frontegg/rest-api/sub-tenants/interfaces.js"() {
    (function(SubAccountAccessTypeEnum2) {
      SubAccountAccessTypeEnum2["DEFAULT_OFF"] = "defaultOff";
      SubAccountAccessTypeEnum2["DEFAULT_ON"] = "defaultOn";
      SubAccountAccessTypeEnum2["ALWAYS_ON"] = "alwaysOn";
    })(SubAccountAccessTypeEnum || (SubAccountAccessTypeEnum = {}));
  }
});

// node_modules/@frontegg/rest-api/routers.js
var fronteggAuthApiRoutesRegex, fronteggRefreshTokenUrl, fronteggSilentRefreshTokenUrl, fronteggUsersUrl, fronteggTenantsUrl, fronteggTenantsV3Url, fronteggEntitlementsV2Url;
var init_routers = __esm({
  "node_modules/@frontegg/rest-api/routers.js"() {
    init_constants();
    fronteggAuthApiRoutesRegex = [
      // Logout urls:
      // - `${urls.identity.auth.v1}/logout`,
      // - `${urls.oauth.v1}/logout`,
      /^(.*)\/logout$/g,
      "/logout",
      // Saml urls:
      // - `${urls.identity.auth.v1}/user/saml/postlogin`,
      // - `${urls.identity.auth.v2}/user/oidc/postlogin`,
      /^\/identity\/resources\/auth\/v[0-9]*\/user\/[^\/]*\/postlogin$/g,
      // impersonation url:
      /^\/identity\/resources\/impersonation\/v[0-9]$/g,
      // Passwordless urls:
      // - `${urls.identity.auth.v1}/passwordless/magiclink/postlogin`,
      // - `${urls.identity.auth.v1}/passwordless/code/postlogin`,
      // - `${urls.identity.auth.v1}/passwordless/smscode/postlogin`,
      // - `${urls.identity.auth.v1}/passwordless/${type.toLocaleLowerCase()}/postlogin`,
      /^\/identity\/resources\/auth\/v[0-9]*\/passwordless\/[^\/]*\/postlogin$/g,
      // Webauthn postlogin urls:
      /^\/identity\/resources\/auth\/v[0-9]*\/webauthn\/postlogin$/g,
      // General login urls:
      // - `${urls.identity.auth.v1}/user`,
      // - `${urls.identity.auth.v1}/user/token/refresh`,
      // - `${urls.identity.users.v1}`,
      // - `${urls.identity.users.v1}/signUp`,
      // - `${urls.identity.users.v1}/activate`,
      // - `${urls.identity.users.v1}/invitation/accept`,
      /^\/identity\/resources\/auth\/v[0-9]*\/user$/g,
      /^\/identity\/resources\/auth\/v[0-9]*\/user\/token\/refresh$/g,
      /^\/identity\/resources\/users\/v[0-9]*\/signUp$/g,
      /^\/identity\/resources\/users\/v[0-9]*\/activate$/g,
      /^\/identity\/resources\/users\/v[0-9]*\/invitation\/accept$/g,
      // - `${urls.identity.auth.v1}/user/mfa/verify`,
      // - `${urls.identity.auth.v1}/user/mfa/authenticator/enroll/verify`,
      // - `${urls.identity.auth.v1}/user/mfa/authenticator/${deviceId}/verify`,
      // - `${urls.identity.auth.v1}/user/mfa/sms/enroll/verify`,
      // - `${urls.identity.auth.v1}/user/mfa/sms/${deviceId}/verify`,
      // - `${urls.identity.auth.v1}/user/mfa/webauthn/enroll/verify`,
      // - `${urls.identity.auth.v1}/user/mfa/webauthn/${deviceId}/verify`,
      /^\/identity\/resources\/auth\/v[0-9]*\/user\/mfa\/verify$/g,
      /^\/identity\/resources\/auth\/v[0-9]*\/user\/mfa\/[^\/]*\/[^\/]*\/verify$/g,
      // Oauth urls:
      // - `${urls.oauth.v1}/token`
      // - `${urls.oauth.v1}/authorize/silent`
      /^\/oauth\/token$/g,
      /^\/oauth\/authorize\/silent$/g
    ];
    fronteggRefreshTokenUrl = `${urls.identity.auth.v1}/user/token/refresh`;
    fronteggSilentRefreshTokenUrl = `${urls.oauth.v1}/authorize/silent`;
    fronteggUsersUrl = `${urls.identity.users.v2}/me`;
    fronteggTenantsUrl = `${urls.identity.users.v2}/me/tenants`;
    fronteggTenantsV3Url = `${urls.identity.users.v3}/me/tenants`;
    fronteggEntitlementsV2Url = urls.entitlements.v2;
  }
});

// node_modules/@frontegg/rest-api/feature-flags/interfaces.js
var init_interfaces17 = __esm({
  "node_modules/@frontegg/rest-api/feature-flags/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/directory/interfaces.js
var ScimConnectionSource;
var init_interfaces18 = __esm({
  "node_modules/@frontegg/rest-api/directory/interfaces.js"() {
    (function(ScimConnectionSource2) {
      ScimConnectionSource2["FRONTEGG"] = "frontegg";
      ScimConnectionSource2["OKTA"] = "okta";
      ScimConnectionSource2["AZURE_AD"] = "azure-ad";
      ScimConnectionSource2["OTHER"] = "other";
    })(ScimConnectionSource || (ScimConnectionSource = {}));
  }
});

// node_modules/@frontegg/rest-api/impersonate/interfaces.js
var init_interfaces19 = __esm({
  "node_modules/@frontegg/rest-api/impersonate/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/groups/interfaces.js
var init_interfaces20 = __esm({
  "node_modules/@frontegg/rest-api/groups/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/groups/enums.js
var GroupRelations, GroupManagedByEnum;
var init_enums3 = __esm({
  "node_modules/@frontegg/rest-api/groups/enums.js"() {
    (function(GroupRelations3) {
      GroupRelations3["roles"] = "roles";
      GroupRelations3["users"] = "users";
      GroupRelations3["rolesAndUsers"] = "rolesAndUsers";
    })(GroupRelations || (GroupRelations = {}));
    (function(GroupManagedByEnum2) {
      GroupManagedByEnum2["FRONTEGG"] = "frontegg";
      GroupManagedByEnum2["SCIM2"] = "scim2";
    })(GroupManagedByEnum || (GroupManagedByEnum = {}));
  }
});

// node_modules/@frontegg/rest-api/users/interfaces.js
var SortByEnum, GetUsersFilterPreset, providersArray;
var init_interfaces21 = __esm({
  "node_modules/@frontegg/rest-api/users/interfaces.js"() {
    (function(SortByEnum2) {
      SortByEnum2["createdAt"] = "createdAt";
      SortByEnum2["name"] = "name";
      SortByEnum2["email"] = "email";
      SortByEnum2["id"] = "id";
      SortByEnum2["verified"] = "verified";
      SortByEnum2["isLocked"] = "isLocked";
      SortByEnum2["provider"] = "provider";
      SortByEnum2["tenantId"] = "tenantId";
    })(SortByEnum || (SortByEnum = {}));
    (function(GetUsersFilterPreset2) {
      GetUsersFilterPreset2["MFA_UNENROLLED"] = "mfa-unenrolled";
      GetUsersFilterPreset2["BREACHED_PASSWORDS"] = "breached-passwords";
      GetUsersFilterPreset2["INACTIVE"] = "inactive";
    })(GetUsersFilterPreset || (GetUsersFilterPreset = {}));
    providersArray = ["local", "saml", "google", "github", "facebook", "microsoft", "scim2", "slack"];
  }
});

// node_modules/@frontegg/rest-api/entitlements/interfaces.js
var NotEntitledJustification;
var init_interfaces22 = __esm({
  "node_modules/@frontegg/rest-api/entitlements/interfaces.js"() {
    (function(NotEntitledJustification2) {
      NotEntitledJustification2["MISSING_PERMISSION"] = "MISSING_PERMISSION";
      NotEntitledJustification2["MISSING_FEATURE"] = "MISSING_FEATURE";
      NotEntitledJustification2["BUNDLE_EXPIRED"] = "BUNDLE_EXPIRED";
    })(NotEntitledJustification || (NotEntitledJustification = {}));
  }
});

// node_modules/@frontegg/rest-api/security-center/interfaces.js
var RecommendationCode, InsightCode, RecommendationActionKey, RecommendationSeverity, SecurityCategory;
var init_interfaces23 = __esm({
  "node_modules/@frontegg/rest-api/security-center/interfaces.js"() {
    (function(RecommendationCode2) {
      RecommendationCode2["FORCE_MFA"] = "FORCE_MFA";
      RecommendationCode2["BREACHED_PASSWORDS_EXIST"] = "BREACHED_PASSWORDS_EXIST";
      RecommendationCode2["ENABLE_USER_LOCKOUT"] = "ENABLE_USER_LOCKOUT";
      RecommendationCode2["STRENGTHEN_USER_LOCKOUT"] = "STRENGTHEN_USER_LOCKOUT";
      RecommendationCode2["ENABLE_PASSWORD_HISTORY"] = "ENABLE_PASSWORD_HISTORY";
      RecommendationCode2["STRENGTHEN_PASSWORD_HISTORY"] = "STRENGTHEN_PASSWORD_HISTORY";
      RecommendationCode2["ENABLE_FORCE_RELOGIN"] = "ENABLE_FORCE_RELOGIN";
      RecommendationCode2["SET_FORCE_RELOGIN"] = "SET_FORCE_RELOGIN";
      RecommendationCode2["ENABLE_SESSION_CONCURRENCY"] = "ENABLE_SESSION_CONCURRENCY";
      RecommendationCode2["SET_SESSION_CONCURRENCY"] = "SET_SESSION_CONCURRENCY";
      RecommendationCode2["ENABLE_IDLE_SESSION"] = "ENABLE_IDLE_SESSION";
      RecommendationCode2["SET_IDLE_SESSION"] = "SET_IDLE_SESSION";
      RecommendationCode2["ENABLE_IP_RESTRICTIONS"] = "ENABLE_IP_RESTRICTIONS";
      RecommendationCode2["CHANGE_IP_TO_ALLOWLIST"] = "CHANGE_IP_TO_ALLOWLIST";
      RecommendationCode2["ENABLE_DOMAIN_RESTRICTIONS"] = "ENABLE_DOMAIN_RESTRICTIONS";
      RecommendationCode2["CHANGE_DOMAIN_TO_ALLOWLIST"] = "CHANGE_DOMAIN_TO_ALLOWLIST";
      RecommendationCode2["CONFIGURE_SSO"] = "CONFIGURE_SSO";
    })(RecommendationCode || (RecommendationCode = {}));
    (function(InsightCode2) {
      InsightCode2["MFA_FORCED"] = "MFA_FORCED";
      InsightCode2["PARTIALLY_FORCED_MFA"] = "PARTIALLY_FORCED_MFA";
      InsightCode2["PARTIAL_MFA_USAGE"] = "PARTIAL_MFA_USAGE";
      InsightCode2["FULL_MFA_USAGE"] = "FULL_MFA_USAGE";
      InsightCode2["BREACHED_PASSWORD_USERS_EXIST"] = "BREACHED_PASSWORD_USERS_EXIST";
      InsightCode2["IMPROVE_LOCKOUT_POLICY"] = "IMPROVE_LOCKOUT_POLICY";
      InsightCode2["IMPROVE_PASSWORD_HISTORY_POLICY"] = "IMPROVE_PASSWORD_HISTORY_POLICY";
      InsightCode2["NO_SESSION_SETTINGS"] = "NO_SESSION_SETTINGS";
      InsightCode2["PARTIAL_SESSION_SETTINGS"] = "PARTIAL_SESSION_SETTINGS";
      InsightCode2["FULL_SESSION_SETTINGS"] = "FULL_SESSION_SETTINGS";
      InsightCode2["NO_IP_RESTRICTIONS"] = "NO_IP_RESTRICTIONS";
      InsightCode2["IP_ALLOWLIST"] = "IP_ALLOWLIST";
      InsightCode2["IP_DENYLIST"] = "IP_DENYLIST";
      InsightCode2["NO_DOMAIN_RESTRICTIONS"] = "NO_DOMAIN_RESTRICTIONS";
      InsightCode2["DOMAIN_ALLOWLIST"] = "DOMAIN_ALLOWLIST";
      InsightCode2["DOMAIN_DENYLIST"] = "DOMAIN_DENYLIST";
      InsightCode2["FULL_PASSWORD_SETTINGS"] = "FULL_PASSWORD_SETTINGS";
    })(InsightCode || (InsightCode = {}));
    (function(RecommendationActionKey2) {
      RecommendationActionKey2["SEND_RESET_BREACHED_PASSWORD_EMAIL"] = "SEND_RESET_BREACHED_PASSWORD_EMAIL";
      RecommendationActionKey2["ADJUST_FORCE_RELOGIN"] = "ADJUST_FORCE_RELOGIN";
      RecommendationActionKey2["ADJUST_MAX_CONCURRENT_SESSIONS"] = "ADJUST_MAX_CONCURRENT_SESSIONS";
      RecommendationActionKey2["ADJUST_IDLE_TIMEOUT"] = "ADJUST_IDLE_TIMEOUT";
    })(RecommendationActionKey || (RecommendationActionKey = {}));
    (function(RecommendationSeverity2) {
      RecommendationSeverity2["SEVERE"] = "SEVERE";
      RecommendationSeverity2["WARNING"] = "WARNING";
      RecommendationSeverity2["INFO"] = "INFO";
    })(RecommendationSeverity || (RecommendationSeverity = {}));
    (function(SecurityCategory2) {
      SecurityCategory2["MFA"] = "MFA";
      SecurityCategory2["SESSIONS"] = "SESSIONS";
      SecurityCategory2["PASSWORD"] = "PASSWORD";
      SecurityCategory2["INACTIVITY"] = "INACTIVITY";
      SecurityCategory2["IP"] = "IP";
      SecurityCategory2["DOMAIN"] = "DOMAIN";
      SecurityCategory2["SSO"] = "SSO";
    })(SecurityCategory || (SecurityCategory = {}));
  }
});

// node_modules/@frontegg/rest-api/user-phone-numbers/interfaces.js
var init_interfaces24 = __esm({
  "node_modules/@frontegg/rest-api/user-phone-numbers/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/applications/interfaces.js
var ApplicationAccessType;
var init_interfaces25 = __esm({
  "node_modules/@frontegg/rest-api/applications/interfaces.js"() {
    (function(ApplicationAccessType2) {
      ApplicationAccessType2["FREE_ACCESS"] = "FREE_ACCESS";
      ApplicationAccessType2["MANAGED_ACCESS"] = "MANAGED_ACCESS";
    })(ApplicationAccessType || (ApplicationAccessType = {}));
  }
});

// node_modules/@frontegg/rest-api/velo/interfaces.js
var init_interfaces26 = __esm({
  "node_modules/@frontegg/rest-api/velo/interfaces.js"() {
  }
});

// node_modules/@frontegg/rest-api/index.js
var rest_api_exports = {};
__export(rest_api_exports, {
  ApplicationAccessType: () => ApplicationAccessType,
  AuthStrategyEnum: () => AuthStrategyEnum,
  ContextHolder: () => ContextHolder,
  DirectoryApi: () => DirectoryApi,
  FRONTEGG_SEPARATE_TABS_BY_TENANT: () => FRONTEGG_SEPARATE_TABS_BY_TENANT,
  FeatureFlags: () => FeatureFlags,
  FeatureFlagsApi: () => FeatureFlagsApi,
  FetchClient: () => FetchClient,
  FronteggApiError: () => FronteggApiError,
  FronteggContext: () => FronteggContext,
  FronteggFrameworks: () => FronteggFrameworks,
  GENERIC_ERROR_CODE: () => GENERIC_ERROR_CODE,
  GENERIC_ERROR_MESSAGE: () => GENERIC_ERROR_MESSAGE,
  GetUsersFilterPreset: () => GetUsersFilterPreset,
  GroupManagedByEnum: () => GroupManagedByEnum,
  GroupRelations: () => GroupRelations,
  ISubscriptionCancellationPolicy: () => ISubscriptionCancellationPolicy,
  ISubscriptionStatus: () => ISubscriptionStatus,
  InsightCode: () => InsightCode,
  LOAD_AUTHORIZATION_FF: () => LOAD_AUTHORIZATION_FF,
  MFAStrategyEnum: () => MFAStrategyEnum,
  MachineToMachineAuthStrategy: () => MachineToMachineAuthStrategy,
  NotEntitledJustification: () => NotEntitledJustification,
  PaginationOrderEnum: () => PaginationOrderEnum,
  PaymentMethodType: () => PaymentMethodType,
  PermissionAssignmentTypeEnum: () => PermissionAssignmentTypeEnum,
  ProviderType: () => ProviderType,
  RecommendationActionKey: () => RecommendationActionKey,
  RecommendationCode: () => RecommendationCode,
  RecommendationSeverity: () => RecommendationSeverity,
  RequestSource: () => RequestSource,
  RestrictionType: () => RestrictionType,
  ScimConnectionSource: () => ScimConnectionSource,
  SecondaryAuthStrategy: () => SecondaryAuthStrategy,
  SecurityCategory: () => SecurityCategory,
  SignUpStrategyEnum: () => SignUpStrategyEnum,
  SocialLoginProviders: () => SocialLoginProviders,
  SortByEnum: () => SortByEnum,
  SubAccountAccessTypeEnum: () => SubAccountAccessTypeEnum,
  TenantSortByEnum: () => TenantSortByEnum,
  TenantType: () => TenantType,
  UserManagedByEnum: () => UserManagedByEnum,
  WebAuthnDeviceType: () => WebAuthnDeviceType,
  api: () => api,
  createApiClient: () => createApiClient,
  default: () => rest_api_default,
  fetch: () => FetchClient_default,
  fronteggAuthApiRoutesRegex: () => fronteggAuthApiRoutesRegex,
  fronteggEntitlementsV2Url: () => fronteggEntitlementsV2Url,
  fronteggHeaders: () => fronteggHeaders,
  fronteggRefreshTokenUrl: () => fronteggRefreshTokenUrl,
  fronteggSilentRefreshTokenUrl: () => fronteggSilentRefreshTokenUrl,
  fronteggTenantsUrl: () => fronteggTenantsUrl,
  fronteggTenantsV3Url: () => fronteggTenantsV3Url,
  fronteggUsersUrl: () => fronteggUsersUrl,
  getCurrentUserTenantsFunction: () => getCurrentUserTenantsFunction,
  getTabTenantFromSessionStorage: () => getTabTenantFromSessionStorage,
  providersArray: () => providersArray,
  removeTabTenantFromSessionStorage: () => removeTabTenantFromSessionStorage,
  setTabTenantInSessionStorage: () => setTabTenantInSessionStorage
});
var api, createApiClient, rest_api_default;
var init_rest_api = __esm({
  "node_modules/@frontegg/rest-api/index.js"() {
    init_auth();
    init_subscriptions2();
    init_error();
    init_FetchClient();
    init_ContextHolder();
    init_auth();
    init_secutiry_poilicy();
    init_users();
    init_teams();
    init_metadata();
    init_reports();
    init_connectivity();
    init_notifications();
    init_audits();
    init_tenants();
    init_account_settings();
    init_roles();
    init_subscriptions2();
    init_vendor();
    init_sub_tenants();
    init_feature_flags();
    init_directory();
    init_impersonate();
    init_groups();
    init_entitlements();
    init_security_center();
    init_user_phone_numbers();
    init_applications();
    init_velo();
    init_interfaces();
    init_interfaces3();
    init_enums();
    init_auth();
    init_interfaces6();
    init_interfaces7();
    init_interfaces8();
    init_interfaces9();
    init_interfaces10();
    init_interfaces11();
    init_interfaces12();
    init_interfaces13();
    init_interfaces14();
    init_interfaces5();
    init_interfaces15();
    init_interfaces16();
    init_routers();
    init_feature_flags();
    init_interfaces17();
    init_directory();
    init_interfaces18();
    init_interfaces19();
    init_interfaces20();
    init_enums3();
    init_interfaces21();
    init_interfaces22();
    init_interfaces23();
    init_interfaces24();
    init_interfaces25();
    init_interfaces26();
    init_constants();
    api = {
      auth: auth_default,
      securityPolicy: secutiry_poilicy_default,
      teams: teams_default,
      metadata: metadata_default,
      reports: reports_default,
      connectivity: connectivity_default,
      notifications: notifications_default,
      audits: audits_default,
      tenants: tenants_default,
      accountSettings: account_settings_default,
      roles: roles_default,
      subscriptions: subscriptions_default,
      vendor: vendor_default,
      subTenants: sub_tenants_default,
      featureFlags: feature_flags_default,
      directory: directory_default,
      impersonate: impersonate_default,
      groups: groups_default,
      users: users_default,
      entitlements: entitlements_default,
      securityCenter: security_center_default,
      userPhoneNumbers: user_phone_numbers_default,
      applications: applications_default,
      velo: velo_default
    };
    createApiClient = (appName) => ({
      auth: new AuthenticationApi(appName),
      securityPolicy: new SecurityPolicyApi(appName),
      teams: new TeamsApi(appName),
      metadata: new MetadataApi(appName),
      reports: new ReportsApi(appName),
      connectivity: new ConnectivityApi(appName),
      notifications: new NotificationsApi(appName),
      audits: new AuditsApi(appName),
      tenants: new TenantsApi(appName),
      accountSettings: new AccountSettingsApi(appName),
      roles: new RolesApi(appName),
      subscriptions: new SubscriptionsApi(appName),
      vendor: new VendorApi(appName),
      subTenants: new SubTenantsApi(appName),
      featureFlags: new FeatureFlagsApi(appName),
      directory: new DirectoryApi(appName),
      impersonate: new ImpersonateApi(appName),
      groups: new GroupsApi(appName),
      users: new UsersApi(appName),
      entitlements: new EntitlementsApi(appName),
      securityCenter: new SecurityCenterApi(appName),
      userPhoneNumbers: new PhoneNumbersApi(appName),
      applications: new ApplicationsApi(appName),
      velo: new VeloApi(appName)
    });
    rest_api_default = {
      fetch: FetchClient_default,
      FetchClient,
      ContextHolder,
      FronteggContext,
      api,
      createApiClient,
      FronteggApiError,
      AuthStrategyEnum,
      MachineToMachineAuthStrategy,
      SocialLoginProviders,
      ISubscriptionCancellationPolicy,
      ISubscriptionStatus,
      PaymentMethodType,
      ProviderType
    };
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// node_modules/@frontegg/redux-store/toolkit/proxy.js
var import_deepmerge, createProxy2;
var init_proxy = __esm({
  "node_modules/@frontegg/redux-store/toolkit/proxy.js"() {
    init_extends();
    init_valtio2();
    import_deepmerge = __toESM(require_cjs());
    createProxy2 = (initialState48, overrideState) => {
      const deepMergedState = (0, import_deepmerge.default)(initialState48, _extends({}, overrideState));
      return proxy(_extends({
        __isProxy: true
      }, deepMergedState));
    };
  }
});

// node_modules/@frontegg/redux-store/auth/AcceptInvitationState/interfaces.js
var AcceptInvitationStep;
var init_interfaces27 = __esm({
  "node_modules/@frontegg/redux-store/auth/AcceptInvitationState/interfaces.js"() {
    (function(AcceptInvitationStep2) {
      AcceptInvitationStep2["validate"] = "validate";
      AcceptInvitationStep2["invalid"] = "invalid";
      AcceptInvitationStep2["pending"] = "pending";
      AcceptInvitationStep2["success"] = "success";
      AcceptInvitationStep2["failed"] = "failed";
    })(AcceptInvitationStep || (AcceptInvitationStep = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/AcceptInvitationState/state.js
var initialState, state_default;
var init_state = __esm({
  "node_modules/@frontegg/redux-store/auth/AcceptInvitationState/state.js"() {
    init_proxy();
    init_interfaces27();
    initialState = {
      step: AcceptInvitationStep.validate
    };
    state_default = (overrideState) => createProxy2(initialState, overrideState);
  }
});

// node_modules/isobject/index.js
var require_isobject = __commonJS({
  "node_modules/isobject/index.js"(exports, module) {
    "use strict";
    module.exports = function isObject3(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// node_modules/get-value/index.js
var require_get_value = __commonJS({
  "node_modules/get-value/index.js"(exports, module) {
    var isObject3 = require_isobject();
    module.exports = function(target, path, options) {
      if (!isObject3(options)) {
        options = { default: options };
      }
      if (!isValidObject(target)) {
        return typeof options.default !== "undefined" ? options.default : target;
      }
      if (typeof path === "number") {
        path = String(path);
      }
      const isArray = Array.isArray(path);
      const isString = typeof path === "string";
      const splitChar = options.separator || ".";
      const joinChar = options.joinChar || (typeof splitChar === "string" ? splitChar : ".");
      if (!isString && !isArray) {
        return target;
      }
      if (isString && path in target) {
        return isValid(path, target, options) ? target[path] : options.default;
      }
      let segs = isArray ? path : split(path, splitChar, options);
      let len = segs.length;
      let idx = 0;
      do {
        let prop = segs[idx];
        if (typeof prop === "number") {
          prop = String(prop);
        }
        while (prop && prop.slice(-1) === "\\") {
          prop = join([prop.slice(0, -1), segs[++idx] || ""], joinChar, options);
        }
        if (prop in target) {
          if (!isValid(prop, target, options)) {
            return options.default;
          }
          target = target[prop];
        } else {
          let hasProp = false;
          let n = idx + 1;
          while (n < len) {
            prop = join([prop, segs[n++]], joinChar, options);
            if (hasProp = prop in target) {
              if (!isValid(prop, target, options)) {
                return options.default;
              }
              target = target[prop];
              idx = n - 1;
              break;
            }
          }
          if (!hasProp) {
            return options.default;
          }
        }
      } while (++idx < len && isValidObject(target));
      if (idx === len) {
        return target;
      }
      return options.default;
    };
    function join(segs, joinChar, options) {
      if (typeof options.join === "function") {
        return options.join(segs);
      }
      return segs[0] + joinChar + segs[1];
    }
    function split(path, splitChar, options) {
      if (typeof options.split === "function") {
        return options.split(path);
      }
      return path.split(splitChar);
    }
    function isValid(key, target, options) {
      if (typeof options.isValid === "function") {
        return options.isValid(key, target);
      }
      return true;
    }
    function isValidObject(val) {
      return isObject3(val) || Array.isArray(val) || typeof val === "function";
    }
  }
});

// node_modules/is-primitive/index.js
var require_is_primitive = __commonJS({
  "node_modules/is-primitive/index.js"(exports, module) {
    "use strict";
    module.exports = function isPrimitive(val) {
      if (typeof val === "object") {
        return val === null;
      }
      return typeof val !== "function";
    };
  }
});

// node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "node_modules/is-plain-object/index.js"(exports, module) {
    "use strict";
    var isObject3 = require_isobject();
    function isObjectObject(o) {
      return isObject3(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module.exports = function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false) return false;
      ctor = o.constructor;
      if (typeof ctor !== "function") return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false) return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/set-value/index.js
var require_set_value = __commonJS({
  "node_modules/set-value/index.js"(exports, module) {
    "use strict";
    var { deleteProperty } = Reflect;
    var isPrimitive = require_is_primitive();
    var isPlainObject = require_is_plain_object();
    var isObject3 = (value) => {
      return typeof value === "object" && value !== null || typeof value === "function";
    };
    var isUnsafeKey = (key) => {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    };
    var validateKey = (key) => {
      if (!isPrimitive(key)) {
        throw new TypeError("Object keys must be strings or symbols");
      }
      if (isUnsafeKey(key)) {
        throw new Error(`Cannot set unsafe key: "${key}"`);
      }
    };
    var toStringKey = (input) => {
      return Array.isArray(input) ? input.flat().map(String).join(",") : input;
    };
    var createMemoKey = (input, options) => {
      if (typeof input !== "string" || !options) return input;
      let key = input + ";";
      if (options.arrays !== void 0) key += `arrays=${options.arrays};`;
      if (options.separator !== void 0) key += `separator=${options.separator};`;
      if (options.split !== void 0) key += `split=${options.split};`;
      if (options.merge !== void 0) key += `merge=${options.merge};`;
      if (options.preservePaths !== void 0) key += `preservePaths=${options.preservePaths};`;
      return key;
    };
    var memoize = (input, options, fn) => {
      const key = toStringKey(options ? createMemoKey(input, options) : input);
      validateKey(key);
      const value = setValue3.cache.get(key) || fn();
      setValue3.cache.set(key, value);
      return value;
    };
    var splitString = (input, options = {}) => {
      const sep = options.separator || ".";
      const preserve = sep === "/" ? false : options.preservePaths;
      if (typeof input === "string" && preserve !== false && /\//.test(input)) {
        return [input];
      }
      const parts = [];
      let part = "";
      const push = (part2) => {
        let number;
        if (part2.trim() !== "" && Number.isInteger(number = Number(part2))) {
          parts.push(number);
        } else {
          parts.push(part2);
        }
      };
      for (let i = 0; i < input.length; i++) {
        const value = input[i];
        if (value === "\\") {
          part += input[++i];
          continue;
        }
        if (value === sep) {
          push(part);
          part = "";
          continue;
        }
        part += value;
      }
      if (part) {
        push(part);
      }
      return parts;
    };
    var split = (input, options) => {
      if (options && typeof options.split === "function") return options.split(input);
      if (typeof input === "symbol") return [input];
      if (Array.isArray(input)) return input;
      return memoize(input, options, () => splitString(input, options));
    };
    var assignProp = (obj, prop, value, options) => {
      validateKey(prop);
      if (value === void 0) {
        deleteProperty(obj, prop);
      } else if (options && options.merge) {
        const merge = options.merge === "function" ? options.merge : Object.assign;
        if (merge && isPlainObject(obj[prop]) && isPlainObject(value)) {
          obj[prop] = merge(obj[prop], value);
        } else {
          obj[prop] = value;
        }
      } else {
        obj[prop] = value;
      }
      return obj;
    };
    var setValue3 = (target, path, value, options) => {
      if (!path || !isObject3(target)) return target;
      const keys = split(path, options);
      let obj = target;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const next = keys[i + 1];
        validateKey(key);
        if (next === void 0) {
          assignProp(obj, key, value, options);
          break;
        }
        if (typeof next === "number" && !Array.isArray(obj[key])) {
          obj = obj[key] = [];
          continue;
        }
        if (!isObject3(obj[key])) {
          obj[key] = {};
        }
        obj = obj[key];
      }
      return target;
    };
    setValue3.split = split;
    setValue3.cache = /* @__PURE__ */ new Map();
    setValue3.clear = () => {
      setValue3.cache = /* @__PURE__ */ new Map();
    };
    module.exports = setValue3;
  }
});

// node_modules/@frontegg/redux-store/auth/StepUpState/consts.js
var ACR_VALUE, AMR_MFA_VALUE, AMR_ADDITIONAL_VALUE, SHOULD_STEP_UP_KEY, STEP_UP_MAX_AGE_PARAM_NAME;
var init_consts = __esm({
  "node_modules/@frontegg/redux-store/auth/StepUpState/consts.js"() {
    ACR_VALUE = "http://schemas.openid.net/pape/policies/2007/06/multi-factor";
    AMR_MFA_VALUE = "mfa";
    AMR_ADDITIONAL_VALUE = ["otp", "sms", "hwk"];
    SHOULD_STEP_UP_KEY = "SHOULD_STEP_UP";
    STEP_UP_MAX_AGE_PARAM_NAME = "maxAge";
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/interfaces.js
var LoginStep, LoginFlow, QuickLoginStrategy, LoginActionTypes;
var init_interfaces28 = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/interfaces.js"() {
    init_rest_api();
    (function(LoginStep2) {
      LoginStep2["preLogin"] = "preLogin";
      LoginStep2["magicLinkPreLoginSuccess"] = "magicLinkPreLoginSuccess";
      LoginStep2["loginWithSmsOtc"] = "loginWithSmsOtc";
      LoginStep2["loginWithQuickSmsOtc"] = "loginWithQuickSmsOtc";
      LoginStep2["loginWithOtc"] = "loginWithOtc";
      LoginStep2["loginWithPassword"] = "loginWithPassword";
      LoginStep2["loginWithTwoFactor"] = "loginWithTwoFactor";
      LoginStep2["redirectToSSO"] = "redirectToSSO";
      LoginStep2["loginWithSSOFailed"] = "loginWithSSOFailed";
      LoginStep2["success"] = "success";
      LoginStep2["forceTwoFactor"] = "forceTwoFactor";
      LoginStep2["recoverTwoFactor"] = "recoverTwoFactor";
      LoginStep2["promptPasskeys"] = "promptPasskeys";
      LoginStep2["breachedPassword"] = "breachedPassword";
      LoginStep2["breachedPasswordSuccess"] = "breachedPasswordSuccess";
      LoginStep2["passwordRotationExpired"] = "passwordRotationExpired";
      LoginStep2["passwordRotationNotification"] = "passwordRotationNotification";
      LoginStep2["magicLinkPostLoginSuccess"] = "magicLinkPostLoginSuccess";
    })(LoginStep || (LoginStep = {}));
    (function(LoginFlow2) {
      LoginFlow2["Login"] = "login";
      LoginFlow2["RegisterQuickLogin"] = "registerQuickLogin";
    })(LoginFlow || (LoginFlow = {}));
    (function(QuickLoginStrategy2) {
      QuickLoginStrategy2["Internal"] = "internal";
      QuickLoginStrategy2["UsbKey"] = "usb-key";
      QuickLoginStrategy2["Android"] = "android";
      QuickLoginStrategy2["Sms"] = "sms";
    })(QuickLoginStrategy || (QuickLoginStrategy = {}));
    (function(LoginActionTypes2) {
      LoginActionTypes2["social-login"] = "social-login";
      LoginActionTypes2["custom-social-login"] = "custom-social-login";
      LoginActionTypes2["direct"] = "direct";
    })(LoginActionTypes || (LoginActionTypes = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/consts.js
var authStrategyLoginStepMap, defaultFronteggRoutes;
var init_consts2 = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/consts.js"() {
    init_rest_api();
    init_interfaces28();
    authStrategyLoginStepMap = {
      [AuthStrategyEnum.Code]: LoginStep.loginWithOtc,
      [AuthStrategyEnum.EmailAndPassword]: LoginStep.loginWithPassword,
      [AuthStrategyEnum.MagicLink]: LoginStep.magicLinkPreLoginSuccess,
      [AuthStrategyEnum.SmsCode]: LoginStep.loginWithSmsOtc
    };
    defaultFronteggRoutes = {
      authenticatedUrl: "/",
      loginUrl: "/account/login",
      stepUpUrl: "/account/step-up",
      logoutUrl: "/account/logout",
      activateUrl: "/account/activate",
      impersonationUrl: "/account/impersonate",
      acceptInvitationUrl: "/account/invitation/accept",
      forgetPasswordUrl: "/account/forget-password",
      resetPhoneNumberUrl: "/account/reset-phone-number",
      resetPasswordUrl: "/account/reset-password",
      socialLoginCallbackUrl: "/account/social/success",
      signUpUrl: "/account/sign-up",
      oidcRedirectUrl: "/account/oidc/callback",
      samlCallbackUrl: "/account/saml/callback",
      magicLinkCallbackUrl: "/account/login/magic-link",
      hostedLoginRedirectUrl: "/oauth/callback",
      openAppUrl: "/account/redirect",
      unlockAccountUrl: "/account/unlock",
      activateWithOTCUrl: "/account/activate/code",
      acceptInvitationWithOTCUrl: "/account/invitation/code",
      mfaMobileAuthenticator: "/account/mfa-mobile-authenticator"
    };
  }
});

// node_modules/@frontegg/redux-store/constants.js
var FRONTEGG_AFTER_AUTH_REDIRECT_URL, HOSTED_LOGIN_VERIFIER_KEY, DEFAULT_RETRY_CONFIG;
var init_constants3 = __esm({
  "node_modules/@frontegg/redux-store/constants.js"() {
    init_consts();
    init_consts2();
    FRONTEGG_AFTER_AUTH_REDIRECT_URL = "FRONTEGG_AFTER_AUTH_REDIRECT_URL";
    HOSTED_LOGIN_VERIFIER_KEY = "HOSTED_LOGIN_VERIFIER_KEY";
    DEFAULT_RETRY_CONFIG = {
      retryCount: 3
    };
  }
});

// node_modules/@frontegg/redux-store/helpers/common.js
function omitProps(props, keys) {
  const newProps = _extends({}, props);
  keys.forEach((key) => {
    delete newProps[key];
  });
  return newProps;
}
function shouldBeCloneable(o) {
  const type = typeof o;
  return (o == null ? void 0 : o.constructor) === {}.constructor || type === "undefined" || o === null || type === "boolean" || type === "number" || type === "string" || o instanceof Date || o instanceof RegExp || o instanceof Blob || o instanceof File || o instanceof FileList || o instanceof ArrayBuffer || o instanceof ImageData || o instanceof ImageBitmap || o instanceof Array || o instanceof Map || o instanceof Set;
}
function isProxy(obj) {
  if (obj === null || obj === void 0) {
    return;
  }
  const _shouldBeCloneable = shouldBeCloneable(obj);
  return _shouldBeCloneable && obj.__isProxy !== void 0;
}
var import_get_value, import_set_value, delay, retry, retryIfNeeded2, withRetryConfig, errorTraceId, deepClone, deepResetState;
var init_common = __esm({
  "node_modules/@frontegg/redux-store/helpers/common.js"() {
    init_extends();
    import_get_value = __toESM(require_get_value());
    import_set_value = __toESM(require_set_value());
    init_constants3();
    delay = (ms = 500) => new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
    retry = async (asyncFunc, retryCount, delay2, shouldRetryWhenNull) => {
      let attempts = 0;
      while (attempts < retryCount - 1) {
        try {
          const response = await asyncFunc();
          if (shouldRetryWhenNull && response === null) {
            attempts++;
            if (attempts >= retryCount) {
              return response;
            }
            await new Promise((resolve) => setTimeout(resolve, delay2));
          } else {
            return response;
          }
        } catch (error) {
          attempts++;
          if (attempts >= retryCount) {
            throw error;
          }
          await new Promise((resolve) => setTimeout(resolve, delay2));
        }
      }
      return await asyncFunc();
    };
    retryIfNeeded2 = async (asyncFunc, config) => {
      if (!config) {
        return asyncFunc();
      }
      return retry(asyncFunc, config.retryCount, config.delay || 500, config.shouldRetryWhenNull);
    };
    withRetryConfig = (payload) => _extends({}, payload, {
      retryConfig: DEFAULT_RETRY_CONFIG
    });
    errorTraceId = (e) => (e == null ? void 0 : e.traceId) || void 0;
    deepClone = (objectToClone) => {
      return JSON.parse(JSON.stringify(objectToClone));
    };
    deepResetState = (store, statePath, initialState48) => {
      const initialLoginState = deepClone(initialState48);
      const currentState = (0, import_get_value.default)(store, statePath);
      for (const key in currentState) {
        if (key === "__isProxy") {
          continue;
        }
        if (key in initialLoginState) {
          (0, import_set_value.default)(store, [...statePath, key], initialLoginState[key]);
        } else {
          (0, import_set_value.default)(store, [...statePath, key], void 0);
        }
      }
    };
  }
});

// node_modules/@frontegg/redux-store/helpers/handlers.js
var isFronteggApiError, isError, errorHandler;
var init_handlers = __esm({
  "node_modules/@frontegg/redux-store/helpers/handlers.js"() {
    init_rest_api();
    isFronteggApiError = (error) => Boolean(error == null ? void 0 : error.statusCode);
    isError = (error) => {
      if (error instanceof Error) {
        return true;
      }
      return (error == null ? void 0 : error.message) && (error == null ? void 0 : error.stack) && (error == null ? void 0 : error.name) === "Error";
    };
    errorHandler = (error, fallback) => {
      if (!error) {
        return fallback;
      }
      if (isFronteggApiError(error)) {
        console.error(error.message);
        return error;
      }
      if (isError(error)) {
        console.error(error.message);
      } else if (typeof error === "string") {
        console.error(error);
      }
      return fallback != null ? fallback : new FronteggApiError(GENERIC_ERROR_MESSAGE, 500, null, GENERIC_ERROR_CODE);
    };
  }
});

// node_modules/@frontegg/redux-store/helpers/encoders.js
var chars2, lookup, base64urlEncode, base64urlDecode;
var init_encoders = __esm({
  "node_modules/@frontegg/redux-store/helpers/encoders.js"() {
    chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    lookup = new Uint8Array(256);
    for (let i = 0; i < chars2.length; i++) {
      lookup[chars2.charCodeAt(i)] = i;
    }
    base64urlEncode = (arraybuffer) => {
      const bytes = new Uint8Array(arraybuffer);
      const len = bytes.length;
      let i;
      let base64url = "";
      for (i = 0; i < len; i += 3) {
        base64url += chars2[bytes[i] >> 2];
        base64url += chars2[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64url += chars2[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64url += chars2[bytes[i + 2] & 63];
      }
      if (len % 3 === 2) {
        base64url = base64url.substring(0, base64url.length - 1);
      } else if (len % 3 === 1) {
        base64url = base64url.substring(0, base64url.length - 2);
      }
      return base64url;
    };
    base64urlDecode = (base64string) => {
      const bufferLength = base64string.length * 0.75;
      const len = base64string.length;
      let i, p = 0, encoded1, encoded2, encoded3, encoded4;
      const bytes = new Uint8Array(bufferLength);
      for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64string.charCodeAt(i)];
        encoded2 = lookup[base64string.charCodeAt(i + 1)];
        encoded3 = lookup[base64string.charCodeAt(i + 2)];
        encoded4 = lookup[base64string.charCodeAt(i + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return bytes.buffer;
    };
  }
});

// node_modules/@frontegg/redux-store/helpers/converters.js
function base64ToFormData(base64, key = "file") {
  const b64toBlob = (base642, contentType2) => {
    const sliceSize = 512;
    const byteCharacters = atob(base642);
    const byteArrays = [];
    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
      const slice = byteCharacters.slice(offset, offset + sliceSize);
      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }
      byteArrays.push(new Uint8Array(byteNumbers));
    }
    return new Blob(byteArrays, {
      type: contentType2
    });
  };
  const matchResult = base64.match(/^data:image\/([A-Za-z-+\/]+);base64,(.+)$/);
  if (matchResult == null) {
    return null;
  }
  const contentType = `image/${matchResult[1]}`;
  const data = matchResult[2];
  const blob = b64toBlob(data, contentType);
  const formDataToUpload = new FormData();
  formDataToUpload.append(key, new File([blob], key, {
    type: contentType
  }));
  return formDataToUpload;
}
var publicKeyCredentialToJSON, readFileAsText;
var init_converters = __esm({
  "node_modules/@frontegg/redux-store/helpers/converters.js"() {
    init_encoders();
    publicKeyCredentialToJSON = (pubKeyCred) => {
      if (pubKeyCred instanceof Array) {
        const arr = [];
        for (const i of pubKeyCred) {
          arr.push(publicKeyCredentialToJSON(i));
        }
        return arr;
      } else if (pubKeyCred instanceof ArrayBuffer) {
        return base64urlEncode(pubKeyCred);
      } else if (pubKeyCred instanceof Object) {
        const obj = {};
        for (const key in pubKeyCred) {
          obj[key] = publicKeyCredentialToJSON(pubKeyCred[key]);
        }
        return obj;
      }
      return pubKeyCred;
    };
    readFileAsText = (file) => new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsText(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
    });
  }
});

// node_modules/@frontegg/redux-store/helpers/sha256.js
var ERROR, ARRAY_BUFFER, HEX_CHARS, EXTRA, SHIFT, K, OUTPUT_TYPES, blocks, createOutputMethod, createMethod, createHmacOutputMethod, createHmacMethod, Sha256, HmacSha256, sha256, hmac;
var init_sha256 = __esm({
  "node_modules/@frontegg/redux-store/helpers/sha256.js"() {
    ERROR = "input is invalid type";
    ARRAY_BUFFER = typeof ArrayBuffer !== "undefined";
    HEX_CHARS = "0123456789abcdef".split("");
    EXTRA = [-2147483648, 8388608, 32768, 128];
    SHIFT = [24, 16, 8, 0];
    K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    blocks = [];
    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && !ArrayBuffer.isView) {
      ArrayBuffer.isView = function(arg) {
        return typeof arg === "object" && arg.buffer && arg.buffer.constructor === ArrayBuffer;
      };
    }
    createOutputMethod = function(outputType) {
      return function(message) {
        const instance = new Sha256(true);
        const sha256MessageInstance = instance.update(message);
        return sha256MessageInstance == null ? void 0 : sha256MessageInstance[outputType]();
      };
    };
    createMethod = function() {
      const method = createOutputMethod("hex");
      method.create = function() {
        return new Sha256();
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      for (let i = 0; i < OUTPUT_TYPES.length; ++i) {
        const type = OUTPUT_TYPES[i];
        method[type] = createOutputMethod(type);
      }
      return method;
    };
    createHmacOutputMethod = function(outputType) {
      return function(key, message) {
        const instance = new HmacSha256(key, true);
        const hmacMessageInstance = instance.update(message);
        return hmacMessageInstance == null ? void 0 : hmacMessageInstance[outputType]();
      };
    };
    createHmacMethod = function() {
      const method = createHmacOutputMethod("hex");
      method.create = function(key) {
        return new HmacSha256(key);
      };
      method.update = function(key, message) {
        return method.create(key).update(message);
      };
      for (let i = 0; i < OUTPUT_TYPES.length; ++i) {
        const type = OUTPUT_TYPES[i];
        method[type] = createHmacOutputMethod(type);
      }
      return method;
    };
    Sha256 = class _Sha256 {
      constructor(sharedMemory = false) {
        this.blocks = void 0;
        this.h0 = void 0;
        this.h1 = void 0;
        this.h2 = void 0;
        this.h3 = void 0;
        this.h4 = void 0;
        this.h5 = void 0;
        this.h6 = void 0;
        this.h7 = void 0;
        this.block = void 0;
        this.start = void 0;
        this.bytes = void 0;
        this.hBytes = void 0;
        this.finalized = void 0;
        this.hashed = void 0;
        this.first = void 0;
        this.lastByteIndex = void 0;
        this.sharedMemory = false;
        this.toString = () => this.hex();
        this.array = () => _Sha256.prototype.digest();
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        this.h0 = 1779033703;
        this.h1 = 3144134277;
        this.h2 = 1013904242;
        this.h3 = 2773480762;
        this.h4 = 1359893119;
        this.h5 = 2600822924;
        this.h6 = 528734635;
        this.h7 = 1541459225;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.sharedMemory = sharedMemory;
      }
      update(message) {
        if (this.finalized) {
          return void 0;
        }
        let notString;
        const type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        let code, index = 0, i;
        const length = message.length;
        const blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      }
      finalize() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        const blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      }
      hash() {
        let a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f2 = this.h5, g = this.h6, h = this.h7, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        const blocks2 = this.blocks;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            ab = 704751109;
            t1 = blocks2[0] - 210244248;
            h = t1 - 1521486534 << 0;
            d = t1 + 143694565 << 0;
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b;
            maj = ab ^ a & c ^ bc;
            ch = e & f2 ^ ~e & g;
            t1 = h + s1 + ch + K[j] + blocks2[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
          s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
          da = d & a;
          maj = da ^ d & b ^ ab;
          ch = h & e ^ ~h & f2;
          t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
          cd = c & d;
          maj = cd ^ c & a ^ da;
          ch = g & h ^ ~g & e;
          t1 = f2 + s1 + ch + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj;
          f2 = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
          bc = b & c;
          maj = bc ^ b & d ^ cd;
          ch = f2 & g ^ ~f2 & h;
          t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f2 << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      }
      hex() {
        this.finalize();
        const h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        let hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        return hex;
      }
      digest() {
        this.finalize();
        const h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        const arr = [h0 >> 24 & 255, h0 >> 16 & 255, h0 >> 8 & 255, h0 & 255, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, h1 & 255, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, h3 & 255, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, h4 & 255, h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, h5 & 255, h6 >> 24 & 255, h6 >> 16 & 255, h6 >> 8 & 255, h6 & 255];
        arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        return arr;
      }
      arrayBuffer() {
        this.finalize();
        const buffer = new ArrayBuffer(32);
        const dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        dataView.setUint32(28, this.h7);
        return buffer;
      }
    };
    HmacSha256 = class extends Sha256 {
      constructor(key, sharedMemory = false) {
        super(sharedMemory);
        this.inner = void 0;
        this.oKeyPad = void 0;
        let i;
        const type = typeof key;
        if (type === "string") {
          const bytes = [], length = key.length;
          let index = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          var _Sha256$update;
          key = (_Sha256$update = new Sha256(true).update(key)) == null ? void 0 : _Sha256$update.array();
        }
        const oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          const b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha256.call(this, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      finalize() {
        super.finalize();
        if (this.inner) {
          this.inner = false;
          const innerHash = this.array();
          Sha256.call(this, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      }
    };
    sha256 = createMethod();
    hmac = createHmacMethod();
  }
});

// node_modules/@frontegg/redux-store/helpers/random.js
async function generateCodeChallengePureJs(codeVerifier) {
  const digest = sha256.digest(new TextEncoder().encode(codeVerifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
async function generateCodeChallengeNative(codeVerifier) {
  const digest = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(codeVerifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
async function generateCodeChallenge(codeVerifier) {
  var _window$crypto, _window$crypto$subtle;
  if ((_window$crypto = window.crypto) != null && (_window$crypto$subtle = _window$crypto.subtle) != null && _window$crypto$subtle.digest) {
    return generateCodeChallengeNative(codeVerifier);
  } else {
    console.warn("Generating CodeChallenge in non-secure domain:", window.location.origin);
    return generateCodeChallengePureJs(codeVerifier);
  }
}
function createRandomString(length = 16) {
  let text = "";
  const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
var init_random = __esm({
  "node_modules/@frontegg/redux-store/helpers/random.js"() {
    init_sha256();
  }
});

// node_modules/@frontegg/redux-store/helpers/gtm.js
function reportGTMEvent(action, payload) {
  var _window$onFronteggEve, _window;
  (_window$onFronteggEve = (_window = window).onFronteggEvent) == null ? void 0 : _window$onFronteggEve.call(_window, action, payload);
}
var GTMEventAction;
var init_gtm = __esm({
  "node_modules/@frontegg/redux-store/helpers/gtm.js"() {
    (function(GTMEventAction2) {
      GTMEventAction2["SIGNUP_COMPLETED"] = "signup_completed";
      GTMEventAction2["USER_VERIFIED"] = "user_verified";
    })(GTMEventAction || (GTMEventAction = {}));
  }
});

// node_modules/@frontegg/redux-store/helpers/index.js
var init_helpers = __esm({
  "node_modules/@frontegg/redux-store/helpers/index.js"() {
    init_common();
    init_handlers();
    init_converters();
    init_encoders();
    init_random();
    init_gtm();
    init_sha256();
  }
});

// node_modules/@frontegg/redux-store/auth/AcceptInvitationState/actions.js
var actions_default;
var init_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/AcceptInvitationState/actions.js"() {
    init_interfaces27();
    init_state();
    init_helpers();
    actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setAcceptInvitationState = (state) => {
        Object.assign(store.auth.acceptInvitationState, state);
      };
      const resetAcceptInvitationState = () => {
        deepResetState(store, ["auth", "acceptInvitationState"], initialState);
      };
      const acceptInvitation = async (payload) => {
        if (!payload.token || !payload.userId) {
          setAcceptInvitationState({
            error: void 0,
            step: AcceptInvitationStep.invalid
          });
          return;
        }
        try {
          setAcceptInvitationState({
            error: void 0,
            step: AcceptInvitationStep.pending
          });
          await api2.auth.acceptInvitation(payload);
          setAcceptInvitationState({
            step: AcceptInvitationStep.success
          });
        } catch (e) {
          setAcceptInvitationState({
            step: AcceptInvitationStep.failed,
            error: errorHandler(e)
          });
        }
      };
      const acceptInvitationWithOTC = async (payload) => {
        if (!payload.token || !payload.userId || !payload.code) {
          setAcceptInvitationState({
            error: void 0,
            step: AcceptInvitationStep.invalid
          });
          return;
        }
        try {
          setAcceptInvitationState({
            error: void 0,
            step: AcceptInvitationStep.pending
          });
          await api2.auth.acceptInvitationWithOTC(payload);
          setAcceptInvitationState({
            step: AcceptInvitationStep.success
          });
        } catch (e) {
          setAcceptInvitationState({
            step: AcceptInvitationStep.validate,
            error: errorHandler(e)
          });
        }
      };
      return {
        setAcceptInvitationState,
        resetAcceptInvitationState,
        acceptInvitation,
        acceptInvitationWithOTC
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/AcceptInvitationState/index.js
var init_AcceptInvitationState = __esm({
  "node_modules/@frontegg/redux-store/auth/AcceptInvitationState/index.js"() {
    init_state();
    init_actions();
  }
});

// node_modules/@frontegg/redux-store/auth/AccountSettingsState/state.js
var initialState2, state_default2;
var init_state2 = __esm({
  "node_modules/@frontegg/redux-store/auth/AccountSettingsState/state.js"() {
    init_proxy();
    initialState2 = {
      loading: false
    };
    state_default2 = (overrideState) => createProxy2(initialState2, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/AccountSettingsState/actions.js
var _excluded10, actions_default2;
var init_actions2 = __esm({
  "node_modules/@frontegg/redux-store/auth/AccountSettingsState/actions.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_state2();
    init_helpers();
    _excluded10 = ["activeTenant", "tenants"];
    actions_default2 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setAccountSettingsState = (state) => {
        Object.assign(store.auth.accountSettingsState, state);
      };
      const resetAccountSettingsState = () => {
        deepResetState(store, ["auth", "accountSettingsState"], initialState2);
      };
      const updateTenantState = ({
        newSettingValues
      }) => {
        const _store$auth$tenantsSt = store.auth.tenantsState, {
          activeTenant,
          tenants
        } = _store$auth$tenantsSt, rest = _objectWithoutPropertiesLoose(_store$auth$tenantsSt, _excluded10);
        const updatedTenants = tenants.map((tenant) => tenant.id !== (activeTenant == null ? void 0 : activeTenant.id) ? tenant : _extends({}, tenant, newSettingValues));
        const updatedActiveTenant = _extends({}, activeTenant, newSettingValues);
        sharedActions.setTenantsState(_extends({}, rest, {
          tenants: updatedTenants,
          activeTenant: updatedActiveTenant
        }));
      };
      const saveAccountSettings = async (payload) => {
        try {
          var _payload$callback;
          setAccountSettingsState({
            loading: true
          });
          const {
            address,
            timezone,
            dateFormat,
            timeFormat,
            currency,
            logo
          } = store.auth.accountSettingsState;
          const body = await api2.accountSettings.updateSettings(_extends({
            address,
            timezone,
            dateFormat,
            timeFormat,
            currency,
            logo
          }, payload));
          updateTenantState({
            newSettingValues: body
          });
          setAccountSettingsState(_extends({}, body, {
            loading: false
          }));
          (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, body);
        } catch (e) {
          var _payload$callback2;
          setAccountSettingsState({
            loading: false,
            error: errorHandler(e)
          });
          (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
        }
      };
      const loadAccountSettings = async (payload) => {
        setAccountSettingsState({
          loading: !(payload != null && payload.silentLoading),
          error: null
        });
        try {
          const body = await retryIfNeeded2(() => api2.accountSettings.getSettings(), payload == null ? void 0 : payload.retryConfig);
          setAccountSettingsState(_extends({}, body, {
            loading: false
          }));
        } catch (e) {
          setAccountSettingsState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      return {
        setAccountSettingsState,
        resetAccountSettingsState,
        saveAccountSettings,
        loadAccountSettings
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/AccountSettingsState/index.js
var init_AccountSettingsState = __esm({
  "node_modules/@frontegg/redux-store/auth/AccountSettingsState/index.js"() {
    init_state2();
    init_actions2();
  }
});

// node_modules/@frontegg/redux-store/auth/ActivateAccountState/interfaces.js
var ActivateAccountStep;
var init_interfaces29 = __esm({
  "node_modules/@frontegg/redux-store/auth/ActivateAccountState/interfaces.js"() {
    (function(ActivateAccountStep2) {
      ActivateAccountStep2["activating"] = "activating";
      ActivateAccountStep2["success"] = "success";
      ActivateAccountStep2["resend"] = "resend";
      ActivateAccountStep2["activatingForm"] = "activatingForm";
    })(ActivateAccountStep || (ActivateAccountStep = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/ActivateAccountState/state.js
var initialState3, state_default3;
var init_state3 = __esm({
  "node_modules/@frontegg/redux-store/auth/ActivateAccountState/state.js"() {
    init_interfaces29();
    init_proxy();
    initialState3 = {
      step: ActivateAccountStep.activating,
      loading: false,
      submitting: false,
      resentEmail: false,
      activationStrategy: {
        loading: false
      }
    };
    state_default3 = (overrideState) => createProxy2(initialState3, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/interfaces.js
var REQUEST_NAME, UserVerifiedOriginTypes, AuthenticationTypes, AdminPortalPagesForEvents, AdminPortalPages;
var init_interfaces30 = __esm({
  "node_modules/@frontegg/redux-store/auth/interfaces.js"() {
    (function(REQUEST_NAME2) {
      REQUEST_NAME2["LOAD_FEATURE_FLAGS"] = "LOAD_FEATURE_FLAGS,";
      REQUEST_NAME2["LOAD_ADMIN_BOX_METADATA"] = "LOAD_ADMIN_BOX_METADATA,";
      REQUEST_NAME2["LOAD_SSO_PUBLIC_CONFIGURATION"] = "LOAD_SSO_PUBLIC_CONFIGURATION,";
      REQUEST_NAME2["LOAD_PUBLIC_AUTH_STRATEGIES_POLICY"] = "LOAD_PUBLIC_AUTH_STRATEGIES_POLICY,";
      REQUEST_NAME2["LOAD_ALLOW_SIGNUPS"] = "LOAD_ALLOW_SIGNUPS,";
      REQUEST_NAME2["LOAD_CUSTOM_LOGIN_ROUTES"] = "LOAD_CUSTOM_LOGIN_ROUTES";
      REQUEST_NAME2["LOAD_PASSWORD_CONFIGURATION"] = "LOAD_PASSWORD_CONFIGURATION";
    })(REQUEST_NAME || (REQUEST_NAME = {}));
    (function(UserVerifiedOriginTypes2) {
      UserVerifiedOriginTypes2["SOCIAL_LOGIN"] = "SOCIAL_LOGIN";
      UserVerifiedOriginTypes2["PASSWORDLESS"] = "PASSWORDLESS";
      UserVerifiedOriginTypes2["ACTIVATION_LINK"] = "ACTIVATION_LINK";
    })(UserVerifiedOriginTypes || (UserVerifiedOriginTypes = {}));
    (function(AuthenticationTypes2) {
      AuthenticationTypes2["SOCIAL_LOGIN"] = "SOCIAL_LOGIN";
      AuthenticationTypes2["PASSWORD"] = "PASSWORD";
      AuthenticationTypes2["PHONE_NUMBER"] = "PHONE_NUMBER";
    })(AuthenticationTypes || (AuthenticationTypes = {}));
    (function(AdminPortalPagesForEvents2) {
      AdminPortalPagesForEvents2["profile"] = "profile";
      AdminPortalPagesForEvents2["privacy"] = "privacy";
      AdminPortalPagesForEvents2["personalApiTokens"] = "personalApiTokens";
      AdminPortalPagesForEvents2["account"] = "account";
      AdminPortalPagesForEvents2["users"] = "users";
      AdminPortalPagesForEvents2["groups"] = "groups";
      AdminPortalPagesForEvents2["security"] = "security";
      AdminPortalPagesForEvents2["sso"] = "sso";
      AdminPortalPagesForEvents2["audits"] = "audits";
      AdminPortalPagesForEvents2["webhooks"] = "webhooks";
      AdminPortalPagesForEvents2["apiTokens"] = "apiTokens";
      AdminPortalPagesForEvents2["roles"] = "roles";
      AdminPortalPagesForEvents2["subscriptions"] = "subscription";
      AdminPortalPagesForEvents2["allAccounts"] = "allAccounts";
    })(AdminPortalPagesForEvents || (AdminPortalPagesForEvents = {}));
    AdminPortalPages = {
      profile: AdminPortalPagesForEvents.profile,
      privacy: AdminPortalPagesForEvents.privacy,
      personalApiTokens: AdminPortalPagesForEvents.personalApiTokens,
      account: AdminPortalPagesForEvents.account,
      users: AdminPortalPagesForEvents.users,
      groups: AdminPortalPagesForEvents.groups,
      security: AdminPortalPagesForEvents.security,
      sso: AdminPortalPagesForEvents.sso,
      audits: AdminPortalPagesForEvents.audits,
      webhooks: AdminPortalPagesForEvents.webhooks,
      apiTokens: AdminPortalPagesForEvents.apiTokens,
      roles: AdminPortalPagesForEvents.roles,
      subscriptions: AdminPortalPagesForEvents.subscriptions,
      allAccounts: AdminPortalPagesForEvents.allAccounts
    };
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/rules/types.js
var require_types = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/rules/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleEvaluationResultEnum = exports.TreatmentEnum = exports.ConditionLogicEnum = void 0;
    var ConditionLogicEnum;
    (function(ConditionLogicEnum2) {
      ConditionLogicEnum2["And"] = "and";
    })(ConditionLogicEnum = exports.ConditionLogicEnum || (exports.ConditionLogicEnum = {}));
    var TreatmentEnum;
    (function(TreatmentEnum2) {
      TreatmentEnum2["True"] = "true";
      TreatmentEnum2["False"] = "false";
    })(TreatmentEnum = exports.TreatmentEnum || (exports.TreatmentEnum = {}));
    var RuleEvaluationResultEnum;
    (function(RuleEvaluationResultEnum2) {
      RuleEvaluationResultEnum2["Treatable"] = "treatable";
      RuleEvaluationResultEnum2["Insufficient"] = "insufficient";
    })(RuleEvaluationResultEnum = exports.RuleEvaluationResultEnum || (exports.RuleEvaluationResultEnum = {}));
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/types/operation.enum.js
var require_operation_enum = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/types/operation.enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperationEnum = void 0;
    var OperationEnum;
    (function(OperationEnum2) {
      OperationEnum2["InList"] = "in_list";
      OperationEnum2["StartsWith"] = "starts_with";
      OperationEnum2["EndsWith"] = "ends_with";
      OperationEnum2["Contains"] = "contains";
      OperationEnum2["Matches"] = "matches";
      OperationEnum2["Equal"] = "equal";
      OperationEnum2["GreaterThan"] = "greater_than";
      OperationEnum2["GreaterThanEqual"] = "greater_than_equal";
      OperationEnum2["LesserThan"] = "lower_than";
      OperationEnum2["LesserThanEqual"] = "lower_than_equal";
      OperationEnum2["BetweenNumeric"] = "between_numeric";
      OperationEnum2["Is"] = "is";
      OperationEnum2["On"] = "on";
      OperationEnum2["BetweenDate"] = "between_date";
      OperationEnum2["OnOrAfter"] = "on_or_after";
      OperationEnum2["OnOrBefore"] = "on_or_before";
    })(OperationEnum = exports.OperationEnum || (exports.OperationEnum = {}));
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/types/index.js
var require_types2 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/types/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_operation_enum(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/string/operations.js
var require_operations = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/string/operations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMatchesOperation = exports.useInListOperation = exports.useContainsOperation = exports.useEndsWithOperation = exports.useStartsWithOperation = void 0;
    function useStartsWithOperation(payload) {
      return (attribute) => ({ isValid: payload.list.some((value) => attribute.startsWith(value)) });
    }
    exports.useStartsWithOperation = useStartsWithOperation;
    function useEndsWithOperation(payload) {
      return (attribute) => ({ isValid: payload.list.some((value) => attribute.endsWith(value)) });
    }
    exports.useEndsWithOperation = useEndsWithOperation;
    function useContainsOperation(payload) {
      return (attribute) => ({ isValid: payload.list.some((value) => attribute.includes(value)) });
    }
    exports.useContainsOperation = useContainsOperation;
    function useInListOperation(payload) {
      return (attribute) => ({ isValid: payload.list.includes(attribute) });
    }
    exports.useInListOperation = useInListOperation;
    function useMatchesOperation(payload) {
      return (attribute) => {
        let expression;
        try {
          expression = new RegExp(payload.string);
        } catch (e) {
          return { isValid: false };
        }
        return { isValid: expression.test(attribute) };
      };
    }
    exports.useMatchesOperation = useMatchesOperation;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/string/types.js
var require_types3 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/string/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/string/index.js
var require_string = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/string/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringOperationsMapper = void 0;
    var types_1 = require_types2();
    var operations_1 = require_operations();
    __exportStar(require_operations(), exports);
    __exportStar(require_types3(), exports);
    exports.StringOperationsMapper = {
      [types_1.OperationEnum.StartsWith]: (value) => (0, operations_1.useStartsWithOperation)(value),
      [types_1.OperationEnum.EndsWith]: (value) => (0, operations_1.useEndsWithOperation)(value),
      [types_1.OperationEnum.Contains]: (value) => (0, operations_1.useContainsOperation)(value),
      [types_1.OperationEnum.InList]: (value) => (0, operations_1.useInListOperation)(value),
      [types_1.OperationEnum.Matches]: (value) => (0, operations_1.useMatchesOperation)(value)
    };
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/numeric/operations.js
var require_operations2 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/numeric/operations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useBetweenNumericOperation = exports.useLesserThanEqualOperation = exports.useLesserThanOperation = exports.useGreaterThanEqualOperation = exports.useGreaterThanOperation = exports.useEqualsOperation = void 0;
    function useEqualsOperation(payload) {
      return (attribute) => ({ isValid: attribute === payload.number });
    }
    exports.useEqualsOperation = useEqualsOperation;
    function useGreaterThanOperation(payload) {
      return (attribute) => ({ isValid: attribute > payload.number });
    }
    exports.useGreaterThanOperation = useGreaterThanOperation;
    function useGreaterThanEqualOperation(payload) {
      return (attribute) => ({ isValid: attribute >= payload.number });
    }
    exports.useGreaterThanEqualOperation = useGreaterThanEqualOperation;
    function useLesserThanOperation(payload) {
      return (attribute) => ({ isValid: attribute < payload.number });
    }
    exports.useLesserThanOperation = useLesserThanOperation;
    function useLesserThanEqualOperation(payload) {
      return (attribute) => ({ isValid: attribute <= payload.number });
    }
    exports.useLesserThanEqualOperation = useLesserThanEqualOperation;
    function useBetweenNumericOperation(payload) {
      return (attribute) => ({ isValid: attribute >= payload.start && attribute <= payload.end });
    }
    exports.useBetweenNumericOperation = useBetweenNumericOperation;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/numeric/sanitizers.js
var require_sanitizers = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/numeric/sanitizers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSanitizersMapper = exports.sanitizeNumericRange = exports.sanitizeSingleNumber = void 0;
    var types_1 = require_types2();
    var isNumber = (value) => typeof value === "number";
    var sanitizeSingleNumber = (value) => {
      const sanitizedValue = value.number !== void 0 && isNumber(value.number) ? { number: value.number } : void 0;
      return {
        isSanitized: !!sanitizedValue,
        sanitizedValue
      };
    };
    exports.sanitizeSingleNumber = sanitizeSingleNumber;
    var sanitizeNumericRange = (value) => {
      const sanitizedValue = value.start !== void 0 && value.end !== void 0 && isNumber(value.start) && isNumber(value.end) ? { start: value.start, end: value.end } : void 0;
      return {
        isSanitized: !!sanitizedValue,
        sanitizedValue
      };
    };
    exports.sanitizeNumericRange = sanitizeNumericRange;
    exports.NumericSanitizersMapper = {
      [types_1.OperationEnum.Equal]: exports.sanitizeSingleNumber,
      [types_1.OperationEnum.GreaterThan]: exports.sanitizeSingleNumber,
      [types_1.OperationEnum.GreaterThanEqual]: exports.sanitizeSingleNumber,
      [types_1.OperationEnum.LesserThan]: exports.sanitizeSingleNumber,
      [types_1.OperationEnum.LesserThanEqual]: exports.sanitizeSingleNumber,
      [types_1.OperationEnum.BetweenNumeric]: exports.sanitizeNumericRange
    };
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/numeric/types.js
var require_types4 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/numeric/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/numeric/index.js
var require_numeric = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/numeric/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericOperationsMapper = void 0;
    var types_1 = require_types2();
    var operations_1 = require_operations2();
    exports.NumericOperationsMapper = {
      [types_1.OperationEnum.Equal]: (value) => (0, operations_1.useEqualsOperation)(value),
      [types_1.OperationEnum.GreaterThan]: (value) => (0, operations_1.useGreaterThanOperation)(value),
      [types_1.OperationEnum.GreaterThanEqual]: (value) => (0, operations_1.useGreaterThanEqualOperation)(value),
      [types_1.OperationEnum.LesserThan]: (value) => (0, operations_1.useLesserThanOperation)(value),
      [types_1.OperationEnum.LesserThanEqual]: (value) => (0, operations_1.useLesserThanEqualOperation)(value),
      [types_1.OperationEnum.BetweenNumeric]: (value) => (0, operations_1.useBetweenNumericOperation)(value)
    };
    __exportStar(require_operations2(), exports);
    __exportStar(require_sanitizers(), exports);
    __exportStar(require_types4(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/date/operations.js
var require_operations3 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/date/operations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useDateBetweenOperation = exports.useDateOnOrBeforeOperation = exports.useDateOnOrAfterOperation = exports.useDateOnOperation = void 0;
    function useDateOnOperation(payload) {
      return (attribute) => ({ isValid: attribute.getTime() === payload.date.getTime() });
    }
    exports.useDateOnOperation = useDateOnOperation;
    function useDateOnOrAfterOperation(payload) {
      return (attribute) => ({ isValid: attribute.getTime() >= payload.date.getTime() });
    }
    exports.useDateOnOrAfterOperation = useDateOnOrAfterOperation;
    function useDateOnOrBeforeOperation(payload) {
      return (attribute) => ({ isValid: attribute.getTime() <= payload.date.getTime() });
    }
    exports.useDateOnOrBeforeOperation = useDateOnOrBeforeOperation;
    function useDateBetweenOperation(payload) {
      return (attribute) => ({
        isValid: attribute.getTime() >= payload.start.getTime() && attribute.getTime() <= payload.end.getTime()
      });
    }
    exports.useDateBetweenOperation = useDateBetweenOperation;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/date/types.js
var require_types5 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/date/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/date/index.js
var require_date = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/date/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateOperationsMapper = void 0;
    var types_1 = require_types2();
    var operations_1 = require_operations3();
    __exportStar(require_operations3(), exports);
    __exportStar(require_types5(), exports);
    exports.DateOperationsMapper = {
      [types_1.OperationEnum.On]: (value) => (0, operations_1.useDateOnOperation)(value),
      [types_1.OperationEnum.OnOrAfter]: (value) => (0, operations_1.useDateOnOrAfterOperation)(value),
      [types_1.OperationEnum.OnOrBefore]: (value) => (0, operations_1.useDateOnOrBeforeOperation)(value),
      [types_1.OperationEnum.BetweenDate]: (value) => (0, operations_1.useDateBetweenOperation)(value)
    };
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/boolean/operations.js
var require_operations4 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/boolean/operations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useIsOperation = void 0;
    function useIsOperation(payload) {
      return (attribute) => ({ isValid: attribute === payload.boolean });
    }
    exports.useIsOperation = useIsOperation;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/boolean/sanitizers.js
var require_sanitizers2 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/boolean/sanitizers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanSanitizersMapper = exports.singleBooleanSanitizer = void 0;
    var types_1 = require_types2();
    var isBoolean = (value) => typeof value === "boolean";
    var singleBooleanSanitizer = (value) => {
      const sanitizedValue = value.boolean !== void 0 && isBoolean(value.boolean) ? { boolean: value.boolean } : void 0;
      return {
        isSanitized: !!sanitizedValue,
        sanitizedValue
      };
    };
    exports.singleBooleanSanitizer = singleBooleanSanitizer;
    exports.BooleanSanitizersMapper = {
      [types_1.OperationEnum.Is]: exports.singleBooleanSanitizer
    };
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/boolean/index.js
var require_boolean = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/boolean/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanOperationsMapper = void 0;
    var types_1 = require_types2();
    var operations_1 = require_operations4();
    __exportStar(require_operations4(), exports);
    __exportStar(require_sanitizers2(), exports);
    exports.BooleanOperationsMapper = {
      [types_1.OperationEnum.Is]: (value) => (0, operations_1.useIsOperation)(value)
    };
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/components/operation.resolver.js
var require_operation_resolver = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/components/operation.resolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useOperation = void 0;
    var string_1 = require_string();
    var numeric_1 = require_numeric();
    var date_1 = require_date();
    var boolean_1 = require_boolean();
    var operationEnrichersMapper = {
      ...string_1.StringOperationsMapper,
      ...numeric_1.NumericOperationsMapper,
      ...date_1.DateOperationsMapper,
      ...boolean_1.BooleanOperationsMapper
    };
    function useOperation(operation, value) {
      const operationContextEnricher = operationEnrichersMapper[operation];
      return operationContextEnricher ? operationContextEnricher(value) : void 0;
    }
    exports.useOperation = useOperation;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/string/sanitizers.js
var require_sanitizers3 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/string/sanitizers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringSanitizersMapper = exports.sanitizeListString = exports.sanitizeSingleString = void 0;
    var types_1 = require_types2();
    var isString = (value) => typeof value === "string";
    var sanitizeSingleString = (value) => {
      const sanitizedValue = value.string !== void 0 && isString(value.string) ? { string: value.string } : void 0;
      return {
        isSanitized: !!sanitizedValue,
        sanitizedValue
      };
    };
    exports.sanitizeSingleString = sanitizeSingleString;
    var sanitizeListString = (value) => {
      const sanitizedValue = value.list !== void 0 && value.list.every((str) => isString(str)) ? { list: value.list } : void 0;
      return {
        isSanitized: !!sanitizedValue,
        sanitizedValue
      };
    };
    exports.sanitizeListString = sanitizeListString;
    exports.StringSanitizersMapper = {
      [types_1.OperationEnum.Matches]: exports.sanitizeSingleString,
      [types_1.OperationEnum.Contains]: exports.sanitizeListString,
      [types_1.OperationEnum.StartsWith]: exports.sanitizeListString,
      [types_1.OperationEnum.EndsWith]: exports.sanitizeListString,
      [types_1.OperationEnum.InList]: exports.sanitizeListString
    };
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/date/sanitizers.js
var require_sanitizers4 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/date/sanitizers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateSanitizersMapper = exports.sanitizeDateRange = exports.sanitizeSingleDate = exports.isValidDate = exports.sanitizeDateValue = void 0;
    var types_1 = require_types2();
    var sanitizeDateValue = (value) => {
      return new Date(value);
    };
    exports.sanitizeDateValue = sanitizeDateValue;
    var isValidDate = (value) => value instanceof Date && !isNaN(value);
    exports.isValidDate = isValidDate;
    var sanitizeSingleDate = (value) => {
      const sanitizedDateValue = value.date ? (0, exports.sanitizeDateValue)(value.date) : void 0;
      const sanitizedValue = sanitizedDateValue && (0, exports.isValidDate)(sanitizedDateValue) ? { date: sanitizedDateValue } : void 0;
      return {
        isSanitized: !!sanitizedValue,
        sanitizedValue
      };
    };
    exports.sanitizeSingleDate = sanitizeSingleDate;
    var sanitizeDateRange = (value) => {
      const sanitizedStartValue = value.start ? (0, exports.sanitizeDateValue)(value.start) : void 0;
      const sanitizedEndValue = value.end ? (0, exports.sanitizeDateValue)(value.end) : void 0;
      const sanitizedValue = sanitizedStartValue && sanitizedEndValue && (0, exports.isValidDate)(sanitizedStartValue) && (0, exports.isValidDate)(sanitizedEndValue) ? { start: sanitizedStartValue, end: sanitizedEndValue } : void 0;
      return {
        isSanitized: !!sanitizedValue,
        sanitizedValue
      };
    };
    exports.sanitizeDateRange = sanitizeDateRange;
    exports.DateSanitizersMapper = {
      [types_1.OperationEnum.On]: exports.sanitizeSingleDate,
      [types_1.OperationEnum.OnOrAfter]: exports.sanitizeSingleDate,
      [types_1.OperationEnum.OnOrBefore]: exports.sanitizeSingleDate,
      [types_1.OperationEnum.BetweenDate]: exports.sanitizeDateRange
    };
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/operations/components/sanitizers.resolver.js
var require_sanitizers_resolver = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/operations/components/sanitizers.resolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSanitizer = void 0;
    var boolean_1 = require_boolean();
    var sanitizers_1 = require_sanitizers3();
    var sanitizers_2 = require_sanitizers4();
    var numeric_1 = require_numeric();
    var SanitizersMapper = {
      ...sanitizers_1.StringSanitizersMapper,
      ...numeric_1.NumericSanitizersMapper,
      ...sanitizers_2.DateSanitizersMapper,
      ...boolean_1.BooleanSanitizersMapper
    };
    function useSanitizer(operation) {
      return SanitizersMapper[operation];
    }
    exports.useSanitizer = useSanitizer;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/conditions/condition.evaluator.js
var require_condition_evaluator = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/conditions/condition.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConditionEvaluator = void 0;
    var operation_resolver_1 = require_operation_resolver();
    var sanitizers_resolver_1 = require_sanitizers_resolver();
    function failingConditionEvaluator() {
      return () => false;
    }
    function createConditionEvaluator(payload) {
      const sanitizer = (0, sanitizers_resolver_1.useSanitizer)(payload.condition.op);
      if (!sanitizer) {
        return failingConditionEvaluator();
      }
      const { isSanitized, sanitizedValue } = sanitizer(payload.condition.value);
      if (!isSanitized || sanitizedValue === void 0) {
        return failingConditionEvaluator();
      }
      const operation = (0, operation_resolver_1.useOperation)(payload.condition.op, sanitizedValue);
      return (attributes) => {
        const attributeKey = payload.condition.attribute;
        const value = attributes[attributeKey];
        if (value === void 0 || !operation) {
          return false;
        }
        const { isValid: result } = operation(value);
        return payload.condition.negate ? !result : result;
      };
    }
    exports.createConditionEvaluator = createConditionEvaluator;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/conditions/types.js
var require_types6 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/conditions/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/conditions/index.js
var require_conditions = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/conditions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_condition_evaluator(), exports);
    __exportStar(require_types6(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/rules/rule.evaluator.js
var require_rule_evaluator = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/rules/rule.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRuleEvaluator = void 0;
    var types_1 = require_types();
    var conditions_1 = require_conditions();
    function createRuleEvaluator(payload) {
      return (attributes) => {
        const isRuleTreatable = payload.rule.conditions.every((condition) => {
          const evaluator = (0, conditions_1.createConditionEvaluator)({ condition });
          return evaluator(attributes);
        });
        return isRuleTreatable ? types_1.RuleEvaluationResultEnum.Treatable : types_1.RuleEvaluationResultEnum.Insufficient;
      };
    }
    exports.createRuleEvaluator = createRuleEvaluator;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/rules/index.js
var require_rules = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/rules/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types(), exports);
    __exportStar(require_rule_evaluator(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/feature-flags/feature-flag.evaluator.js
var require_feature_flag_evaluator = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/feature-flags/feature-flag.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evaluateFeatureFlag = void 0;
    var rules_1 = require_rules();
    function evaluateFeatureFlag(featureFlag, attributes) {
      if (!featureFlag.on) {
        return { treatment: featureFlag.offTreatment };
      }
      const treatableRule = findTreatableRule(featureFlag, attributes);
      if (treatableRule) {
        return { treatment: treatableRule.treatment };
      }
      return { treatment: featureFlag.defaultTreatment };
    }
    exports.evaluateFeatureFlag = evaluateFeatureFlag;
    function findTreatableRule(featureFlag, attributes) {
      var _a;
      return (_a = featureFlag.rules) === null || _a === void 0 ? void 0 : _a.find((rule) => {
        const evaluator = (0, rules_1.createRuleEvaluator)({ rule });
        const result = evaluator(attributes);
        return result === rules_1.RuleEvaluationResultEnum.Treatable;
      });
    }
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/feature-flags/index.js
var require_feature_flags = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/feature-flags/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_feature_flag_evaluator(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/plans/plan.evaluator.js
var require_plan_evaluator = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/plans/plan.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evaluatePlan = void 0;
    var rules_1 = require_rules();
    function evaluatePlan(plan, attributes) {
      const treatableRule = findTreatableRule(plan, attributes);
      if (treatableRule) {
        return { treatment: treatableRule.treatment };
      }
      return { treatment: plan.defaultTreatment };
    }
    exports.evaluatePlan = evaluatePlan;
    function findTreatableRule(plan, attributes) {
      var _a;
      return (_a = plan.rules) === null || _a === void 0 ? void 0 : _a.find((rule) => {
        const evaluator = (0, rules_1.createRuleEvaluator)({ rule });
        const result = evaluator(attributes);
        return result === rules_1.RuleEvaluationResultEnum.Treatable;
      });
    }
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/plans/index.js
var require_plans = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/plans/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_plan_evaluator(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/types.js
var require_types7 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NO_EXPIRATION_TIME = exports.NotEntitledJustification = void 0;
    var NotEntitledJustification2;
    (function(NotEntitledJustification3) {
      NotEntitledJustification3["MISSING_FEATURE"] = "MISSING_FEATURE";
      NotEntitledJustification3["MISSING_PERMISSION"] = "MISSING_PERMISSION";
      NotEntitledJustification3["BUNDLE_EXPIRED"] = "BUNDLE_EXPIRED";
    })(NotEntitledJustification2 = exports.NotEntitledJustification || (exports.NotEntitledJustification = {}));
    exports.NO_EXPIRATION_TIME = -1;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/permissions.utils.js
var require_permissions_utils = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/permissions.utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPermissionCheckRegex = exports.checkPermission = void 0;
    function checkPermission(permissions, requiredPermission) {
      return Object.keys(permissions).some((permissionKey) => createPermissionCheckRegex(permissionKey).test(requiredPermission));
    }
    exports.checkPermission = checkPermission;
    function createPermissionCheckRegex(permissionKey) {
      return new RegExp("^" + permissionKey.replace(/\./g, "\\.").replace(/\*/g, ".*") + "$", "gs");
    }
    exports.createPermissionCheckRegex = createPermissionCheckRegex;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/flatten.utils.js
var require_flatten_utils = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/flatten.utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flatten = void 0;
    function flatten(target, opts) {
      opts = opts || {};
      const delimiter = (opts === null || opts === void 0 ? void 0 : opts.delimiter) || ".";
      const maxDepth = opts === null || opts === void 0 ? void 0 : opts.maxDepth;
      const transformKey = (opts === null || opts === void 0 ? void 0 : opts.transformKey) || keyIdentity;
      const output = {};
      function step(object, prev, currentDepth) {
        currentDepth = currentDepth || 1;
        Object.keys(object).forEach(function(key) {
          const value = object[key];
          const isarray = (opts === null || opts === void 0 ? void 0 : opts.safe) && Array.isArray(value);
          const type = Object.prototype.toString.call(value);
          const isbuffer = isBuffer(value);
          const isobject = type === "[object Object]" || type === "[object Array]";
          const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
          if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!(opts === null || opts === void 0 ? void 0 : opts.maxDepth) || maxDepth && currentDepth < maxDepth)) {
            return step(value, newKey, currentDepth + 1);
          }
          output[newKey] = value;
        });
      }
      step(target);
      return output;
    }
    exports.flatten = flatten;
    function isBuffer(obj) {
      return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function keyIdentity(key) {
      return key;
    }
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/attributes.utils.js
var require_attributes_utils = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/attributes.utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modifyObjectKeysWithPrefix = exports.defaultFronteggAttributesMapper = exports.prepareAttributes = void 0;
    var flatten_utils_1 = require_flatten_utils();
    function prepareAttributes(attributes = {}, customFronteggAttributesMapper) {
      const { custom = {}, jwt = {} } = attributes;
      const flatJwtAttributes = (0, flatten_utils_1.flatten)(jwt);
      const fronteggAttributes = customFronteggAttributesMapper ? customFronteggAttributesMapper(jwt) : defaultFronteggAttributesMapper(jwt);
      const fronteggAttributesPrefix = "frontegg.";
      const jwtAttributesPrefix = "jwt.";
      return {
        ...custom,
        ...modifyObjectKeysWithPrefix(fronteggAttributes, fronteggAttributesPrefix),
        ...modifyObjectKeysWithPrefix(flatJwtAttributes, jwtAttributesPrefix)
      };
    }
    exports.prepareAttributes = prepareAttributes;
    function defaultFronteggAttributesMapper(jwt) {
      return {
        email: jwt.email,
        emailVerified: jwt.email_verified,
        tenantId: jwt.tenantId,
        userId: jwt.id
      };
    }
    exports.defaultFronteggAttributesMapper = defaultFronteggAttributesMapper;
    function modifyObjectKeysWithPrefix(object, prefix) {
      return Object.keys(object).reduce((modifiedObject, currentKey) => {
        modifiedObject[`${prefix}${currentKey}`] = object[currentKey];
        return modifiedObject;
      }, {});
    }
    exports.modifyObjectKeysWithPrefix = modifyObjectKeysWithPrefix;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/entitlement-results.utils.js
var require_entitlement_results_utils = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/entitlement-results.utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldContinue = exports.getResult = void 0;
    var types_1 = require_types7();
    function getResult(entitlementResults) {
      let hasExpired = false;
      for (const entitlementResult of entitlementResults) {
        if (entitlementResult.isEntitled) {
          return entitlementResult;
        }
        if (entitlementResult.justification === types_1.NotEntitledJustification.BUNDLE_EXPIRED) {
          hasExpired = true;
        }
      }
      return {
        isEntitled: false,
        justification: hasExpired ? types_1.NotEntitledJustification.BUNDLE_EXPIRED : types_1.NotEntitledJustification.MISSING_FEATURE
      };
    }
    exports.getResult = getResult;
    function shouldContinue(entitlementResults) {
      return entitlementResults.every(({ isEntitled }) => !isEntitled);
    }
    exports.shouldContinue = shouldContinue;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/index.js
var require_utils = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/utils/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_permissions_utils(), exports);
    __exportStar(require_attributes_utils(), exports);
    __exportStar(require_entitlement_results_utils(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/evaluators/direct-entitlement.evaluator.js
var require_direct_entitlement_evaluator = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/evaluators/direct-entitlement.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.directEntitlementEvalutor = void 0;
    var types_1 = require_types7();
    function directEntitlementEvalutor(featureKey, userEntitlementsContext, attributes = {}) {
      const feature = userEntitlementsContext.features[featureKey];
      let hasExpired = false;
      if (feature && feature.expireTime !== null) {
        hasExpired = feature.expireTime !== types_1.NO_EXPIRATION_TIME && feature.expireTime < Date.now();
        if (!hasExpired) {
          return { isEntitled: true };
        }
      }
      return {
        isEntitled: false,
        justification: hasExpired ? types_1.NotEntitledJustification.BUNDLE_EXPIRED : types_1.NotEntitledJustification.MISSING_FEATURE
      };
    }
    exports.directEntitlementEvalutor = directEntitlementEvalutor;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/evaluators/feature-flag.evaluator.js
var require_feature_flag_evaluator2 = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/evaluators/feature-flag.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.featureFlagEvaluator = void 0;
    var types_1 = require_types7();
    var feature_flags_1 = require_feature_flags();
    var attributes_utils_1 = require_attributes_utils();
    var rules_1 = require_rules();
    function featureFlagEvaluator(featureKey, userEntitlementsContext, attributes = {}) {
      const feature = userEntitlementsContext.features[featureKey];
      if (feature && feature.featureFlag) {
        const preparedAttributes = (0, attributes_utils_1.prepareAttributes)(attributes);
        const { treatment } = (0, feature_flags_1.evaluateFeatureFlag)(feature.featureFlag, preparedAttributes);
        if (treatment === rules_1.TreatmentEnum.True) {
          return { isEntitled: true };
        }
      }
      return {
        isEntitled: false,
        justification: types_1.NotEntitledJustification.MISSING_FEATURE
      };
    }
    exports.featureFlagEvaluator = featureFlagEvaluator;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/evaluators/plan-targeting-rules.evaluator.js
var require_plan_targeting_rules_evaluator = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/evaluators/plan-targeting-rules.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.planTargetingRulesEvalutor = void 0;
    var types_1 = require_types7();
    var attributes_utils_1 = require_attributes_utils();
    var rules_1 = require_rules();
    var plans_1 = require_plans();
    function planTargetingRulesEvalutor(featureKey, userEntitlementsContext, attributes = {}) {
      const feature = userEntitlementsContext.features[featureKey];
      if (feature && feature.planIds && feature.planIds.length > 0) {
        const preparedAttributes = (0, attributes_utils_1.prepareAttributes)(attributes);
        const plans = userEntitlementsContext.plans;
        for (const planId of feature.planIds) {
          const plan = plans[planId];
          if (plan) {
            const { treatment } = (0, plans_1.evaluatePlan)(plan, preparedAttributes);
            if (treatment === rules_1.TreatmentEnum.True) {
              return { isEntitled: true };
            }
          }
        }
      }
      return {
        isEntitled: false,
        justification: types_1.NotEntitledJustification.MISSING_FEATURE
      };
    }
    exports.planTargetingRulesEvalutor = planTargetingRulesEvalutor;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/evaluators/index.js
var require_evaluators = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/evaluators/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getIsEntitledEvaluators = void 0;
    var direct_entitlement_evaluator_1 = require_direct_entitlement_evaluator();
    var feature_flag_evaluator_1 = require_feature_flag_evaluator2();
    var plan_targeting_rules_evaluator_1 = require_plan_targeting_rules_evaluator();
    function getIsEntitledEvaluators() {
      return [direct_entitlement_evaluator_1.directEntitlementEvalutor, feature_flag_evaluator_1.featureFlagEvaluator, plan_targeting_rules_evaluator_1.planTargetingRulesEvalutor];
    }
    exports.getIsEntitledEvaluators = getIsEntitledEvaluators;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/is-entitled-to-feature.evaluator.js
var require_is_entitled_to_feature_evaluator = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/is-entitled-to-feature.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evaluateIsEntitledToFeature = void 0;
    var types_1 = require_types7();
    var utils_1 = require_utils();
    var evaluators_1 = require_evaluators();
    function evaluateIsEntitledToFeature2(featureKey, userEntitlementsContext, attributes = {}) {
      if (!userEntitlementsContext) {
        return { isEntitled: false, justification: types_1.NotEntitledJustification.MISSING_FEATURE };
      }
      const entitlementResults = [];
      for (const evaluator of (0, evaluators_1.getIsEntitledEvaluators)()) {
        entitlementResults.push(evaluator(featureKey, userEntitlementsContext, attributes));
        if (!(0, utils_1.shouldContinue)(entitlementResults)) {
          break;
        }
      }
      return (0, utils_1.getResult)(entitlementResults);
    }
    exports.evaluateIsEntitledToFeature = evaluateIsEntitledToFeature2;
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/index.js
var require_is_entitled_to_feature = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-feature/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_is_entitled_to_feature_evaluator(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-permission/is-entitled-to-permission.evaluator.js
var require_is_entitled_to_permission_evaluator = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-permission/is-entitled-to-permission.evaluator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evaluateIsEntitledToPermissions = void 0;
    var is_entitled_to_feature_evaluator_1 = require_is_entitled_to_feature_evaluator();
    var types_1 = require_types7();
    var utils_1 = require_utils();
    var permissions_utils_1 = require_permissions_utils();
    function evaluateIsEntitledToPermissions2(permissionKey, userEntitlementsContext, attributes) {
      if (!userEntitlementsContext) {
        return { isEntitled: false, justification: types_1.NotEntitledJustification.MISSING_PERMISSION };
      }
      const hasPermission = (0, permissions_utils_1.checkPermission)(userEntitlementsContext.permissions, permissionKey);
      if (!hasPermission) {
        return { isEntitled: false, justification: types_1.NotEntitledJustification.MISSING_PERMISSION };
      }
      const linkedFeatures = getLinkedFeatures(permissionKey, userEntitlementsContext);
      if (!linkedFeatures.length) {
        return { isEntitled: true };
      }
      const entitlementResults = [];
      for (const featureKey of linkedFeatures) {
        entitlementResults.push((0, is_entitled_to_feature_evaluator_1.evaluateIsEntitledToFeature)(featureKey, userEntitlementsContext, attributes));
        if (!(0, utils_1.shouldContinue)(entitlementResults)) {
          break;
        }
      }
      return (0, utils_1.getResult)(entitlementResults);
    }
    exports.evaluateIsEntitledToPermissions = evaluateIsEntitledToPermissions2;
    function getLinkedFeatures(permissionKey, userEntitlementsContext) {
      return Object.keys(userEntitlementsContext.features).filter((featureKey) => userEntitlementsContext.features[featureKey].linkedPermissions.includes(permissionKey));
    }
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-permission/index.js
var require_is_entitled_to_permission = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/is-entitled-to-permission/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_is_entitled_to_permission_evaluator(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/index.js
var require_user_entitlements = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/user-entitlements/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_is_entitled_to_feature(), exports);
    __exportStar(require_is_entitled_to_permission(), exports);
    __exportStar(require_types7(), exports);
    __exportStar(require_utils(), exports);
  }
});

// node_modules/@frontegg/entitlements-javascript-commons/dist/index.js
var require_dist = __commonJS({
  "node_modules/@frontegg/entitlements-javascript-commons/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotEntitledJustification = exports.createPermissionCheckRegex = exports.checkPermission = exports.prepareAttributes = exports.evaluateIsEntitledToPermissions = exports.evaluateIsEntitledToFeature = exports.OperationEnum = exports.TreatmentEnum = exports.evaluatePlan = exports.evaluateFeatureFlag = void 0;
    var feature_flags_1 = require_feature_flags();
    Object.defineProperty(exports, "evaluateFeatureFlag", { enumerable: true, get: function() {
      return feature_flags_1.evaluateFeatureFlag;
    } });
    var plans_1 = require_plans();
    Object.defineProperty(exports, "evaluatePlan", { enumerable: true, get: function() {
      return plans_1.evaluatePlan;
    } });
    var rules_1 = require_rules();
    Object.defineProperty(exports, "TreatmentEnum", { enumerable: true, get: function() {
      return rules_1.TreatmentEnum;
    } });
    var types_1 = require_types2();
    Object.defineProperty(exports, "OperationEnum", { enumerable: true, get: function() {
      return types_1.OperationEnum;
    } });
    var user_entitlements_1 = require_user_entitlements();
    Object.defineProperty(exports, "evaluateIsEntitledToFeature", { enumerable: true, get: function() {
      return user_entitlements_1.evaluateIsEntitledToFeature;
    } });
    Object.defineProperty(exports, "evaluateIsEntitledToPermissions", { enumerable: true, get: function() {
      return user_entitlements_1.evaluateIsEntitledToPermissions;
    } });
    Object.defineProperty(exports, "prepareAttributes", { enumerable: true, get: function() {
      return user_entitlements_1.prepareAttributes;
    } });
    Object.defineProperty(exports, "checkPermission", { enumerable: true, get: function() {
      return user_entitlements_1.checkPermission;
    } });
    Object.defineProperty(exports, "createPermissionCheckRegex", { enumerable: true, get: function() {
      return user_entitlements_1.createPermissionCheckRegex;
    } });
    Object.defineProperty(exports, "NotEntitledJustification", { enumerable: true, get: function() {
      return user_entitlements_1.NotEntitledJustification;
    } });
  }
});

// node_modules/@frontegg/redux-store/auth/Entitlements/helpers.js
function isEntitlementsDeeplyEqual(oldEntitlements, newEntitlements) {
  return (0, import_fast_deep_equal.default)(oldEntitlements, newEntitlements);
}
var import_fast_deep_equal, import_entitlements_javascript_commons, ENTITLEMENTS_NOT_ENABLED_EXCEPTION_TEXT, guardEntitlementsUsage, getPermissionEntitlements, getFeatureEntitlements, getEntitlements;
var init_helpers2 = __esm({
  "node_modules/@frontegg/redux-store/auth/Entitlements/helpers.js"() {
    init_rest_api();
    import_fast_deep_equal = __toESM(require_fast_deep_equal());
    import_entitlements_javascript_commons = __toESM(require_dist());
    ENTITLEMENTS_NOT_ENABLED_EXCEPTION_TEXT = "You must first enable entitlements via Frontegg options to use this function";
    guardEntitlementsUsage = (appName = "default") => {
      if (ContextHolder.for(appName).shouldLoadEntitlements()) return;
      throw new Error(ENTITLEMENTS_NOT_ENABLED_EXCEPTION_TEXT);
    };
    getPermissionEntitlements = (entitlements, key, attributes, isV2, appName = "default") => {
      guardEntitlementsUsage(appName);
      return (0, import_entitlements_javascript_commons.evaluateIsEntitledToPermissions)(key, entitlements, attributes);
    };
    getFeatureEntitlements = (entitlements, key, attributes, isV2, appName = "default") => {
      guardEntitlementsUsage(appName);
      return (0, import_entitlements_javascript_commons.evaluateIsEntitledToFeature)(key, entitlements, attributes);
    };
    getEntitlements = (entitlements, options, attributes, isV2, appName = "default") => {
      if ("permissionKey" in options) {
        return getPermissionEntitlements(entitlements, options.permissionKey, attributes, isV2, appName);
      }
      return getFeatureEntitlements(entitlements, options.featureKey, attributes, isV2, appName);
    };
  }
});

// node_modules/@frontegg/redux-store/auth/MfaState/interfaces.js
var MFAStep;
var init_interfaces31 = __esm({
  "node_modules/@frontegg/redux-store/auth/MfaState/interfaces.js"() {
    (function(MFAStep2) {
      MFAStep2["verify"] = "verify";
      MFAStep2["recoveryCode"] = "recoveryCode";
      MFAStep2["authenticatorApp"] = "authenticatorApp";
      MFAStep2["smsSetPhoneNumber"] = "smsSetPhoneNumber";
      MFAStep2["smsVerifyCode"] = "smsVerifyCode";
      MFAStep2["emailVerifyCode"] = "emailVerifyCode";
      MFAStep2["noMFAEnrolledStepUp"] = "noMFAEnrolledStepUp";
    })(MFAStep || (MFAStep = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/helpers.js
function isEmailPayload(payload) {
  return "email" in payload;
}
var isAbsoluteUrl, isValidRedirectUrl, getRedirectUrl, getSearchParamsFromUrl, getPathAndSearchParamsFromUrl, getSearchParam, TENANT_ID_PARAM_KEY, getNumberOfMfaDevices, getMfaStepForEnrolledUsers, getMfaStepForNotEnrolledUsers, isOauthCallbackRoute, getBaseNameWithoutSlashSuffix, shouldShowPasswordRotationPromptFunc;
var init_helpers3 = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/helpers.js"() {
    init_rest_api();
    init_interfaces31();
    isAbsoluteUrl = (path) => {
      try {
        new URL(path);
        return true;
      } catch (e) {
        return false;
      }
    };
    isValidRedirectUrl = (redirectUrl, allowedRedirectOrigins) => {
      const currentUrl = new URL(window.location.href);
      const redirectURL = new URL(redirectUrl);
      const isSameSite = redirectURL.origin === currentUrl.origin;
      const isOriginInWhiteList = allowedRedirectOrigins.includes(redirectURL.origin);
      return isOriginInWhiteList || isSameSite;
    };
    getRedirectUrl = ({
      authenticatedUrl,
      enforceRedirectToSameSite,
      allowedRedirectOrigins,
      includeQueryParam
    }) => {
      const currentUrl = new URL(window.location.href);
      let redirectUrl = authenticatedUrl;
      const redirectUrlQueryParam = currentUrl.searchParams.get("redirectUrl");
      if (redirectUrlQueryParam) {
        if (!enforceRedirectToSameSite || !isAbsoluteUrl(redirectUrlQueryParam)) {
          redirectUrl = redirectUrlQueryParam;
        } else {
          if (isValidRedirectUrl(redirectUrlQueryParam, allowedRedirectOrigins)) {
            redirectUrl = redirectUrlQueryParam;
          } else {
            console.warn("The redirect url param is not valid, the origin is a different site");
          }
        }
      } else if (includeQueryParam) {
        redirectUrl += window.location.search;
      }
      return redirectUrl;
    };
    getSearchParamsFromUrl = (url) => {
      const {
        searchParams
      } = new URL(url);
      const stringifySearchParam = searchParams.toString();
      if (stringifySearchParam) {
        return `?${stringifySearchParam}`;
      }
      return void 0;
    };
    getPathAndSearchParamsFromUrl = (url, preventRedirectUrlOriginCleaning = false) => {
      const {
        pathname,
        href
      } = new URL(url);
      if (preventRedirectUrlOriginCleaning) {
        return href;
      }
      const searchParams = getSearchParamsFromUrl(url);
      if (searchParams) {
        return pathname + searchParams;
      }
      return pathname;
    };
    getSearchParam = (key) => {
      const params = new URLSearchParams(window.location.search);
      const param = params.get(key);
      return param != null ? param : void 0;
    };
    TENANT_ID_PARAM_KEY = "tenantId";
    getNumberOfMfaDevices = (mfaDevices) => {
      const numberOfWebAuthnDevices = +Boolean(mfaDevices.webauthn.length);
      const numberOfPhoneDevices = +Boolean(mfaDevices.phones.length);
      const numberOfAuthenticators = +Boolean(mfaDevices.authenticators.length);
      const numberOfEmails = +Boolean(mfaDevices.emails.length);
      const totalDevices = numberOfWebAuthnDevices + numberOfPhoneDevices + numberOfAuthenticators + numberOfEmails;
      return {
        numberOfWebAuthnDevices,
        numberOfPhoneDevices,
        numberOfAuthenticators,
        numberOfEmails,
        totalDevices
      };
    };
    getMfaStepForEnrolledUsers = (mfaDevices) => {
      const {
        numberOfPhoneDevices,
        numberOfAuthenticators,
        numberOfEmails,
        totalDevices
      } = getNumberOfMfaDevices(mfaDevices);
      if (totalDevices === 1) {
        if (numberOfAuthenticators) {
          return MFAStep.authenticatorApp;
        } else if (numberOfPhoneDevices) {
          return MFAStep.smsVerifyCode;
        } else if (numberOfEmails) {
          return MFAStep.emailVerifyCode;
        }
      }
      return MFAStep.verify;
    };
    getMfaStepForNotEnrolledUsers = (mfaStrategies) => {
      if (mfaStrategies.length === 1) {
        const [strategy] = mfaStrategies;
        if (strategy === MFAStrategyEnum.AuthenticatorApp) {
          return MFAStep.authenticatorApp;
        } else if (strategy === MFAStrategyEnum.SMS) {
          return MFAStep.smsSetPhoneNumber;
        } else if (strategy === MFAStrategyEnum.EmailCode) {
          return MFAStep.emailVerifyCode;
        }
      }
      return MFAStep.verify;
    };
    isOauthCallbackRoute = (activeUri) => {
      return activeUri === "/oauth/callback";
    };
    getBaseNameWithoutSlashSuffix = (state) => {
      const basename = ContextHolder.for(state.root.appName).getBasename();
      if (basename != null && basename.endsWith("/")) {
        return basename.slice(0, -1);
      }
      return basename;
    };
    shouldShowPasswordRotationPromptFunc = (user) => {
      return user.passwordExpiresIn !== void 0 && user.notificationPeriod !== void 0 && user.passwordExpiresIn <= user.notificationPeriod;
    };
  }
});

// node_modules/@frontegg/redux-store/auth/StepUpState/helpers.js
function setAfterAuthRedirectUrlForStepUp() {
  const encodedRedirectUrl = window.location.pathname + window.location.search;
  window.localStorage.setItem(FRONTEGG_AFTER_AUTH_REDIRECT_URL, encodedRedirectUrl);
}
var isSteppedUp, redirectByStepUpUrl;
var init_helpers4 = __esm({
  "node_modules/@frontegg/redux-store/auth/StepUpState/helpers.js"() {
    init_constants3();
    init_consts();
    isSteppedUp = (user, {
      maxAge
    } = {}) => {
      if (!user) return false;
      const {
        amr = [],
        acr = "",
        auth_time
      } = user;
      if (maxAge && auth_time) {
        const isMaxAgeValid = Date.now() / 1e3 - auth_time <= maxAge;
        if (!isMaxAgeValid) return false;
      }
      const isACRValid = acr === ACR_VALUE;
      const isAMRIncludesMFA = amr.indexOf(AMR_MFA_VALUE) !== -1;
      const isAMRIncludesMethod = AMR_ADDITIONAL_VALUE.find((method) => amr.indexOf(method)) !== void 0;
      return isACRValid && isAMRIncludesMFA && isAMRIncludesMethod;
    };
    redirectByStepUpUrl = (stepUpUrl, onRedirectTo, maxAge) => {
      setAfterAuthRedirectUrlForStepUp();
      const searchParams = new URLSearchParams(window.location.search);
      if (maxAge) {
        searchParams.set(STEP_UP_MAX_AGE_PARAM_NAME, maxAge.toString());
      }
      onRedirectTo(`${stepUpUrl}${searchParams ? `?${searchParams}` : ""}`, {
        refresh: false
      });
    };
  }
});

// node_modules/@frontegg/redux-store/auth/helpers.js
var _excluded11, _excluded26, isMfaRequired, isResetPasswordRequired, mapMetaDataObjectToActions, getUri, prepareIdentifiersForSignup, isAuthRoute;
var init_helpers5 = __esm({
  "node_modules/@frontegg/redux-store/auth/helpers.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_rest_api();
    init_consts2();
    init_helpers2();
    init_helpers3();
    init_helpers4();
    _excluded11 = ["phoneNumber", "email"];
    _excluded26 = ["authenticatedUrl"];
    isMfaRequired = (user, appName) => {
      const contextHolder = ContextHolder.for(appName);
      if (user.mfaRequired && user.mfaToken) {
        contextHolder.setAccessToken(null);
        contextHolder.setUser(null);
        return true;
      }
      contextHolder.setAccessToken(user.accessToken);
      contextHolder.setUser(user);
      return false;
    };
    isResetPasswordRequired = (user, appName) => {
      const contextHolder = ContextHolder.for(appName);
      if (user.resetPasswordToken) {
        contextHolder.setAccessToken(null);
        return true;
      }
      contextHolder.setAccessToken(user.accessToken);
      contextHolder.setUser(user);
      return false;
    };
    mapMetaDataObjectToActions = (obj, path = []) => {
      return Object.entries(obj).reduce((acc, [key, value]) => {
        if (typeof value === "object") {
          return [...acc, ...mapMetaDataObjectToActions(value, [...path, key])];
        }
        return [...acc, {
          type: [...path, key].join("/"),
          payload: value
        }];
      }, []);
    };
    getUri = (urlStrategy) => {
      if (urlStrategy === "path") {
        var _window;
        return ((_window = window) != null ? _window : document).location.pathname;
      } else {
        var _window2;
        const uri = (((_window2 = window) != null ? _window2 : document).location.hash || "#").substring(1);
        if (uri.indexOf("?") !== -1) {
          return uri.substring(0, uri.indexOf("?"));
        } else {
          return uri;
        }
      }
    };
    prepareIdentifiersForSignup = (payload) => {
      const {
        phoneNumber,
        email
      } = payload, finalDto = _objectWithoutPropertiesLoose(payload, _excluded11);
      if (email != null && email.length) {
        Object.assign(finalDto, {
          email
        });
      }
      if (phoneNumber != null && phoneNumber.length) {
        Object.assign(finalDto, {
          phoneNumber
        });
      }
      return finalDto;
    };
    isAuthRoute = (path, routes) => {
      const _defaultFronteggRoute = _extends({}, defaultFronteggRoutes, routes), authRoutes = _objectWithoutPropertiesLoose(_defaultFronteggRoute, _excluded26);
      return Object.values(authRoutes).includes(path);
    };
  }
});

// node_modules/@frontegg/redux-store/auth/TeamState/interfaces.js
var TeamStateKeys;
var init_interfaces32 = __esm({
  "node_modules/@frontegg/redux-store/auth/TeamState/interfaces.js"() {
    (function(TeamStateKeys2) {
      TeamStateKeys2["USERS"] = "USERS";
      TeamStateKeys2["STATS"] = "STATS";
      TeamStateKeys2["UPDATE_USER"] = "UPDATE_USER";
      TeamStateKeys2["DELETE_USER"] = "DELETE_USER";
      TeamStateKeys2["RESEND_ACTIVATE_LINK"] = "RESEND_ACTIVATE_LINK";
      TeamStateKeys2["RESEND_INVITATION_LINK"] = "RESEND_INVITATION_LINK";
      TeamStateKeys2["ROLES_AND_PERMISSIONS"] = "ROLES_AND_PERMISSIONS";
      TeamStateKeys2["CREATE_TOKEN_LINK"] = "CREATE_TOKEN_LINK";
      TeamStateKeys2["GET_TOKEN_LINK"] = "GET_TOKEN_LINK";
      TeamStateKeys2["UPDATE_TOKEN_LINK"] = "UPDATE_TOKEN_LINK";
      TeamStateKeys2["DELETE_TOKEN_LINK"] = "DELETE_TOKEN_LINK";
      TeamStateKeys2["CONFIG_TOKEN_LINK"] = "CONFIG_TOKEN_LINK";
      TeamStateKeys2["CONFIG_TEMPORARY_USERS"] = "CONFIG_TEMPORARY_USERS";
      TeamStateKeys2["UPDATE_USER_EXPIRATION_TIME"] = "UPDATE_USER_EXPIRATION_TIME";
    })(TeamStateKeys || (TeamStateKeys = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/ActivateAccountState/actions.js
var _excluded12, _excluded27, _excluded34, _excluded42, _excluded52, _excluded62, _excluded72, actions_default3;
var init_actions3 = __esm({
  "node_modules/@frontegg/redux-store/auth/ActivateAccountState/actions.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_state3();
    init_rest_api();
    init_helpers();
    init_interfaces29();
    init_interfaces30();
    init_gtm();
    init_helpers5();
    init_interfaces32();
    _excluded12 = ["user"];
    _excluded27 = ["callback", "events"];
    _excluded34 = ["user"];
    _excluded42 = ["callback", "events"];
    _excluded52 = ["user"];
    _excluded62 = ["callback"];
    _excluded72 = ["callback"];
    actions_default3 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setActivateState = (state) => {
        Object.assign(store.auth.activateAccountState, state);
      };
      const resetActivateState = () => {
        deepResetState(store, ["auth", "activateAccountState"], initialState3);
      };
      const setActivateStrategyState = (state) => {
        Object.assign(store.auth.activateAccountState.activationStrategy, state);
      };
      const preActivateAccount = async (payload) => {
        const {
          userId,
          token
        } = payload;
        setActivateState({
          loading: true,
          step: ActivateAccountStep.activating
        });
        try {
          const isAuthenticated = store.auth.isAuthenticated;
          if (isAuthenticated) {
            await actions.silentLogout();
          }
          const strategy = await api2.auth.getActivateAccountStrategy({
            userId,
            token
          });
          setActivateStrategyState({
            strategy,
            loading: false,
            error: void 0
          });
          if (strategy.shouldSetPassword) {
            setActivateState({
              loading: false,
              step: ActivateAccountStep.activatingForm
            });
          }
        } catch (e) {
          setActivateState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const handleActivationResponse = async ({
        loginResponse,
        events,
        onRedirectTo,
        routes
      }) => {
        const {
          user
        } = loginResponse, rest = _objectWithoutPropertiesLoose(loginResponse, _excluded12);
        if (user.redirectLocation) {
          window.location.href = user.redirectLocation;
          return;
        }
        if (isMfaRequired(user, store.root.appName)) {
          setActivateState({
            step: ActivateAccountStep.success
          });
          const mfaRequiredState = await actions.getMfaRequiredState(user);
          actions.setAuthState(mfaRequiredState);
          await delay(1e3);
          onRedirectTo(routes.loginUrl, {
            preserveQueryParams: true
          });
        } else {
          var _events$userVerified;
          setActivateState({
            step: ActivateAccountStep.success
          });
          const userVerifiedPayload = {
            email: user.email,
            origin: UserVerifiedOriginTypes.ACTIVATION_LINK,
            id: user.id,
            tenantId: user.tenantId,
            name: user.name,
            createdAt: /* @__PURE__ */ new Date()
          };
          events == null ? void 0 : (_events$userVerified = events.userVerified) == null ? void 0 : _events$userVerified.call(events, userVerifiedPayload);
          reportGTMEvent(GTMEventAction.USER_VERIFIED, userVerifiedPayload);
          actions.afterAuthenticationStateUpdate(_extends({
            user
          }, rest), {
            isAuthenticated: true
          });
          await delay(5e3);
          await actions.afterAuthNavigation();
          resetActivateState();
        }
      };
      const activateAccount = async (_payload) => {
        const {
          callback,
          events
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded27);
        setActivateState({
          loading: true,
          submitting: true
        });
        try {
          const onRedirectTo = ContextHolder.for(store.root.appName).onRedirectTo;
          const routes = store.auth.routes;
          const _await$api$auth$activ = await api2.auth.activateAccountV2(payload), {
            user
          } = _await$api$auth$activ, rest = _objectWithoutPropertiesLoose(_await$api$auth$activ, _excluded34);
          setActivateState({
            submitting: false
          });
          await handleActivationResponse({
            loginResponse: _extends({
              user
            }, rest),
            events,
            onRedirectTo,
            routes
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setActivateState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const activateAccountWithCode = async (_payload) => {
        const {
          callback,
          events
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded42);
        setActivateState({
          loading: true,
          submitting: true
        });
        try {
          const onRedirectTo = ContextHolder.for(store.root.appName).onRedirectTo;
          const routes = store.auth.routes;
          const _await$api$auth$activ2 = await api2.auth.activateAccountWithOTC(payload), {
            user
          } = _await$api$auth$activ2, rest = _objectWithoutPropertiesLoose(_await$api$auth$activ2, _excluded52);
          setActivateState({
            submitting: false
          });
          await handleActivationResponse({
            loginResponse: _extends({
              user
            }, rest),
            events,
            onRedirectTo,
            routes
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setActivateState({
            submitting: false,
            loading: false,
            error: errorHandler(e),
            step: ActivateAccountStep.activating
          });
        }
      };
      const getActivateAccountStrategy = async (payload) => {
        const {
          callback
        } = payload, params = _objectWithoutPropertiesLoose(payload, _excluded62);
        setActivateStrategyState({
          loading: true
        });
        try {
          const strategy = await api2.auth.getActivateAccountStrategy(params);
          setActivateStrategyState({
            strategy,
            loading: false,
            error: void 0
          });
          callback == null ? void 0 : callback(strategy);
        } catch (e) {
          setActivateStrategyState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const resendActivationEmail = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded72);
        actions.setTeamLoader({
          key: TeamStateKeys.RESEND_ACTIVATE_LINK,
          value: body.email
        });
        setActivateState({
          loading: true
        });
        try {
          await api2.auth.resendActivationEmail(body);
          setActivateState({
            loading: false,
            error: void 0,
            resentEmail: true
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setActivateState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          actions.setTeamLoader({
            key: TeamStateKeys.RESEND_ACTIVATE_LINK,
            value: false
          });
        }
      };
      return {
        setActivateState,
        resetActivateState,
        setActivateStrategyState,
        activateAccount,
        preActivateAccount,
        getActivateAccountStrategy,
        resendActivationEmail,
        activateAccountWithCode
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ActivateAccountState/index.js
var init_ActivateAccountState = __esm({
  "node_modules/@frontegg/redux-store/auth/ActivateAccountState/index.js"() {
    init_state3();
    init_actions3();
  }
});

// node_modules/@frontegg/redux-store/auth/UnlockAccountState/state.js
var initialState4, state_default4;
var init_state4 = __esm({
  "node_modules/@frontegg/redux-store/auth/UnlockAccountState/state.js"() {
    init_proxy();
    initialState4 = {
      loading: false,
      error: void 0,
      unlockAccountSuccess: false
    };
    state_default4 = (overrideState) => createProxy2(initialState4, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/UnlockAccountState/actions.js
var actions_default4;
var init_actions4 = __esm({
  "node_modules/@frontegg/redux-store/auth/UnlockAccountState/actions.js"() {
    init_state4();
    init_helpers();
    init_rest_api();
    actions_default4 = (store, api2, sharedActions) => {
      const setUnlockAccountState = (state) => {
        Object.assign(store.auth.unlockAccountState, state);
      };
      const resetUnlockAccountState = () => {
        deepResetState(store, ["auth", "activateAccountState"], initialState4);
      };
      const unlockAccount = async (_payload) => {
        const {
          token
        } = _payload;
        const onRedirectTo = ContextHolder.for(store.root.appName).onRedirectTo;
        const routes = store.auth.routes;
        setUnlockAccountState({
          loading: true
        });
        try {
          await api2.users.unlockMe({
            token
          });
          setUnlockAccountState({
            loading: false,
            error: void 0,
            unlockAccountSuccess: true
          });
          await delay(5e3);
          onRedirectTo(routes.loginUrl);
        } catch (e) {
          setUnlockAccountState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      return {
        setUnlockAccountState,
        resetUnlockAccountState,
        unlockAccount
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/UnlockAccountState/index.js
var init_UnlockAccountState = __esm({
  "node_modules/@frontegg/redux-store/auth/UnlockAccountState/index.js"() {
    init_state4();
    init_actions4();
  }
});

// node_modules/@frontegg/redux-store/auth/ApiTokensState/state.js
var initialState5, state_default5;
var init_state5 = __esm({
  "node_modules/@frontegg/redux-store/auth/ApiTokensState/state.js"() {
    init_proxy();
    initialState5 = {
      apiTokenType: null,
      searchValue: "",
      showAddTokenDialog: false,
      createdByUserIdColumn: "show",
      deleteTokenDialog: {
        open: false,
        clientId: ""
      },
      successDialog: {
        open: false,
        secret: "",
        clientId: ""
      },
      loaders: {},
      apiTokensDataTenant: [],
      apiTokensDataUser: [],
      roles: [],
      permissions: [],
      errors: {}
    };
    state_default5 = (overrideState) => createProxy2(initialState5, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/ApiTokensState/interfaces.js
var ApiStateKeys;
var init_interfaces33 = __esm({
  "node_modules/@frontegg/redux-store/auth/ApiTokensState/interfaces.js"() {
    init_rest_api();
    (function(ApiStateKeys2) {
      ApiStateKeys2["LOAD_API_TOKENS"] = "LOAD_API_TOKENS";
      ApiStateKeys2["ADD_API_TOKEN"] = "ADD_API_TOKEN";
      ApiStateKeys2["DELETE_API_TOKEN"] = "DELETE_API_TOKEN";
    })(ApiStateKeys || (ApiStateKeys = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/ApiTokensState/actions.js
var actions_default5;
var init_actions5 = __esm({
  "node_modules/@frontegg/redux-store/auth/ApiTokensState/actions.js"() {
    init_extends();
    init_state5();
    init_rest_api();
    init_helpers();
    init_interfaces33();
    actions_default5 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setApiTokensLoader = (payload) => {
        Object.assign(store.auth.apiTokensState, {
          loaders: _extends({}, store.auth.apiTokensState.loaders, {
            [payload.key]: payload.value
          })
        });
      };
      const setApiTokensError = (payload) => {
        Object.assign(store.auth.apiTokensState, {
          errors: _extends({}, store.auth.apiTokensState.errors, {
            [payload.key]: payload.value
          }),
          loaders: _extends({}, store.auth.apiTokensState.loaders, {
            [payload.key]: false
          })
        });
      };
      const setApiTokensState = (state) => {
        Object.assign(store.auth.apiTokensState, state);
      };
      const resetApiTokensState = () => {
        deepResetState(store, ["auth", "apiTokensState"], initialState5);
      };
      const loadApiTokens = async (payload) => {
        if (!(payload != null && payload.silentLoading)) {
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: true
          });
        }
        try {
          var _payload$callback;
          const [apiTokensDataUser = [], apiTokensDataTenant = []] = await Promise.all([api2.auth.getUserApiTokensData(), api2.auth.getTenantApiTokensData()]);
          setApiTokensState({
            apiTokensDataUser,
            apiTokensDataTenant
          });
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: false
          });
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
        } catch (e) {
          var _payload$callback2;
          setApiTokensError({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: errorHandler(e)
          });
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: false
          });
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
        }
      };
      const loadUserApiTokens = async (payload) => {
        if (!(payload != null && payload.silentLoading)) {
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: true
          });
        }
        try {
          var _accessTokensData$acc, _payload$callback3;
          const [apiTokensData = [], accessTokensData] = await Promise.all([retryIfNeeded2(() => api2.auth.getUserApiTokensData(), payload == null ? void 0 : payload.retryConfig), retryIfNeeded2(() => api2.auth.getUserAccessTokensData(), payload == null ? void 0 : payload.retryConfig)]);
          const accessTokens = (_accessTokensData$acc = accessTokensData.accessTokens) != null ? _accessTokensData$acc : [];
          const allTokens = accessTokens.map((item) => _extends({}, item, {
            type: MachineToMachineAuthStrategy.AccessToken
          })).concat(apiTokensData.map((item) => _extends({}, item, {
            type: MachineToMachineAuthStrategy.ClientCredentials
          })));
          const sortedTokensByDate = allTokens.sort((date1, date2) => new Date(date2.createdAt) - new Date(date1.createdAt));
          setApiTokensState({
            apiTokensDataUser: sortedTokensByDate != null ? sortedTokensByDate : []
          });
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: false
          });
          payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
        } catch (e) {
          var _payload$callback4;
          setApiTokensError({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: errorHandler(e)
          });
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: false
          });
          payload == null ? void 0 : (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, null, e);
        }
      };
      const loadTenantApiTokens = async (payload) => {
        if (!(payload != null && payload.silentLoading)) {
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: true
          });
        }
        try {
          var _accessTokensData$acc2, _payload$callback5;
          const [apiTokensData = [], accessTokensData] = await Promise.all([retryIfNeeded2(() => api2.auth.getTenantApiTokensData(), payload == null ? void 0 : payload.retryConfig), retryIfNeeded2(() => api2.auth.getTenantAccessTokensData(), payload == null ? void 0 : payload.retryConfig)]);
          const accessTokens = (_accessTokensData$acc2 = accessTokensData == null ? void 0 : accessTokensData.accessTokens) != null ? _accessTokensData$acc2 : [];
          const allTokens = accessTokens.map((item) => _extends({}, item, {
            type: MachineToMachineAuthStrategy.AccessToken
          })).concat(apiTokensData.map((item) => _extends({}, item, {
            type: MachineToMachineAuthStrategy.ClientCredentials
          })));
          const sortedTokensByDate = allTokens.sort((date1, date2) => new Date(date2.createdAt) - new Date(date1.createdAt));
          setApiTokensState({
            apiTokensDataTenant: sortedTokensByDate != null ? sortedTokensByDate : []
          });
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: false
          });
          payload == null ? void 0 : (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, true);
        } catch (e) {
          var _payload$callback6;
          setApiTokensError({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: errorHandler(e)
          });
          setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: false
          });
          payload == null ? void 0 : (_payload$callback6 = payload.callback) == null ? void 0 : _payload$callback6.call(payload, null, e);
        }
      };
      const addTenantApiToken = async (payload) => {
        const {
          description,
          roleIds,
          expires,
          callback
        } = payload;
        const actionKey = ApiStateKeys.ADD_API_TOKEN;
        setApiTokensLoader({
          key: actionKey,
          value: true
        });
        try {
          const {
            policy
          } = store.auth.securityPolicyState.publicPolicy;
          const isAccessToken = (policy == null ? void 0 : policy.machineToMachineAuthStrategy) === MachineToMachineAuthStrategy.AccessToken;
          let data;
          let expiresInMinutes = null;
          if (expires) {
            expiresInMinutes = expires * 1440;
          }
          if (isAccessToken) {
            data = await api2.auth.createTenantAccessToken({
              description,
              expiresInMinutes,
              roleIds
            });
          } else {
            data = await api2.auth.updateTenantApiTokensData({
              description,
              roleIds,
              expiresInMinutes
            });
          }
          setApiTokensState({
            showAddTokenDialog: false
          });
          await delay(200);
          const type = isAccessToken ? MachineToMachineAuthStrategy.AccessToken : MachineToMachineAuthStrategy.ClientCredentials;
          store.auth.apiTokensState.apiTokensDataTenant.unshift(_extends({}, data, {
            type
          }));
          store.auth.apiTokensState.successDialog = {
            open: true,
            secret: data.secret,
            clientId: !isAccessToken ? data.clientId : void 0
          };
          callback == null ? void 0 : callback(null);
        } catch (e) {
          setApiTokensError({
            key: actionKey,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          setApiTokensLoader({
            key: actionKey,
            value: false
          });
        }
      };
      const addUserApiToken = async (payload) => {
        const {
          description,
          expires,
          callback
        } = payload;
        const actionKey = ApiStateKeys.ADD_API_TOKEN;
        setApiTokensLoader({
          key: actionKey,
          value: true
        });
        try {
          const {
            policy
          } = store.auth.securityPolicyState.publicPolicy;
          const isAccessToken = (policy == null ? void 0 : policy.machineToMachineAuthStrategy) === MachineToMachineAuthStrategy.AccessToken;
          let data;
          let expiresInMinutes = null;
          if (expires) {
            expiresInMinutes = expires * 1440;
          }
          if (isAccessToken) {
            data = await api2.auth.createUserAccessToken({
              description,
              expiresInMinutes
            });
          } else {
            data = await api2.auth.updateUserApiTokensData({
              description,
              expiresInMinutes
            });
          }
          setApiTokensState({
            showAddTokenDialog: false
          });
          await delay(200);
          const type = isAccessToken ? MachineToMachineAuthStrategy.AccessToken : MachineToMachineAuthStrategy.ClientCredentials;
          store.auth.apiTokensState.apiTokensDataUser.unshift(_extends({}, data, {
            type
          }));
          store.auth.apiTokensState.successDialog = {
            open: true,
            secret: data.secret,
            clientId: !isAccessToken ? data.clientId : void 0
          };
          callback == null ? void 0 : callback(null);
        } catch (e) {
          setApiTokensError({
            key: actionKey,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          setApiTokensLoader({
            key: actionKey,
            value: false
          });
        }
      };
      const deleteUserApiToken = async (payload) => {
        const actionKey = ApiStateKeys.DELETE_API_TOKEN;
        setApiTokensLoader({
          key: actionKey,
          value: true
        });
        try {
          const apiTokensDataUser = store.auth.apiTokensState.apiTokensDataUser;
          const isAccessToken = apiTokensDataUser.some((token) => token.id === payload);
          if (isAccessToken) {
            await api2.auth.deleteUserAccessToken({
              id: payload
            });
            setApiTokensState({
              apiTokensDataUser: apiTokensDataUser.filter((token) => token.id !== payload),
              deleteTokenDialog: {
                open: false,
                id: payload
              }
            });
          } else {
            await api2.auth.deleteUserApiToken({
              tokenId: payload
            });
            setApiTokensState({
              apiTokensDataUser: apiTokensDataUser.filter((token) => token.clientId !== payload),
              deleteTokenDialog: {
                open: false,
                clientId: payload
              }
            });
          }
        } catch (e) {
          setApiTokensError({
            key: actionKey,
            value: errorHandler(e)
          });
        } finally {
          setApiTokensLoader({
            key: actionKey,
            value: false
          });
        }
      };
      const deleteTenantApiToken = async (payload) => {
        const actionKey = ApiStateKeys.DELETE_API_TOKEN;
        setApiTokensLoader({
          key: actionKey,
          value: true
        });
        try {
          const apiTokensDataTenant = store.auth.apiTokensState.apiTokensDataTenant;
          const isAccessToken = apiTokensDataTenant.some((token) => token.id === payload);
          if (isAccessToken) {
            await api2.auth.deleteTenantAccessToken({
              id: payload
            });
            setApiTokensState({
              apiTokensDataTenant: apiTokensDataTenant.filter((token) => token.id !== payload),
              deleteTokenDialog: {
                open: false,
                id: payload
              }
            });
          } else {
            await api2.auth.deleteTenantApiToken({
              tokenId: payload
            });
            setApiTokensState({
              apiTokensDataTenant: apiTokensDataTenant.filter((token) => token.clientId !== payload),
              deleteTokenDialog: {
                open: false,
                id: payload
              }
            });
          }
        } catch (e) {
          setApiTokensError({
            key: actionKey,
            value: errorHandler(e)
          });
        } finally {
          setApiTokensLoader({
            key: actionKey,
            value: false
          });
        }
      };
      return {
        setApiTokensLoader,
        setApiTokensError,
        setApiTokensState,
        resetApiTokensState,
        loadApiTokens,
        loadUserApiTokens,
        loadTenantApiTokens,
        // initApiTokensData, not used
        addTenantApiToken,
        addUserApiToken,
        deleteUserApiToken,
        deleteTenantApiToken
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ApiTokensState/index.js
var init_ApiTokensState = __esm({
  "node_modules/@frontegg/redux-store/auth/ApiTokensState/index.js"() {
    init_state5();
    init_actions5();
  }
});

// node_modules/@frontegg/redux-store/auth/ApplicationsState/state.js
var initialState6, state_default6;
var init_state6 = __esm({
  "node_modules/@frontegg/redux-store/auth/ApplicationsState/state.js"() {
    init_proxy();
    initialState6 = {
      loading: true,
      fetching: true,
      error: null,
      userApplications: [],
      accountApplications: []
    };
    state_default6 = (overrideState) => createProxy2(initialState6, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/ApplicationsState/helpers.js
var getFlattenAppIds;
var init_helpers6 = __esm({
  "node_modules/@frontegg/redux-store/auth/ApplicationsState/helpers.js"() {
    getFlattenAppIds = (listWithAppIds) => {
      var _listWithAppIds$map$r;
      return (_listWithAppIds$map$r = listWithAppIds.map(({
        appIds
      }) => appIds).reduce((allAppIds, currentAppIds) => {
        currentAppIds == null ? void 0 : currentAppIds.forEach((item) => {
          if (allAppIds && !allAppIds.includes(item)) {
            allAppIds.push(item);
          }
        });
        return allAppIds;
      }, [])) != null ? _listWithAppIds$map$r : [];
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ApplicationsState/actions.js
var actions_default6;
var init_actions6 = __esm({
  "node_modules/@frontegg/redux-store/auth/ApplicationsState/actions.js"() {
    init_extends();
    init_rest_api();
    init_helpers();
    init_state6();
    init_helpers6();
    actions_default6 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setApplicationsState = (payload) => {
        Object.assign(store.auth.applicationsState, payload);
      };
      const resetApplicationsState = () => {
        deepResetState(store, ["auth", "applicationsState"], initialState6);
      };
      const loadUserApplications = async (payload) => {
        setApplicationsState({
          loading: true,
          fetching: true
        });
        try {
          var _store$auth$user$id, _store$auth$user;
          const userId = (_store$auth$user$id = (_store$auth$user = store.auth.user) == null ? void 0 : _store$auth$user.id) != null ? _store$auth$user$id : "";
          const retryConfig = payload == null ? void 0 : payload.retryConfig;
          const appIds = await retryIfNeeded2(() => api2.applications.getUserApplicationsId({
            userId
          }), retryConfig);
          const userApplications = await retryIfNeeded2(() => api2.applications.getApplicationsData({
            appIds
          }), retryConfig);
          setApplicationsState({
            userApplications,
            fetching: false,
            loading: false
          });
        } catch (e) {
          setApplicationsState({
            loading: false,
            fetching: false,
            error: errorHandler(e)
          });
        }
      };
      const loadAccountApplications = async (payload) => {
        const retryConfig = payload == null ? void 0 : payload.retryConfig;
        setApplicationsState({
          loading: true,
          fetching: true
        });
        try {
          const tenantAppIds = await retryIfNeeded2(() => api2.applications.getTenantsApplications(), retryConfig);
          const appIds = getFlattenAppIds(tenantAppIds);
          const accountApplications = await retryIfNeeded2(() => api2.applications.getApplicationsData({
            appIds
          }), retryConfig);
          const usersOfApplications = await retryIfNeeded2(() => api2.applications.getUsersOfApplications({
            appIds
          }), retryConfig);
          const accountApplicationsWithUsers = accountApplications.map((app) => {
            var _usersOfApplications$;
            return _extends({}, app, {
              userIds: (_usersOfApplications$ = usersOfApplications.find((u) => u.appId === app.id)) == null ? void 0 : _usersOfApplications$.userIds
            });
          });
          setApplicationsState({
            accountApplications: accountApplicationsWithUsers,
            fetching: false,
            loading: false
          });
        } catch (e) {
          setApplicationsState({
            loading: false,
            fetching: false,
            error: errorHandler(e)
          });
        }
      };
      const loadMultipleUsersApplications = async ({
        userIds,
        retryConfig
      }) => {
        try {
          const usersAppIds = await retryIfNeeded2(() => api2.applications.getUsersApplicationsId({
            userIds
          }), retryConfig);
          const appIds = getFlattenAppIds(usersAppIds);
          const accountApplications = await retryIfNeeded2(() => api2.applications.getApplicationsData({
            appIds
          }), retryConfig);
          return userIds.reduce((acc, userId) => {
            var _usersAppIds$find, _userAppIds$map$filte, _userAppIds$map;
            const userAppIds = (_usersAppIds$find = usersAppIds.find((app) => app.userId == userId)) == null ? void 0 : _usersAppIds$find.appIds;
            acc[userId] = [...accountApplications.filter((app) => app.accessType === ApplicationAccessType.FREE_ACCESS), ...(_userAppIds$map$filte = userAppIds == null ? void 0 : (_userAppIds$map = userAppIds.map((appId) => accountApplications.find((app) => appId === app.id))) == null ? void 0 : _userAppIds$map.filter((app) => !!app)) != null ? _userAppIds$map$filte : []];
            return acc;
          }, {});
        } catch (e) {
          setApplicationsState({
            error: errorHandler(e)
          });
        }
      };
      const ASSIGNMENT_DEFAULT_ERROR_MESSAGE = "Assignment action failed. Try again or contact support.";
      const assignUserToApps = async (payload) => {
        const {
          userId,
          appIds,
          callback
        } = payload;
        try {
          var _store$auth$user$tena, _store$auth, _store$auth$user2, _store$auth2, _store$auth2$applicat, _store$auth$teamState, _store$auth3, _store$auth3$teamStat, _accountApps$filter;
          const tenantId = (_store$auth$user$tena = (_store$auth = store.auth) == null ? void 0 : (_store$auth$user2 = _store$auth.user) == null ? void 0 : _store$auth$user2.tenantId) != null ? _store$auth$user$tena : "";
          await api2.applications.assignUserToApplications({
            userId,
            appIds,
            tenantId
          });
          const accountApps = (_store$auth2 = store.auth) == null ? void 0 : (_store$auth2$applicat = _store$auth2.applicationsState) == null ? void 0 : _store$auth2$applicat.accountApplications;
          const users = (_store$auth$teamState = (_store$auth3 = store.auth) == null ? void 0 : (_store$auth3$teamStat = _store$auth3.teamState) == null ? void 0 : _store$auth3$teamStat.users) != null ? _store$auth$teamState : [];
          const newApps = (_accountApps$filter = accountApps == null ? void 0 : accountApps.filter((app) => appIds.includes(app.id))) != null ? _accountApps$filter : [];
          if (newApps != null && newApps.length) {
            sharedActions.setTeamState({
              users: users.map((user) => {
                var _user$applications;
                return user.id === userId ? _extends({}, user, {
                  applications: [...(_user$applications = user.applications) != null ? _user$applications : [], ...newApps]
                }) : user;
              })
            });
          }
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setApplicationsState({
            error: errorHandler(e, ASSIGNMENT_DEFAULT_ERROR_MESSAGE)
          });
          callback == null ? void 0 : callback(false);
        }
      };
      const unassignUserFromApps = async (payload) => {
        const {
          userId,
          appIds,
          callback
        } = payload;
        try {
          var _store$auth$user$tena2, _store$auth4, _store$auth4$user, _store$auth$teamState2, _store$auth5, _store$auth5$teamStat, _users$find;
          const tenantId = (_store$auth$user$tena2 = (_store$auth4 = store.auth) == null ? void 0 : (_store$auth4$user = _store$auth4.user) == null ? void 0 : _store$auth4$user.tenantId) != null ? _store$auth$user$tena2 : "";
          await api2.applications.unassignUserFromApplications({
            userId,
            appIds,
            tenantId
          });
          const users = (_store$auth$teamState2 = (_store$auth5 = store.auth) == null ? void 0 : (_store$auth5$teamStat = _store$auth5.teamState) == null ? void 0 : _store$auth5$teamStat.users) != null ? _store$auth$teamState2 : [];
          const userApps = (_users$find = users.find((user) => user.id === userId)) == null ? void 0 : _users$find.applications;
          if (userApps != null && userApps.length && appIds.length) {
            sharedActions.setTeamState({
              users: users.map((user) => user.id === userId ? _extends({}, user, {
                applications: userApps.filter((app) => !appIds.includes(app.id))
              }) : user)
            });
          }
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setApplicationsState({
            error: errorHandler(e, ASSIGNMENT_DEFAULT_ERROR_MESSAGE)
          });
          callback == null ? void 0 : callback(false);
        }
      };
      const assignNewUserToApps = async ({
        appIds,
        user
      }) => {
        var _store$auth6, _store$auth6$applicat, _apps$filter;
        const [multiAppsFlag] = await actions.getFeatureFlags(["multi-apps-admin-portal"]);
        if (!multiAppsFlag) {
          return;
        }
        const apps = (_store$auth6 = store.auth) == null ? void 0 : (_store$auth6$applicat = _store$auth6.applicationsState) == null ? void 0 : _store$auth6$applicat.accountApplications;
        const defaultApps = (_apps$filter = apps == null ? void 0 : apps.filter((app) => app.accessType === ApplicationAccessType.FREE_ACCESS)) != null ? _apps$filter : [];
        if (appIds != null && appIds.length) {
          var _store$auth$user$tena3, _store$auth7, _store$auth7$user;
          const tenantId = (_store$auth$user$tena3 = (_store$auth7 = store.auth) == null ? void 0 : (_store$auth7$user = _store$auth7.user) == null ? void 0 : _store$auth7$user.tenantId) != null ? _store$auth$user$tena3 : "";
          await api2.applications.assignUserToApplications({
            userId: user.id,
            appIds,
            tenantId
          });
          return appIds.map((appId) => {
            var _apps$find;
            return (_apps$find = apps == null ? void 0 : apps.find((app) => app.id === appId)) != null ? _apps$find : [];
          }).concat(defaultApps);
        } else {
          return defaultApps;
        }
      };
      const mapUsersWithApplicationData = async ({
        shouldLoadApps,
        users,
        retryConfig
      }) => {
        const [multiAppsFlag] = await sharedActions.getFeatureFlags(["multi-apps-admin-portal"]);
        if (!multiAppsFlag || !shouldLoadApps) {
          return users;
        }
        const userIds = users.map((user) => user.id);
        const userApps = await loadMultipleUsersApplications({
          userIds,
          retryConfig
        });
        if (!userApps) {
          return users;
        }
        return users.map((user) => userApps != null && userApps[user.id] ? _extends({}, user, {
          applications: userApps[user.id]
        }) : user);
      };
      return {
        setApplicationsState,
        resetApplicationsState,
        loadUserApplications,
        loadAccountApplications,
        loadMultipleUsersApplications,
        assignUserToApps,
        unassignUserFromApps,
        assignNewUserToApps,
        mapUsersWithApplicationData
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ApplicationsState/index.js
var init_ApplicationsState = __esm({
  "node_modules/@frontegg/redux-store/auth/ApplicationsState/index.js"() {
    init_state6();
    init_actions6();
  }
});

// node_modules/@frontegg/redux-store/auth/CustomLoginState/state.js
var initialState7, state_default7;
var init_state7 = __esm({
  "node_modules/@frontegg/redux-store/auth/CustomLoginState/state.js"() {
    init_proxy();
    initialState7 = {
      loading: true,
      error: null
    };
    state_default7 = (overrideState) => createProxy2(initialState7, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/CustomLoginState/actions.js
var _excluded13, actions_default7;
var init_actions7 = __esm({
  "node_modules/@frontegg/redux-store/auth/CustomLoginState/actions.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_state7();
    init_helpers();
    init_helpers5();
    init_rest_api();
    init_helpers3();
    _excluded13 = ["callback"];
    actions_default7 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setCustomLoginState = (payload) => {
        Object.assign(store.auth.customLoginState, payload);
      };
      const resetCustomLoginState = () => {
        deepResetState(store, ["auth", "customLoginState"], initialState7);
      };
      const loadTenantMetadata = async () => {
        setCustomLoginState({
          loading: true
        });
        try {
          const tenantMetadata = await api2.metadata.getAdminBoxMetadata();
          setCustomLoginState({
            tenantMetadata,
            loading: false
          });
        } catch (e) {
          setCustomLoginState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const updateTenantMetadata = async (payload) => {
        const {
          callback
        } = payload, state = _objectWithoutPropertiesLoose(payload, _excluded13);
        try {
          setCustomLoginState({
            error: null,
            saving: true
          });
          const requestActions = mapMetaDataObjectToActions(state);
          if (requestActions.length === 0) {
            throw new Error("No changes to update");
          }
          await api2.metadata.updateAdminBoxMetadata({
            actions: requestActions
          });
          const tenantMetadata = await api2.metadata.getAdminBoxMetadata();
          setCustomLoginState({
            tenantMetadata,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setCustomLoginState({
            error: errorHandler(e, "No changes to update"),
            saving: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const customLoginEnabled = async () => {
        var _await$ContextHolder$, _ContextHolder$for$ge, _ContextHolder$for$ge2;
        const isAuthenticated = store.auth.isAuthenticated;
        if (isAuthenticated) {
          var _store$auth$tenantsSt, _store$auth$tenantsSt2;
          return (_store$auth$tenantsSt = (_store$auth$tenantsSt2 = store.auth.tenantsState.activeTenant) == null ? void 0 : _store$auth$tenantsSt2.hasCustomLogin) != null ? _store$auth$tenantsSt : false;
        }
        const resolvedTenant = (_await$ContextHolder$ = await ((_ContextHolder$for$ge = ContextHolder.for(store.root.appName).getContext()) == null ? void 0 : (_ContextHolder$for$ge2 = _ContextHolder$for$ge.tenantResolver) == null ? void 0 : _ContextHolder$for$ge2.call(_ContextHolder$for$ge))) == null ? void 0 : _await$ContextHolder$.tenant;
        return !!resolvedTenant;
      };
      const loadCustomLoginRoutes = async (payload) => {
        try {
          var _getSearchParamsFromU, _payload$callback3;
          const isCustomLoginEnabled = await customLoginEnabled();
          if (!isCustomLoginEnabled) {
            var _payload$callback;
            payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
            return;
          }
          const isAuthenticated = store.auth.isAuthenticated;
          const {
            getSettings,
            getPublicSettings
          } = api2.accountSettings;
          const {
            applicationUrl
          } = await retryIfNeeded2(isAuthenticated ? getSettings : getPublicSettings, payload == null ? void 0 : payload.retryConfig);
          if (!applicationUrl) {
            var _payload$callback2;
            payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, true);
            return;
          }
          const routes = store.auth.routes;
          const searchParams = (_getSearchParamsFromU = getSearchParamsFromUrl(applicationUrl)) != null ? _getSearchParamsFromU : "";
          actions.setAuthState({
            routes: _extends({}, routes, {
              customLoginAuthenticatedUrl: applicationUrl,
              customLoginUrl: routes.loginUrl + searchParams
            })
          });
          setCustomLoginState({
            customLoginSearchParams: searchParams != null ? searchParams : void 0
          });
          payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
        } catch (e) {
          var _payload$callback4;
          payload == null ? void 0 : (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, null, e);
        }
      };
      return {
        setCustomLoginState,
        resetCustomLoginState,
        loadTenantMetadata,
        updateTenantMetadata,
        customLoginEnabled,
        loadCustomLoginRoutes
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/CustomLoginState/index.js
var init_CustomLoginState = __esm({
  "node_modules/@frontegg/redux-store/auth/CustomLoginState/index.js"() {
    init_state7();
    init_actions7();
  }
});

// node_modules/@frontegg/redux-store/auth/ForgotPasswordState/interfaces.js
var ForgotPasswordStep;
var init_interfaces34 = __esm({
  "node_modules/@frontegg/redux-store/auth/ForgotPasswordState/interfaces.js"() {
    (function(ForgotPasswordStep2) {
      ForgotPasswordStep2["forgotPassword"] = "forgotPassword";
      ForgotPasswordStep2["success"] = "success";
    })(ForgotPasswordStep || (ForgotPasswordStep = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/ForgotPasswordState/state.js
var initialState8, state_default8;
var init_state8 = __esm({
  "node_modules/@frontegg/redux-store/auth/ForgotPasswordState/state.js"() {
    init_interfaces34();
    init_proxy();
    initialState8 = {
      step: ForgotPasswordStep.forgotPassword,
      loading: false,
      email: "",
      passwordConfig: null
    };
    state_default8 = (overrideState) => createProxy2(initialState8, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/ForgotPasswordState/actions.js
var _excluded14, actions_default8;
var init_actions8 = __esm({
  "node_modules/@frontegg/redux-store/auth/ForgotPasswordState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_interfaces34();
    init_state8();
    init_helpers();
    _excluded14 = ["callback"];
    actions_default8 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setForgotPasswordState = (payload) => {
        Object.assign(store.auth.forgotPasswordState, payload);
      };
      const resetForgotPasswordState = () => {
        deepResetState(store, ["auth", "forgotPasswordState"], initialState8);
      };
      const forgotPassword = async (payload) => {
        setForgotPasswordState({
          loading: true
        });
        try {
          var _payload$callback;
          await api2.auth.forgotPassword(payload);
          setForgotPasswordState({
            loading: false,
            error: void 0,
            step: ForgotPasswordStep.success
          });
          (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
        } catch (e) {
          var _payload$callback2;
          setForgotPasswordState({
            loading: false,
            error: errorHandler(e, "Unknown error occurred")
          });
          (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, false, e);
        }
      };
      const resetPassword = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded14);
        setForgotPasswordState({
          loading: true
        });
        try {
          await api2.auth.resetPassword(body);
          setForgotPasswordState({
            loading: false,
            error: void 0,
            step: ForgotPasswordStep.success
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setForgotPasswordState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      const loadPasswordConfig = async (payload) => {
        setForgotPasswordState({
          loading: true
        });
        try {
          const passwordConfig = await api2.auth.loadPasswordConfig(payload);
          setForgotPasswordState({
            loading: false,
            passwordConfig
          });
        } catch (e) {
          setForgotPasswordState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      return {
        setForgotPasswordState,
        resetForgotPasswordState,
        forgotPassword,
        resetPassword,
        loadPasswordConfig
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ForgotPasswordState/index.js
var init_ForgotPasswordState = __esm({
  "node_modules/@frontegg/redux-store/auth/ForgotPasswordState/index.js"() {
    init_state8();
    init_actions8();
  }
});

// node_modules/@frontegg/redux-store/auth/PasswordRotationState/interfaces.js
var PasswordRotationStep;
var init_interfaces35 = __esm({
  "node_modules/@frontegg/redux-store/auth/PasswordRotationState/interfaces.js"() {
    (function(PasswordRotationStep2) {
      PasswordRotationStep2["success"] = "success";
      PasswordRotationStep2["notification"] = "notification";
    })(PasswordRotationStep || (PasswordRotationStep = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/PasswordRotationState/state.js
var initialState9, state_default9;
var init_state9 = __esm({
  "node_modules/@frontegg/redux-store/auth/PasswordRotationState/state.js"() {
    init_interfaces35();
    init_proxy();
    initialState9 = {
      step: PasswordRotationStep.notification
    };
    state_default9 = (overrideState) => createProxy2(initialState9, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/PasswordRotationState/actions.js
var actions_default9;
var init_actions9 = __esm({
  "node_modules/@frontegg/redux-store/auth/PasswordRotationState/actions.js"() {
    actions_default9 = (store, api2, sharedActions) => {
      const setPasswordRotationState = (payload) => {
        Object.assign(store.auth.passwordRotationState, payload);
      };
      const setStep = (step) => {
        setPasswordRotationState({
          step
        });
      };
      return {
        setStep
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/PasswordRotationState/index.js
var init_PasswordRotationState = __esm({
  "node_modules/@frontegg/redux-store/auth/PasswordRotationState/index.js"() {
    init_state9();
    init_actions9();
  }
});

// node_modules/@frontegg/redux-store/auth/GroupsState/state.js
var initialState10, state_default10;
var init_state10 = __esm({
  "node_modules/@frontegg/redux-store/auth/GroupsState/state.js"() {
    init_proxy();
    initialState10 = {
      loaders: {},
      errors: {},
      groups: [],
      groupsConfiguration: {}
    };
    state_default10 = (overrideState) => createProxy2(initialState10, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/GroupsState/interfaces.js
var GroupsStateKeys, GroupRelations2;
var init_interfaces36 = __esm({
  "node_modules/@frontegg/redux-store/auth/GroupsState/interfaces.js"() {
    (function(GroupsStateKeys2) {
      GroupsStateKeys2["CREATE_GROUP"] = "CREATE_GROUP";
      GroupsStateKeys2["GET_GROUP"] = "GET_GROUP";
      GroupsStateKeys2["GET_GROUPS"] = "GET_GROUPS";
      GroupsStateKeys2["DELETE_GROUP"] = "DELETE_GROUP";
      GroupsStateKeys2["UPDATE_GROUP"] = "UPDATE_GROUP";
      GroupsStateKeys2["ADD_USERS_TO_GROUP"] = "ADD_USERS_TO_GROUP";
      GroupsStateKeys2["DELETE_USERS_FROM_GROUP"] = "DELETE_USERS_FROM_GROUP";
      GroupsStateKeys2["ADD_ROLES_TO_GROUP"] = "ADD_ROLES_TO_GROUP";
      GroupsStateKeys2["DELETE_ROLES_FROM_GROUP"] = "DELETE_ROLES_FROM_GROUP";
      GroupsStateKeys2["GET_GROUP_CONFIGURATION"] = "GET_GROUP_CONFIGURATION";
      GroupsStateKeys2["UPDATE_GROUP_CONFIGURATION"] = "UPDATE_GROUP_CONFIGURATION";
      GroupsStateKeys2["GET_TEAM_USERS"] = "GET_TEAM_USERS";
    })(GroupsStateKeys || (GroupsStateKeys = {}));
    (function(GroupRelations3) {
      GroupRelations3["roles"] = "roles";
      GroupRelations3["users"] = "users";
      GroupRelations3["rolesAndUsers"] = "rolesAndUsers";
    })(GroupRelations2 || (GroupRelations2 = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/GroupsState/actions.js
var _excluded15, actions_default10;
var init_actions10 = __esm({
  "node_modules/@frontegg/redux-store/auth/GroupsState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_interfaces36();
    init_helpers();
    init_state10();
    _excluded15 = ["roleIds", "userIds"];
    actions_default10 = (store, api2, sharedActions) => {
      const setUsersGroupsLoader = (payload) => {
        Object.assign(store.auth.groupsState, {
          loaders: _extends({}, store.auth.groupsState.loaders, {
            [payload.key]: payload.value
          })
        });
      };
      const setUsersGroupsError = (payload) => {
        Object.assign(store.auth.groupsState, {
          errors: _extends({}, store.auth.groupsState.errors, {
            [payload.key]: payload.value
          }),
          loaders: _extends({}, store.auth.groupsState.loaders, {
            [payload.key]: false
          })
        });
      };
      const setGroupsState = (payload) => {
        Object.assign(store.auth.groupsState, payload);
      };
      const resetUsersGroupsState = () => {
        deepResetState(store, ["auth", "groupsState"], initialState10);
      };
      const loadGroups = async (payload) => {
        const key = GroupsStateKeys.GET_GROUPS;
        const state = store.auth.groupsState;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          const {
            groups
          } = await retryIfNeeded2(() => api2.groups.getGroups({
            _groupsRelations: GroupRelations2.rolesAndUsers
          }), payload == null ? void 0 : payload.retryConfig);
          setGroupsState(_extends({
            groups
          }, state.selectedGroup && {
            selectedGroup: groups.find((g) => {
              var _state$selectedGroup;
              return g.id === ((_state$selectedGroup = state.selectedGroup) == null ? void 0 : _state$selectedGroup.id);
            })
          }));
        } catch (e) {
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const getGroupById = async (payload) => {
        const key = GroupsStateKeys.GET_GROUP;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          const selectedGroup = await api2.groups.getGroupById({
            groupId: payload.groupId
          }, {
            _groupsRelations: GroupRelations2.rolesAndUsers
          });
          setGroupsState({
            selectedGroup
          });
        } catch (e) {
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const createGroup = async (payload) => {
        const key = GroupsStateKeys.CREATE_GROUP;
        const {
          roleIds,
          userIds
        } = payload, createGroupPayload = _objectWithoutPropertiesLoose(payload, _excluded15);
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          var _payload$callback;
          const response = await api2.groups.createGroup(_extends({
            name: createGroupPayload.name
          }, !!createGroupPayload.description && {
            description: createGroupPayload.description
          }, {
            color: createGroupPayload.color
          }));
          if (userIds != null && userIds.length) {
            addUsersToGroup({
              groupId: response.id,
              userIds
            });
          }
          if (roleIds != null && roleIds.length) {
            addRolesToGroup({
              groupId: response.id,
              roleIds
            });
          }
          await loadGroups();
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
        } catch (e) {
          var _payload$callback2;
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, false);
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const updateGroup = async (payload) => {
        const key = GroupsStateKeys.UPDATE_GROUP;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          var _payload$callback3;
          await api2.groups.updateGroup(payload);
          await loadGroups();
          payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
        } catch (e) {
          var _payload$callback4;
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
          payload == null ? void 0 : (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, false);
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const deleteGroup = async (payload) => {
        const key = GroupsStateKeys.DELETE_GROUP;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          var _payload$callback5;
          await api2.groups.deleteGroup(payload.groupId);
          await loadGroups();
          payload == null ? void 0 : (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, true);
        } catch (e) {
          var _payload$callback6;
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
          payload == null ? void 0 : (_payload$callback6 = payload.callback) == null ? void 0 : _payload$callback6.call(payload, false, e);
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const addRolesToGroup = async (payload) => {
        const key = GroupsStateKeys.ADD_ROLES_TO_GROUP;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          var _payload$callback7;
          await api2.groups.addRolesToGroup(payload.groupId, {
            roleIds: payload.roleIds
          });
          await loadGroups();
          payload == null ? void 0 : (_payload$callback7 = payload.callback) == null ? void 0 : _payload$callback7.call(payload, true);
        } catch (e) {
          var _payload$callback8;
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
          payload == null ? void 0 : (_payload$callback8 = payload.callback) == null ? void 0 : _payload$callback8.call(payload, false);
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const deleteRolesFromGroup = async (payload) => {
        const key = GroupsStateKeys.DELETE_ROLES_FROM_GROUP;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          var _payload$callback9;
          await api2.groups.deleteRolesFromGroup(payload.groupId, {
            roleIds: payload.roleIds
          });
          await loadGroups();
          payload == null ? void 0 : (_payload$callback9 = payload.callback) == null ? void 0 : _payload$callback9.call(payload, true);
        } catch (e) {
          var _payload$callback10;
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
          payload == null ? void 0 : (_payload$callback10 = payload.callback) == null ? void 0 : _payload$callback10.call(payload, false);
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const addUsersToGroup = async (payload) => {
        const key = GroupsStateKeys.ADD_USERS_TO_GROUP;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          var _payload$callback11;
          await api2.groups.addUsersToGroup(payload.groupId, {
            userIds: payload.userIds
          });
          await loadGroups();
          payload == null ? void 0 : (_payload$callback11 = payload.callback) == null ? void 0 : _payload$callback11.call(payload, true);
        } catch (e) {
          var _payload$callback12;
          payload == null ? void 0 : (_payload$callback12 = payload.callback) == null ? void 0 : _payload$callback12.call(payload, false);
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const deleteUsersFromGroup = async (payload) => {
        const key = GroupsStateKeys.DELETE_USERS_FROM_GROUP;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          var _payload$callback13;
          await api2.groups.deleteUsersFromGroup(payload.groupId, {
            userIds: payload.userIds
          });
          await loadGroups();
          payload == null ? void 0 : (_payload$callback13 = payload.callback) == null ? void 0 : _payload$callback13.call(payload, true);
        } catch (e) {
          var _payload$callback14;
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
          payload == null ? void 0 : (_payload$callback14 = payload.callback) == null ? void 0 : _payload$callback14.call(payload, false);
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const getGroupConfiguration = async (payload) => {
        const key = GroupsStateKeys.GET_GROUP_CONFIGURATION;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          const groupsConfiguration = await retryIfNeeded2(() => api2.groups.getGroupConfiguration(), payload == null ? void 0 : payload.retryConfig);
          setGroupsState({
            groupsConfiguration
          });
        } catch (e) {
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const updateGroupConfiguration = async (payload) => {
        const key = GroupsStateKeys.UPDATE_GROUP_CONFIGURATION;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          await api2.groups.updateGroupConfiguration(payload);
          await getGroupConfiguration();
        } catch (e) {
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      const getTeamUsers = async (payload) => {
        const key = GroupsStateKeys.GET_TEAM_USERS;
        setUsersGroupsLoader({
          key,
          value: true
        });
        try {
          const {
            items: teamUsers
          } = await api2.users.getUsersV2({
            _filter: payload.filter,
            _offset: payload.pageOffset,
            _limit: payload.pageSize,
            _includeSubTenants: false
          });
          setGroupsState({
            teamUsers
          });
        } catch (e) {
          setUsersGroupsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setUsersGroupsLoader({
            key,
            value: false
          });
        }
      };
      return {
        setUsersGroupsLoader,
        setUsersGroupsError,
        setGroupsState,
        resetUsersGroupsState,
        loadGroups,
        getGroupById,
        createGroup,
        updateGroup,
        deleteGroup,
        addRolesToGroup,
        deleteRolesFromGroup,
        addUsersToGroup,
        deleteUsersFromGroup,
        getGroupConfiguration,
        updateGroupConfiguration,
        getTeamUsers
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/GroupsState/index.js
var init_GroupsState = __esm({
  "node_modules/@frontegg/redux-store/auth/GroupsState/index.js"() {
    init_state10();
    init_actions10();
  }
});

// node_modules/@frontegg/redux-store/auth/GroupsDialogsState/state.js
var initialState11, state_default11;
var init_state11 = __esm({
  "node_modules/@frontegg/redux-store/auth/GroupsDialogsState/state.js"() {
    init_proxy();
    initialState11 = {
      addGroupDialogState: {
        loading: false,
        open: false
      },
      editGroupDialogState: {
        loading: false,
        open: false
      },
      deleteGroupDialogState: {
        loading: false,
        open: false
      },
      addMembersToGroupDialogState: {
        loading: false,
        open: false,
        userIds: []
      },
      deleteMemberFromGroupDialogState: {
        loading: false,
        open: false
      }
    };
    state_default11 = (overrideState) => createProxy2(initialState11, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/GroupsDialogsState/actions.js
var actions_default11;
var init_actions11 = __esm({
  "node_modules/@frontegg/redux-store/auth/GroupsDialogsState/actions.js"() {
    init_extends();
    init_helpers();
    init_state11();
    actions_default11 = (store, api2, sharedActions) => {
      const setGroupsDialogsState = (payload) => {
        Object.assign(store.auth.groupsDialogsState, payload);
      };
      const resetGroupsDialogsState = () => {
        deepResetState(store, ["auth", "groupsDialogsState"], initialState11);
      };
      const openAddGroupDialog = () => {
        store.auth.groupsDialogsState.addGroupDialogState.open = true;
      };
      const closeAddGroupDialog = () => {
        Object.assign(store.auth.groupsDialogsState.addGroupDialogState, {
          open: false,
          group: void 0
        });
      };
      const openAddMembersToGroupDialog = () => {
        store.auth.groupsDialogsState.addMembersToGroupDialogState.open = true;
      };
      const closeAddMembersToGroupDialog = () => {
        Object.assign(store.auth.groupsDialogsState.addMembersToGroupDialogState, {
          open: false,
          userIds: []
        });
      };
      const openEditGroupDialog = (payload) => {
        Object.assign(store.auth.groupsDialogsState.editGroupDialogState, _extends({}, payload, {
          open: true
        }));
      };
      const closeEditGroupDialog = () => {
        Object.assign(store.auth.groupsDialogsState.editGroupDialogState, {
          open: false,
          loading: false,
          group: void 0
        });
      };
      const openDeleteGroupDialog = (payload) => {
        Object.assign(store.auth.groupsDialogsState.deleteGroupDialogState, _extends({}, payload, {
          open: true
        }));
      };
      const closeDeleteGroupDialog = () => {
        Object.assign(store.auth.groupsDialogsState.deleteGroupDialogState, {
          open: false,
          loading: false,
          group: void 0
        });
      };
      const openDeleteMemberFromGroupDialog = (payload) => {
        Object.assign(store.auth.groupsDialogsState.deleteMemberFromGroupDialogState, payload);
      };
      const closeDeleteMemberFromGroupDialog = () => {
        Object.assign(store.auth.groupsDialogsState.deleteMemberFromGroupDialogState, {
          open: false,
          userId: void 0,
          email: void 0
        });
      };
      return {
        setGroupsDialogsState,
        resetGroupsDialogsState,
        openAddGroupDialog,
        closeAddGroupDialog,
        openAddMembersToGroupDialog,
        closeAddMembersToGroupDialog,
        openEditGroupDialog,
        closeEditGroupDialog,
        openDeleteGroupDialog,
        closeDeleteGroupDialog,
        openDeleteMemberFromGroupDialog,
        closeDeleteMemberFromGroupDialog
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/GroupsDialogsState/index.js
var init_GroupsDialogsState = __esm({
  "node_modules/@frontegg/redux-store/auth/GroupsDialogsState/index.js"() {
    init_state11();
    init_actions11();
  }
});

// node_modules/@frontegg/redux-store/auth/ImpersonateState/interfaces.js
var ImpersonateStep;
var init_interfaces37 = __esm({
  "node_modules/@frontegg/redux-store/auth/ImpersonateState/interfaces.js"() {
    (function(ImpersonateStep2) {
      ImpersonateStep2["impersonating"] = "impersonating";
      ImpersonateStep2["success"] = "success";
    })(ImpersonateStep || (ImpersonateStep = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/ImpersonateState/state.js
var initialState12, state_default12;
var init_state12 = __esm({
  "node_modules/@frontegg/redux-store/auth/ImpersonateState/state.js"() {
    init_interfaces37();
    init_proxy();
    initialState12 = {
      step: ImpersonateStep.impersonating,
      loading: false
    };
    state_default12 = (overrideState) => createProxy2(initialState12, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/ImpersonateState/actions.js
var _excluded16, actions_default12;
var init_actions12 = __esm({
  "node_modules/@frontegg/redux-store/auth/ImpersonateState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_interfaces37();
    init_helpers();
    init_state12();
    _excluded16 = ["callback", "events"];
    actions_default12 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setImpersonateState = (state) => {
        Object.assign(store.auth.impersonateState, state);
      };
      const resetImpersonateState = () => {
        deepResetState(store, ["auth", "impersonateState"], initialState12);
      };
      const impersonate = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded16);
        setImpersonateState({
          loading: true
        });
        try {
          const data = await api2.impersonate.impersonate(payload);
          setImpersonateState({
            step: ImpersonateStep.success
          });
          await delay(1e3);
          await actions.afterAuthNavigation({
            preventRedirectUrlOriginCleaning: true
          });
          resetImpersonateState();
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setImpersonateState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      return {
        setImpersonateState,
        resetImpersonateState,
        impersonate
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ImpersonateState/index.js
var init_ImpersonateState = __esm({
  "node_modules/@frontegg/redux-store/auth/ImpersonateState/index.js"() {
    init_state12();
    init_actions12();
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/state.js
var initialState13, state_default13;
var init_state13 = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/state.js"() {
    init_interfaces28();
    init_proxy();
    initialState13 = {
      flow: LoginFlow.Login,
      step: LoginStep.preLogin,
      loading: false,
      email: "",
      tenants: []
    };
    state_default13 = (overrideState) => createProxy2(initialState13, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/afterAuthNavigation.actions.js
var afterAuthNavigation_actions_default;
var init_afterAuthNavigation_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/afterAuthNavigation.actions.js"() {
    init_extends();
    init_helpers3();
    init_constants3();
    init_consts();
    init_helpers();
    init_helpers4();
    afterAuthNavigation_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      function cleanUrlIfSameOrigin(url) {
        var _window, _window2;
        if (!url.startsWith((_window = window) == null ? void 0 : _window.location.origin)) {
          return url;
        }
        return url.replace((_window2 = window) == null ? void 0 : _window2.location.origin, "");
      }
      function afterAuthenticationStateUpdate({
        user,
        tenants = [],
        activeTenant
      }, additionalUpdate = {}) {
        const currentTenantsState = store.auth.tenantsState;
        actions.setAuthState(_extends({
          user,
          tenantsState: _extends({}, currentTenantsState, {
            tenants,
            activeTenant,
            loading: false
          })
        }, additionalUpdate));
      }
      async function __getUrlForAfterAuthNavigation({
        customLoginAuthenticatedUrl,
        preventRedirectUrlOriginCleaning
      }) {
        const {
          routes,
          includeQueryParam = false,
          enforceRedirectToSameSite = false,
          allowedRedirectOrigins = []
        } = store.auth;
        const urlFromLocalStorage = window.localStorage.getItem(FRONTEGG_AFTER_AUTH_REDIRECT_URL);
        if (customLoginAuthenticatedUrl && !urlFromLocalStorage) {
          return getPathAndSearchParamsFromUrl(customLoginAuthenticatedUrl, preventRedirectUrlOriginCleaning);
        }
        const {
          authenticatedUrl,
          loginUrl,
          logoutUrl,
          socialLoginCallbackUrl,
          activateUrl,
          activateWithOTCUrl
        } = routes;
        let finalUrl = urlFromLocalStorage;
        if (!finalUrl || [loginUrl, logoutUrl, socialLoginCallbackUrl, activateUrl, activateWithOTCUrl].includes(finalUrl)) {
          finalUrl = authenticatedUrl;
        }
        const redirectUrl = getRedirectUrl({
          authenticatedUrl: finalUrl,
          includeQueryParam,
          enforceRedirectToSameSite,
          allowedRedirectOrigins
        });
        if (preventRedirectUrlOriginCleaning) {
          return redirectUrl;
        }
        return cleanUrlIfSameOrigin(redirectUrl);
      }
      const afterAuthNavigationUtil = async (resetStateAction, options = {}) => {
        const {
          customLoginAuthenticatedUrl,
          forceStepUpUrl,
          shouldStepUpDuringLogin,
          preventRedirectUrlOriginCleaning = false
        } = options;
        const onRedirectTo = store.auth.onRedirectTo;
        let redirectUrl = void 0;
        if (forceStepUpUrl) {
          redirectUrl = forceStepUpUrl;
        } else {
          var _window3;
          if (shouldStepUpDuringLogin) {
            const localStorageRedirectUrl = window.localStorage.getItem(FRONTEGG_AFTER_AUTH_REDIRECT_URL);
            if (localStorageRedirectUrl && !isAbsoluteUrl(localStorageRedirectUrl)) {
              redirectUrl = localStorageRedirectUrl;
            }
          }
          if (!redirectUrl) {
            redirectUrl = await __getUrlForAfterAuthNavigation({
              customLoginAuthenticatedUrl,
              preventRedirectUrlOriginCleaning
            });
          }
          (_window3 = window) == null ? void 0 : _window3.localStorage.removeItem(FRONTEGG_AFTER_AUTH_REDIRECT_URL);
        }
        await delay(200);
        await resetStateAction();
        onRedirectTo(redirectUrl, {
          refresh: redirectUrl.startsWith("http")
        });
      };
      const afterAuthNavigation = async (payload) => {
        var _window4, _payload$preventRedir;
        const {
          customLoginAuthenticatedUrl,
          stepUpUrl
        } = store.auth.routes;
        const shouldStepUp = (_window4 = window) == null ? void 0 : _window4.localStorage.getItem(SHOULD_STEP_UP_KEY);
        const user = store.auth.user;
        if (shouldStepUp) {
          var _window5;
          (_window5 = window) == null ? void 0 : _window5.localStorage.removeItem(SHOULD_STEP_UP_KEY);
        }
        if (stepUpUrl && shouldStepUp && !isSteppedUp(user)) {
          return afterAuthNavigationUtil(actions.resetLoginState, {
            forceStepUpUrl: stepUpUrl
          });
        }
        let customLoginURL = customLoginAuthenticatedUrl;
        if (!customLoginAuthenticatedUrl) {
          var _store$auth$routes;
          await actions.loadCustomLoginRoutes();
          customLoginURL = (_store$auth$routes = store.auth.routes) == null ? void 0 : _store$auth$routes.customLoginAuthenticatedUrl;
        }
        return afterAuthNavigationUtil(actions.resetLoginState, {
          customLoginAuthenticatedUrl: customLoginURL,
          shouldStepUpDuringLogin: !!shouldStepUp,
          preventRedirectUrlOriginCleaning: (_payload$preventRedir = payload == null ? void 0 : payload.preventRedirectUrlOriginCleaning) != null ? _payload$preventRedir : false
        });
      };
      const afterStepUpAuthNavigation = async () => {
        return afterAuthNavigationUtil(actions.resetStepUpState);
      };
      return {
        afterAuthNavigationUtil,
        afterAuthNavigation,
        afterStepUpAuthNavigation,
        afterAuthenticationStateUpdate
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/handleVerifyMFAResponse.actions.js
function handleVerifyMFAResponse_actions_default(store, api2, sharedActions) {
  const actions = sharedActions;
  const getFeatureFlags = async (flags) => {
    const appName = store.root.appName;
    return FeatureFlags.getFeatureFlags(flags, appName);
  };
  const postHandleVerifyMFAResponseForStepUp = async () => {
    return await actions.afterStepUpAuthNavigation();
  };
  const postHandleVerifyMFAResponseForLogin = async (isAuthenticated, user) => {
    const loginState = store.auth.loginState;
    const mfaStep = store.auth.mfaState.step;
    const [securityCenterLoginFlows, passwordRotationFlagEnabled] = await actions.getFeatureFlags(["security-center-show-login-flows", "password-rotation"]);
    if (loginState.flow === LoginFlow.Login) {
      if (securityCenterLoginFlows && loginState.isBreachedPassword && !isAuthenticated) {
        actions.setLoginState({
          step: LoginStep.breachedPassword,
          loading: false
        });
        return;
      }
      if (passwordRotationFlagEnabled && isResetPasswordRequired(user, store.root.appName)) {
        actions.setLoginState({
          step: LoginStep.passwordRotationExpired,
          loading: false,
          resetPasswordToken: user.resetPasswordToken,
          userId: user.userId
        });
        return;
      }
      if (passwordRotationFlagEnabled && shouldShowPasswordRotationPromptFunc(user)) {
        actions.setLoginState({
          step: LoginStep.passwordRotationNotification,
          loading: false
        });
        return;
      }
      const shouldShowPasskeysPrompt = await actions.__shouldShowPromptPasskeys();
      if (mfaStep === MFAStep.smsVerifyCode && shouldShowPasskeysPrompt) {
        actions.setLoginState({
          step: LoginStep.promptPasskeys,
          loading: false
        });
      } else {
        await actions.afterAuthNavigation();
      }
    }
  };
  const handleVerifyMFAResponse = async (payload, isStepUp = false) => {
    const {
      user,
      tenants,
      activeTenant
    } = payload;
    actions.setUser(user);
    actions.setTenantsState({
      tenants,
      activeTenant,
      loading: false
    });
    if (user.id) {
      localStorage.setItem("userId", user.id);
    }
    const isAuthenticated = !!user.accessToken;
    actions.setAuthState({
      isAuthenticated
    });
    if (isStepUp) {
      return await postHandleVerifyMFAResponseForStepUp();
    }
    return await postHandleVerifyMFAResponseForLogin(isAuthenticated, user);
  };
  return {
    postHandleVerifyMFAResponseForStepUp,
    postHandleVerifyMFAResponseForLogin,
    handleVerifyMFAResponse,
    getFeatureFlags
  };
}
var init_handleVerifyMFAResponse_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/handleVerifyMFAResponse.actions.js"() {
    init_rest_api();
    init_interfaces31();
    init_interfaces28();
    init_helpers5();
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaRequiredState.actions.js
var mfaRequiredState_actions_default;
var init_mfaRequiredState_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaRequiredState.actions.js"() {
    init_extends();
    init_helpers3();
    init_interfaces28();
    init_interfaces31();
    init_helpers();
    mfaRequiredState_actions_default = (store, api2, _sharedActions) => {
      const getMfaRequiredState = async (user, retryConfig, shouldContinueWhenFailing = false, emailFromSignup) => {
        var _user$mfaDevices, _user$mfaDevices$emai, _user$userEmail;
        let step = LoginStep.loginWithTwoFactor;
        const mfaState = {
          step: MFAStep.verify,
          loading: false,
          saving: false
        };
        const loginState = store.auth.loginState;
        let isAllowedToRemember;
        let mfaDeviceExpiration;
        try {
          const response = await retryIfNeeded2(() => api2.auth.checkIfAllowToRememberMfaDevice(user.mfaToken), retryConfig);
          isAllowedToRemember = response.isAllowedToRemember;
          mfaDeviceExpiration = response.mfaDeviceExpiration;
        } catch (e) {
          if (!shouldContinueWhenFailing) {
            throw e;
          }
        }
        const isEnrolled = !("mfaEnrolled" in user && !user.mfaEnrolled) || ((_user$mfaDevices = user.mfaDevices) == null ? void 0 : (_user$mfaDevices$emai = _user$mfaDevices.emails) == null ? void 0 : _user$mfaDevices$emai.length);
        if (isEnrolled) {
          Object.assign(mfaState, {
            mfaDevices: user.mfaDevices,
            mfaToken: user.mfaToken,
            step: getMfaStepForEnrolledUsers(user.mfaDevices)
          });
        } else {
          Object.assign(mfaState, {
            step: getMfaStepForNotEnrolledUsers(user.mfaStrategies),
            qrCode: user.qrCode,
            recoveryCode: user.recoveryCode,
            loading: false,
            mfaToken: user.mfaToken,
            mfaStrategies: user.mfaStrategies
          });
          step = LoginStep.forceTwoFactor;
        }
        let quickLoginState = {};
        const quickLoginToRegister = localStorage.getItem("register-quick-login");
        if (quickLoginToRegister) {
          quickLoginState = {
            quickLoginToRegister,
            flow: LoginFlow.RegisterQuickLogin
          };
        }
        return {
          user: void 0,
          isAuthenticated: false,
          mfaState,
          loginState: _extends({}, loginState, quickLoginState, {
            mfaToken: user.mfaToken,
            mfaRequired: user.mfaRequired,
            loading: false,
            error: void 0,
            step,
            tenantsLoading: true,
            email: (_user$userEmail = user.userEmail) != null ? _user$userEmail : emailFromSignup,
            tenants: [],
            allowRememberMfaDevice: isAllowedToRemember,
            mfaDeviceExpiration,
            isBreachedPassword: user.isBreachedPassword
          })
        };
      };
      return {
        getMfaRequiredState
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaWithAuthenticator.actions.js
var _excluded17, mfaWithAuthenticator_actions_default;
var init_mfaWithAuthenticator_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaWithAuthenticator.actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_interfaces28();
    init_helpers();
    init_helpers5();
    _excluded17 = ["callback"];
    mfaWithAuthenticator_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      async function __buildPostAuthStateUpdate(tenants, isAuthenticated, isStepUp) {
        const loginState = store.auth.loginState;
        let additionalUpdate = {};
        if (!isStepUp) {
          const step = loginState.flow === LoginFlow.Login ? LoginStep.success : loginState.step;
          additionalUpdate = {
            loginState: {
              flow: loginState.flow,
              quickLoginToRegister: loginState.quickLoginToRegister,
              loading: false,
              step,
              error: void 0,
              tenants
            }
          };
        }
        return _extends({}, additionalUpdate, {
          isAuthenticated
        });
      }
      async function __postLoginMfaAuthenticator(isAuthenticated, user, callback) {
        const loginState = store.auth.loginState;
        if (loginState.flow !== LoginFlow.Login) return;
        const [securityCenterLoginFlows, passwordRotationFlagEnabled] = await actions.getFeatureFlags(["security-center-show-login-flows", "password-rotation"]);
        if (securityCenterLoginFlows && loginState.isBreachedPassword && !isAuthenticated) {
          actions.setLoginState({
            step: LoginStep.breachedPassword,
            loading: false
          });
          callback == null ? void 0 : callback(true);
          return;
        }
        if (passwordRotationFlagEnabled && isResetPasswordRequired(user, store.root.appName)) {
          actions.setLoginState({
            step: LoginStep.passwordRotationExpired,
            loading: false,
            resetPasswordToken: user.resetPasswordToken,
            userId: user.userId
          });
          callback == null ? void 0 : callback(true);
          return;
        }
        const shouldShowPasswordRotationPrompt = shouldShowPasswordRotationPromptFunc(user);
        if (passwordRotationFlagEnabled && shouldShowPasswordRotationPrompt) {
          actions.setLoginState({
            step: LoginStep.passwordRotationNotification,
            loading: false
          });
          callback == null ? void 0 : callback(true);
          return;
        }
        const shouldShowPrompt = await actions.__shouldShowPromptPasskeys();
        if (shouldShowPrompt) {
          actions.setLoginState({
            step: LoginStep.promptPasskeys,
            loading: false
          });
        } else {
          await actions.afterAuthNavigation();
        }
        callback == null ? void 0 : callback(true);
      }
      async function __postStepUpMfaAuthenticator(callback) {
        await actions.afterStepUpAuthNavigation();
        callback == null ? void 0 : callback(true);
      }
      const mfaWithAuthenticator = async (_ref, setLoadingAction, isStepUp) => {
        let {
          callback
        } = _ref, loginWithMfaPayload = _objectWithoutPropertiesLoose(_ref, _excluded17);
        setLoadingAction({
          loading: true,
          error: void 0
        });
        try {
          const {
            user,
            tenants = [],
            activeTenant
          } = await api2.auth.loginWithMfaV2(loginWithMfaPayload);
          const isAuthenticated = !!user.accessToken;
          const additionalUpdate = await __buildPostAuthStateUpdate(tenants, isAuthenticated, isStepUp);
          await actions.afterAuthenticationStateUpdate({
            user,
            tenants,
            activeTenant
          }, additionalUpdate);
          if (user.id) {
            localStorage.setItem("userId", user.id);
          }
          setLoadingAction({
            loading: false,
            error: void 0
          });
          if (isStepUp) {
            return await __postStepUpMfaAuthenticator(callback);
          }
          return await __postLoginMfaAuthenticator(isAuthenticated, user, callback);
        } catch (e) {
          setLoadingAction({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      const loginWithMfa = async (payload) => {
        return await mfaWithAuthenticator(payload, actions.setLoginState, false);
      };
      return {
        mfaWithAuthenticator,
        loginWithMfa
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaWithEmailCode.actions.js
var _excluded18, _excluded28, mfaWithEmailCode_actions_default;
var init_mfaWithEmailCode_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaWithEmailCode.actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_interfaces31();
    init_helpers();
    _excluded18 = ["callback"];
    _excluded28 = ["callback"];
    mfaWithEmailCode_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const preVerifyMFAEmailCode = async (_ref, setLoadingAction) => {
        var _setLoadingAction;
        let {
          callback
        } = _ref, payload = _objectWithoutPropertiesLoose(_ref, _excluded18);
        setLoadingAction = (_setLoadingAction = setLoadingAction) != null ? _setLoadingAction : actions.setLoginState;
        setLoadingAction({
          loading: true,
          error: void 0
        });
        try {
          const data = await api2.auth.preVerifyMFAEmailCode(payload);
          actions.setMfaState({
            otcToken: data.otcToken,
            step: MFAStep.emailVerifyCode
          });
          setLoadingAction({
            loading: false,
            error: void 0
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoadingAction({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const verifyMFAEmailCode = async (_ref2, setLoadingAction) => {
        var _setLoadingAction2;
        let {
          callback
        } = _ref2, payload = _objectWithoutPropertiesLoose(_ref2, _excluded28);
        setLoadingAction = (_setLoadingAction2 = setLoadingAction) != null ? _setLoadingAction2 : actions.setLoginState;
        setLoadingAction({
          loading: true
        });
        try {
          const data = await api2.auth.verifyMFAEmailCodeV2(payload);
          await actions.handleVerifyMFAResponse(data);
          setLoadingAction({
            loading: false,
            error: void 0
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoadingAction({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const preVerifyMFAEmailCodeForLogin = async (payload) => {
        return await preVerifyMFAEmailCode(payload, actions.setLoginState);
      };
      const verifyMFAEmailCodeForLogin = async (payload) => {
        return await verifyMFAEmailCode(payload, actions.setLoginState);
      };
      return {
        preVerifyMFAEmailCode,
        verifyMFAEmailCode,
        preVerifyMFAEmailCodeForLogin,
        verifyMFAEmailCodeForLogin
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaWithSMS.actions.js
var _excluded19, _excluded29, mfaWithSMS_actions_default;
var init_mfaWithSMS_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaWithSMS.actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_interfaces31();
    init_helpers();
    _excluded19 = ["callback", "deviceId"];
    _excluded29 = ["callback", "deviceId"];
    mfaWithSMS_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const preVerifyMFASMS = async (_ref, setLoadingAction) => {
        let {
          callback,
          deviceId
        } = _ref, payload = _objectWithoutPropertiesLoose(_ref, _excluded19);
        setLoadingAction({
          loading: false,
          error: void 0
        });
        try {
          const data = await api2.auth.preVerifyMFASMSForLogin(deviceId, payload);
          actions.setMfaState({
            otcToken: data.otcToken,
            step: MFAStep.smsVerifyCode,
            phoneNumber: data.phoneNumber
          });
          setLoadingAction({
            loading: false,
            error: void 0
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoadingAction({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const verifyMFASMS = async (_ref2, setLoadingAction, isStepUp = false) => {
        let {
          callback,
          deviceId
        } = _ref2, payload = _objectWithoutPropertiesLoose(_ref2, _excluded29);
        setLoadingAction({
          loading: true
        });
        try {
          const data = await api2.auth.verifyMFASMSForLoginV2(deviceId, payload);
          await actions.handleVerifyMFAResponse(data, isStepUp);
          setLoadingAction({
            loading: false,
            error: void 0
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoadingAction({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const preVerifyMFASMSForLogin = async (payload) => {
        return await preVerifyMFASMS(payload, actions.setLoginState);
      };
      const verifyMFASMSForLogin = async (payload) => {
        return await verifyMFASMS(payload, actions.setLoginState, false);
      };
      return {
        preVerifyMFASMS,
        verifyMFASMS,
        preVerifyMFASMSForLogin,
        verifyMFASMSForLogin
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaWithWebAuthn.actions.js
var _excluded20, _excluded210, mfaWithWebAuthn_actions_default;
var init_mfaWithWebAuthn_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/mfaWithWebAuthn.actions.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_helpers();
    _excluded20 = ["callback", "deviceId"];
    _excluded210 = ["callback", "deviceId"];
    mfaWithWebAuthn_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const preVerifyMFAWebAuthn = async (_ref, setLoadingAction) => {
        let {
          callback,
          deviceId
        } = _ref, payload = _objectWithoutPropertiesLoose(_ref, _excluded20);
        setLoadingAction({
          loading: true
        });
        try {
          var _data$options$allowCr;
          const data = await api2.auth.preVerifyMFAWebAuthnForLogin(deviceId, payload);
          const options = _extends({}, data.options, {
            challenge: base64urlDecode(data.options.challenge),
            allowCredentials: (_data$options$allowCr = data.options.allowCredentials) == null ? void 0 : _data$options$allowCr.map((credentials) => _extends({}, credentials, {
              id: base64urlDecode(credentials.id)
            }))
          });
          setLoadingAction({
            loading: false,
            error: void 0
          });
          callback == null ? void 0 : callback({
            options,
            webauthnToken: data.webauthnToken
          });
        } catch (e) {
          setLoadingAction({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const verifyMFAWebAuthn = async (_ref2, setLoadingAction, isStepUp) => {
        let {
          callback,
          deviceId
        } = _ref2, payload = _objectWithoutPropertiesLoose(_ref2, _excluded210);
        setLoadingAction({
          loading: true
        });
        try {
          const publicKey = publicKeyCredentialToJSON(payload.publicKey);
          const data = await api2.auth.verifyMFAWebAuthnForLoginV2(deviceId, _extends({}, payload, {
            options: publicKey
          }));
          await actions.handleVerifyMFAResponse(data, isStepUp);
          setLoadingAction({
            loading: false,
            error: void 0
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoadingAction({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const preVerifyMFAWebAuthnForLogin = async (payload) => {
        return await preVerifyMFAWebAuthn(payload, actions.setLoginState);
      };
      const verifyMFAWebAuthnForLogin = async (payload) => {
        return await verifyMFAWebAuthn(payload, actions.setLoginState, false);
      };
      return {
        preVerifyMFAWebAuthn,
        verifyMFAWebAuthn,
        preVerifyMFAWebAuthnForLogin,
        verifyMFAWebAuthnForLogin
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/hostedLoginAuthorize.actions.js
var hostedLoginAuthorize_actions_default;
var init_hostedLoginAuthorize_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/hostedLoginAuthorize.actions.js"() {
    init_extends();
    init_helpers();
    init_constants3();
    init_helpers3();
    init_helpers5();
    init_consts();
    hostedLoginAuthorize_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __requestHostedLoginSilentAuthorize = async () => {
        const response = await api2.auth.silentOAuthRefreshTokenV2();
        if (response != null && response.user) {
          await actions.afterAuthenticationStateUpdate(response, {
            isAuthenticated: true,
            isLoading: false
          });
        } else {
          throw new Error(`couldn't refresh user token with oauth service`);
        }
      };
      const requestHostedLoginAuthorize = async (additionalParams) => {
        var _store$auth$customLog;
        const {
          routes,
          onRedirectTo
        } = store.auth;
        const {
          context,
          urlStrategy
        } = store.root;
        const activeUri = getUri(urlStrategy);
        if (activeUri === routes.hostedLoginRedirectUrl) {
          console.debug("Calling loginWithRedirect while in hostedLoginCallback route");
          return;
        }
        actions.setAuthState({
          isLoading: true
        });
        const nonce = createRandomString();
        const code_verifier = createRandomString();
        const code_challenge = await generateCodeChallenge(code_verifier);
        localStorage.setItem(HOSTED_LOGIN_VERIFIER_KEY, code_verifier);
        const basename = getBaseNameWithoutSlashSuffix(store);
        let redirectUrl = `${window.location.origin}${urlStrategy === "path" ? "" : "#"}${basename != null ? basename : ""}${routes.hostedLoginRedirectUrl}`;
        await actions.loadCustomLoginRoutes();
        const customLoginSearchParam = (_store$auth$customLog = store.auth.customLoginState) == null ? void 0 : _store$auth$customLog.customLoginSearchParams;
        if (customLoginSearchParam) {
          if (redirectUrl.endsWith("/")) {
            redirectUrl = redirectUrl.slice(0, -1);
          }
          redirectUrl += customLoginSearchParam;
        }
        const baseUrl = api2.fetch.getBaseUrl(context, "/oauth/authorize");
        const oauthUrl = `${baseUrl}/oauth/authorize`;
        const params = _extends({
          response_type: "code",
          client_id: context.appId || context.clientId || "INVALID-CLIENT-ID",
          scope: "openid email profile",
          redirect_uri: redirectUrl,
          code_challenge,
          code_challenge_method: "S256",
          nonce
        }, additionalParams);
        if (context.tenantResolver) {
          var _context$tenantResolv;
          const resolvedTenantResult = await ((_context$tenantResolv = context.tenantResolver) == null ? void 0 : _context$tenantResolv.call(context));
          if (resolvedTenantResult != null && resolvedTenantResult.tenant) {
            params["organization"] = resolvedTenantResult.tenant;
          }
        }
        const tenantId = getSearchParam(TENANT_ID_PARAM_KEY);
        if (tenantId) {
          params["tenantId"] = tenantId;
        }
        const searchParams = new URLSearchParams(params);
        const url = `${oauthUrl}?${searchParams.toString()}`;
        onRedirectTo(url, {
          refresh: true
        });
      };
      const refreshOrRequestHostedLoginAuthorize = async (additionalParams) => {
        var _localStorage;
        (_localStorage = localStorage) == null ? void 0 : _localStorage.removeItem(SHOULD_STEP_UP_KEY);
        const disableSilentRefresh = store.auth.disableSilentRefresh;
        if ((additionalParams == null ? void 0 : additionalParams["prompt"]) === "login") {
          return await requestHostedLoginAuthorize(additionalParams);
        }
        try {
          if (disableSilentRefresh) {
            throw new Error("silent refresh is disabled");
          }
          return await __requestHostedLoginSilentAuthorize();
        } catch (e) {
          return await requestHostedLoginAuthorize(additionalParams);
        }
      };
      const refreshOrRequestHostedLoginAuthorizeV2 = async (payload) => {
        var _localStorage2, _additionalParams;
        const {
          shouldRedirectToLogin,
          firstTime,
          loginDirectAction
        } = payload != null ? payload : {};
        let {
          additionalParams
        } = payload != null ? payload : {};
        (_localStorage2 = localStorage) == null ? void 0 : _localStorage2.removeItem(SHOULD_STEP_UP_KEY);
        if (firstTime) {
          const urlStrategy = store.root.urlStrategy;
          const activeUri = getUri(urlStrategy);
          actions.setAuthState({
            isLoading: true
          });
          if (isOauthCallbackRoute(activeUri)) {
            return;
          }
        }
        const disableSilentRefresh = store.auth.disableSilentRefresh;
        if (loginDirectAction) {
          additionalParams = additionalParams || {};
          additionalParams["login_direct_action"] = btoa(JSON.stringify(loginDirectAction));
        }
        if (((_additionalParams = additionalParams) == null ? void 0 : _additionalParams["prompt"]) === "login") {
          return await requestHostedLoginAuthorize(additionalParams);
        }
        try {
          if (disableSilentRefresh) {
            throw new Error("silent refresh is disabled");
          }
          return await __requestHostedLoginSilentAuthorize();
        } catch (e) {
          if (!shouldRedirectToLogin) {
            actions.setAuthState({
              isLoading: false
            });
            return;
          }
          return await requestHostedLoginAuthorize(additionalParams);
        }
      };
      const handleHostedLoginCallback = async (payload) => {
        var _store$auth$customLog2;
        const code_verifier = localStorage.getItem(HOSTED_LOGIN_VERIFIER_KEY) || "INVALID-CODE-VERIFIER";
        const routes = store.auth.routes;
        const urlStrategy = store.root.urlStrategy;
        const basename = getBaseNameWithoutSlashSuffix(store);
        let redirectUrl = `${window.location.origin}${urlStrategy === "path" ? "" : "#"}${basename != null ? basename : ""}${routes.hostedLoginRedirectUrl}`;
        await actions.loadCustomLoginRoutes();
        const customLoginSearchParam = (_store$auth$customLog2 = store.auth.customLoginState) == null ? void 0 : _store$auth$customLog2.customLoginSearchParams;
        if (customLoginSearchParam) {
          if (redirectUrl.endsWith("/")) {
            redirectUrl = redirectUrl.slice(0, -1);
          }
          redirectUrl += customLoginSearchParam;
        }
        const body = {
          code: payload.code,
          redirect_uri: redirectUrl,
          code_verifier,
          grant_type: "authorization_code"
        };
        try {
          const response = await api2.auth.exchangeOAuthTokensV2(body);
          actions.afterAuthenticationStateUpdate(response, {
            isAuthenticated: true,
            isLoading: false
          });
        } catch (e) {
          actions.setAuthState({
            isLoading: false
          });
          console.error("Failed to exchangeOAuthTokens", e);
        } finally {
          const user = store.auth.user;
          const isStepUpFlow = window.localStorage.getItem(SHOULD_STEP_UP_KEY);
          window.localStorage.removeItem(SHOULD_STEP_UP_KEY);
          if (isStepUpFlow && isSteppedUp(user)) {
            await actions.afterStepUpAuthNavigation();
          } else {
            await actions.afterAuthNavigation();
          }
        }
      };
      return {
        requestHostedLoginAuthorize: refreshOrRequestHostedLoginAuthorize,
        requestHostedLoginAuthorizeV2: refreshOrRequestHostedLoginAuthorizeV2,
        __requestHostedLoginAuthorize: requestHostedLoginAuthorize,
        __requestHostedLoginSilentAuthorize,
        handleHostedLoginCallback
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/SSOState/interfaces.js
var SSOStateKeys, SamlVendors;
var init_interfaces38 = __esm({
  "node_modules/@frontegg/redux-store/auth/SSOState/interfaces.js"() {
    (function(SSOStateKeys2) {
      SSOStateKeys2["LOAD_SSO_CONFIGURATIONS"] = "LOAD_SSO_CONFIGURATIONS";
      SSOStateKeys2["SAVE_SSO_CONFIGURATION"] = "SAVE_SSO_CONFIGURATION";
      SSOStateKeys2["UPDATE_SSO_CONFIGURATION"] = "UPDATE_SSO_CONFIGURATION";
      SSOStateKeys2["SAVE_SSO_CONFIGURATION_BY_METADATA"] = "SAVE_SSO_CONFIGURATION_BY_METADATA";
      SSOStateKeys2["UPDATE_SSO_CONFIGURATION_BY_METADATA"] = "UPDATE_SSO_CONFIGURATION";
      SSOStateKeys2["DELETE_SSO_CONFIGURATION"] = "DELETE_SSO_CONFIGURATION";
      SSOStateKeys2["SAVE_SSO_DOMAIN"] = "SAVE_SSO_DOMAIN";
      SSOStateKeys2["DELETE_SSO_DOMAIN"] = "DELETE_SSO_DOMAIN";
      SSOStateKeys2["VALIDATE_SSO_DOMAIN"] = "VALIDATE_SSO_DOMAIN";
      SSOStateKeys2["UPDATE_SSO_DEFAULT_ROLES"] = "UPDATE_SSO_DEFAULT_ROLES";
      SSOStateKeys2["DELETE_SSO_GROUPS"] = "DELETE_SSO_GROUPS";
      SSOStateKeys2["SAVE_SSO_GROUPS"] = "SAVE_SSO_GROUPS";
      SSOStateKeys2["GET_SSO_AUTHORIZATION_ROLES"] = "GET_SSO_AUTHORIZATION_ROLES";
    })(SSOStateKeys || (SSOStateKeys = {}));
    (function(SamlVendors2) {
      SamlVendors2["Saml"] = "saml";
      SamlVendors2["Okta"] = "okta";
      SamlVendors2["Azure"] = "azure";
      SamlVendors2["Google"] = "google";
      SamlVendors2["Oidc"] = "oidc";
    })(SamlVendors || (SamlVendors = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/actions/index.js
var _excluded21, _excluded211, _excluded35, _excluded43, _excluded53, _excluded63, _excluded73, _excluded82, _excluded92, _excluded102, _excluded112, _excluded122, _excluded132, _excluded142, _excluded152, actions_default13;
var init_actions13 = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/actions/index.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_afterAuthNavigation_actions();
    init_handleVerifyMFAResponse_actions();
    init_mfaRequiredState_actions();
    init_mfaWithAuthenticator_actions();
    init_mfaWithEmailCode_actions();
    init_mfaWithSMS_actions();
    init_mfaWithWebAuthn_actions();
    init_interfaces28();
    init_helpers();
    init_state13();
    init_helpers3();
    init_rest_api();
    init_hostedLoginAuthorize_actions();
    init_toolkit();
    init_interfaces30();
    init_consts2();
    init_helpers5();
    init_interfaces31();
    init_interfaces38();
    init_constants3();
    _excluded21 = ["callback", "error"];
    _excluded211 = ["callback"];
    _excluded35 = ["callback"];
    _excluded43 = ["callback"];
    _excluded53 = ["callback"];
    _excluded63 = ["callback", "events"];
    _excluded73 = ["callback"];
    _excluded82 = ["callback"];
    _excluded92 = ["user"];
    _excluded102 = ["callback"];
    _excluded112 = ["callback"];
    _excluded122 = ["callback"];
    _excluded132 = ["callback"];
    _excluded142 = ["callback"];
    _excluded152 = ["callback"];
    actions_default13 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const contextHolder = ContextHolder.for(store.root.appName);
      const __refreshTokenHosted = async () => {
        const user = store.auth.user;
        if (!(user != null && user.refreshToken)) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          actions.setAuthState({
            user: null,
            isAuthenticated: false
          });
          return;
        }
        try {
          const body = {
            grant_type: "refresh_token",
            refresh_token: user == null ? void 0 : user.refreshToken
          };
          const response = await api2.auth.exchangeOAuthTokensV2(body);
          const updatedUser = await __handleUnnecessaryEntitlementsUpdate(response.user);
          actions.afterAuthenticationStateUpdate(_extends({}, response, {
            user: updatedUser
          }), {
            isAuthenticated: true
          });
        } catch (e) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          actions.setAuthState({
            user: null,
            isAuthenticated: false
          });
        }
      };
      const __shouldNavigateToRegisterQuickLogin = (user) => {
        var _ref;
        const {
          routes,
          loginState
        } = store.auth;
        const quickLoginToRegister = (_ref = localStorage.getItem("register-quick-login")) != null ? _ref : loginState.quickLoginToRegister;
        return quickLoginToRegister && localStorage.getItem(`${user.id}-${quickLoginToRegister}`) !== "true" && !window.location.pathname.endsWith(routes.logoutUrl);
      };
      const __refreshTokenEmbedded = async () => {
        try {
          const {
            routes,
            loginState,
            onRedirectTo
          } = store.auth;
          const {
            user,
            tenants = [],
            activeTenant
          } = await api2.auth.refreshTokenV3();
          if (isMfaRequired(user, store.root.appName)) {
            const mfaRequiredState = await actions.getMfaRequiredState(user);
            actions.setAuthState(mfaRequiredState);
            onRedirectTo(routes.loginUrl, {
              preserveQueryParams: true
            });
          } else {
            var _ref2;
            if (user.id) {
              localStorage.setItem("userId", user.id);
            }
            const quickLoginToRegister = (_ref2 = localStorage.getItem("register-quick-login")) != null ? _ref2 : loginState.quickLoginToRegister;
            const shouldNavigateToRegisterQuickLogin = __shouldNavigateToRegisterQuickLogin(user);
            const updatedUser = await __handleUnnecessaryEntitlementsUpdate(user);
            actions.afterAuthenticationStateUpdate({
              user: updatedUser,
              tenants,
              activeTenant
            }, {
              loginState: _extends({}, loginState, {
                quickLoginToRegister,
                flow: shouldNavigateToRegisterQuickLogin ? LoginFlow.RegisterQuickLogin : LoginFlow.Login
              }),
              isAuthenticated: true
            });
            await __handleRedirectRefreshToken(shouldNavigateToRegisterQuickLogin);
          }
        } catch (e) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          actions.setAuthState({
            user: void 0,
            isAuthenticated: false
          });
        }
      };
      const __refreshToken = async () => {
        const hostedLoginBox = store.auth.hostedLoginBox;
        if (hostedLoginBox) {
          await __refreshTokenHosted();
        } else {
          await __refreshTokenEmbedded();
        }
      };
      const __handleUnnecessaryEntitlementsUpdate = async (updatedUser) => {
        var _store$auth$user;
        const oldEntitlements = (_store$auth$user = store.auth.user) == null ? void 0 : _store$auth$user.entitlements;
        if (isEntitlementsDeeplyEqual(oldEntitlements, updatedUser == null ? void 0 : updatedUser.entitlements)) {
          return _extends({}, updatedUser, {
            entitlements: oldEntitlements
          });
        }
        return updatedUser;
      };
      const __handleRedirectRefreshToken = async (shouldNavigateToRegisterQuickLogin) => {
        var _window;
        const url = new URL((_window = window) == null ? void 0 : _window.location.href);
        const {
          routes,
          loginState,
          onRedirectTo
        } = store.auth;
        const invitationToken = url.searchParams.get("invitationToken");
        const redirectRoutes = [routes.socialLoginCallbackUrl, routes.oidcRedirectUrl, routes.samlCallbackUrl, routes.magicLinkCallbackUrl];
        if (!invitationToken) {
          redirectRoutes.push(routes.loginUrl, routes.signUpUrl);
        }
        if (shouldNavigateToRegisterQuickLogin) {
          onRedirectTo(routes.loginUrl);
        } else if (redirectRoutes.some((url2) => url2 && window.location.pathname.endsWith(url2))) {
          if (loginState.isNewUser && routes.signUpSuccessUrl && routes.socialLoginCallbackUrl === window.location.pathname) {
            onRedirectTo(routes.signUpSuccessUrl, {
              refresh: routes.signUpSuccessUrl.startsWith("http")
            });
          } else {
            await actions.afterAuthNavigation();
          }
        }
      };
      const __loadSSOPublicConfigurationFunction = async (payload) => {
        try {
          var _payload$callback;
          const {
            isActive
          } = await retryIfNeeded2(api2.auth.getSSOPublicConfiguration, payload == null ? void 0 : payload.retryConfig);
          actions.setAuthState({
            isSSOAuth: isActive
          });
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, {
            isSSOAuth: isActive
          });
        } catch (e) {
          var _payload$callback2;
          actions.setAuthState({
            isSSOAuth: false
          });
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
        }
      };
      const __refreshMetadata = async (payload) => {
        let ssoACS;
        try {
          var _metadata$configurati;
          const metadata = await retryIfNeeded2(api2.metadata.getSamlMetadata, payload == null ? void 0 : payload.retryConfig);
          ssoACS = metadata == null ? void 0 : (_metadata$configurati = metadata.configuration) == null ? void 0 : _metadata$configurati.acsUrl;
        } catch (e) {
          console.error(e);
        }
        actions.setAuthState({
          ssoACS
        });
      };
      const __isMFARequiredSSR = async ({
        accessToken,
        user
      }) => {
        if (!accessToken) {
          actions.setAuthState({
            user: void 0,
            isAuthenticated: false
          });
          return;
        }
        const {
          onRedirectTo,
          routes
        } = store.auth;
        if (isMfaRequired(user, store.root.appName)) {
          const mfaRequiredState = await actions.getMfaRequiredState(user, DEFAULT_RETRY_CONFIG, true);
          actions.setAuthState(mfaRequiredState);
          onRedirectTo(routes.loginUrl, {
            preserveQueryParams: true
          });
        }
      };
      const setLoginState = (state) => {
        Object.assign(store.auth.loginState, state);
      };
      const resetLoginState = () => {
        deepResetState(store, ["auth", "loginState"], initialState13);
      };
      const getRetryWithBlockingCallbackPayload = (requestName) => {
        const callback = (_, error) => {
          if (!error || error.statusCode < 500) return;
          actions.setErrorByRequestName({
            requestName,
            traceId: errorTraceId(error)
          });
        };
        return withRetryConfig({
          callback
        });
      };
      const requestAuthorize = async (firstTime) => {
        const calls = [];
        const callsAfterRefresh = [];
        calls.push(__refreshToken());
        if (firstTime) {
          actions.setAuthState({
            isLoading: true
          });
          calls.push(actions.loadSocialLoginsConfigurationV2(withRetryConfig()));
          calls.push(actions.loadAllowSignUps(getRetryWithBlockingCallbackPayload(REQUEST_NAME.LOAD_ALLOW_SIGNUPS)));
          calls.push(actions.loadPublicAuthStrategiesPolicy(getRetryWithBlockingCallbackPayload(REQUEST_NAME.LOAD_PUBLIC_AUTH_STRATEGIES_POLICY)));
          calls.push(actions.loadSignUpStrategies());
          calls.push(__loadSSOPublicConfigurationFunction(getRetryWithBlockingCallbackPayload(REQUEST_NAME.LOAD_SSO_PUBLIC_CONFIGURATION)));
          calls.push(actions.loadVendorPublicInfo(withRetryConfig()));
          calls.push(__refreshMetadata(withRetryConfig()));
          callsAfterRefresh.push(actions.loadCustomLoginRoutes(getRetryWithBlockingCallbackPayload(REQUEST_NAME.LOAD_CUSTOM_LOGIN_ROUTES)));
        }
        await Promise.all(calls);
        if (callsAfterRefresh.length > 0) {
          await Promise.all(callsAfterRefresh);
        }
        actions.setAuthState({
          isLoading: false
        });
      };
      const requestAuthorizeSSR = async (payload) => {
        const calls = [];
        calls.push(actions.loadSocialLoginsConfigurationV2(withRetryConfig()));
        calls.push(actions.loadAllowSignUps(getRetryWithBlockingCallbackPayload(REQUEST_NAME.LOAD_ALLOW_SIGNUPS)));
        calls.push(__loadSSOPublicConfigurationFunction(getRetryWithBlockingCallbackPayload(REQUEST_NAME.LOAD_SSO_PUBLIC_CONFIGURATION)));
        calls.push(actions.loadSignUpStrategies());
        calls.push(actions.loadVendorPublicInfo(withRetryConfig()));
        calls.push(__refreshMetadata());
        calls.push(__isMFARequiredSSR(payload));
        calls.push(actions.loadCustomLoginRoutes(getRetryWithBlockingCallbackPayload(REQUEST_NAME.LOAD_CUSTOM_LOGIN_ROUTES)));
        await Promise.all(calls);
      };
      const ssoPreloginFailed = async (_ref3) => {
        let {
          callback,
          error
        } = _ref3, body = _objectWithoutPropertiesLoose(_ref3, _excluded21);
        const publicPolicy = store.auth.securityPolicyState.publicPolicy.policy;
        if (!(publicPolicy != null && publicPolicy.authStrategy)) {
          actions.setLoginState({
            step: LoginStep.loginWithPassword,
            loading: false
          });
          callback == null ? void 0 : callback();
          return;
        }
        if ((publicPolicy == null ? void 0 : publicPolicy.authStrategy) === AuthStrategyEnum.EmailAndPassword) {
          actions.setLoginState({
            step: LoginStep.loginWithPassword,
            loading: false
          });
          callback == null ? void 0 : callback();
        } else if ([AuthStrategyEnum.MagicLink, AuthStrategyEnum.Code, AuthStrategyEnum.SmsCode].includes(publicPolicy == null ? void 0 : publicPolicy.authStrategy)) {
          await actions.passwordlessPreLogin(_extends({}, body, {
            type: publicPolicy == null ? void 0 : publicPolicy.authStrategy,
            callback
          }));
        } else {
          actions.setLoginState({
            step: LoginStep.loginWithPassword,
            loading: false,
            error: errorHandler(error)
          });
          callback == null ? void 0 : callback();
        }
      };
      const preLogin = async (payload) => {
        const {
          email,
          recaptchaToken,
          invitationToken,
          callback
        } = payload;
        setLoginState({
          loading: true
        });
        try {
          const onRedirectTo = store.auth.onRedirectTo;
          const tenantId = getSearchParam(TENANT_ID_PARAM_KEY);
          const preLoginResult = await api2.auth.preLoginV2({
            email,
            tenantId
          });
          const {
            address,
            idpType
          } = preLoginResult != null ? preLoginResult : {};
          if (address) {
            let ssoRedirectUrl = address;
            if (idpType === SamlVendors.Oidc && !ssoRedirectUrl.includes("redirect_uri")) {
              const {
                oidcRedirectUrl
              } = store.auth.routes;
              ssoRedirectUrl += `&redirect_uri=${window.location.origin}${oidcRedirectUrl}`;
            }
            if (FronteggNativeModule_default.isLoginWithSSOAvailable()) {
              FronteggNativeModule_default.loginWithSSO(email);
              setLoginState({
                loading: false
              });
              callback == null ? void 0 : callback();
            } else {
              setLoginState({
                step: LoginStep.redirectToSSO,
                loading: false,
                ssoRedirectUrl
              });
              setTimeout(() => {
                onRedirectTo(ssoRedirectUrl, {
                  refresh: true
                });
              }, 2e3);
            }
          } else {
            await ssoPreloginFailed({
              email,
              recaptchaToken,
              callback,
              invitationToken
            });
          }
        } catch (e) {
          await ssoPreloginFailed({
            email,
            recaptchaToken,
            callback,
            invitationToken,
            error: e
          });
        }
      };
      const postLogin = async (payload) => {
        const {
          onRedirectTo,
          routes
        } = store.auth;
        setLoginState({
          loading: true
        });
        try {
          const user = await api2.auth.postLogin(payload);
          actions.setAuthState({
            user: user.accessToken ? user : void 0,
            isAuthenticated: !!user.accessToken
          });
          await actions.afterAuthNavigation();
        } catch (e) {
          setTimeout(() => {
            onRedirectTo(routes.authenticatedUrl);
          }, 1e3);
          setLoginState({
            step: LoginStep.loginWithSSOFailed,
            loading: false
          });
        }
      };
      const login = async (payload) => {
        const {
          email,
          password,
          recaptchaToken,
          invitationToken,
          callback
        } = payload;
        setLoginState({
          loading: true
        });
        try {
          const {
            user,
            tenants = [],
            activeTenant
          } = await api2.auth.loginv2({
            email,
            password,
            recaptchaToken,
            invitationToken
          });
          const {
            onRedirectTo,
            routes
          } = store.auth;
          if (isMfaRequired(user, store.root.appName)) {
            const mfaRequiredState = await actions.getMfaRequiredState(user, DEFAULT_RETRY_CONFIG, true, email);
            actions.setAuthState(mfaRequiredState);
            onRedirectTo(routes.loginUrl, {
              preserveQueryParams: true
            });
          } else {
            const [securityCenterLoginFlows, passwordRotationFlagEnabled] = await actions.getFeatureFlags(["security-center-show-login-flows", "password-rotation"]);
            if (passwordRotationFlagEnabled && isResetPasswordRequired(user, store.root.appName)) {
              setLoginState({
                step: LoginStep.passwordRotationExpired,
                loading: false,
                resetPasswordToken: user.resetPasswordToken,
                userId: user.userId
              });
            } else {
              const loginState = store.auth.loginState;
              const isAuthenticated = !!user.accessToken;
              if (user.id) {
                localStorage.setItem("userId", user.id);
              }
              actions.afterAuthenticationStateUpdate({
                user,
                tenants,
                activeTenant
              }, {
                loginState: {
                  flow: loginState.flow,
                  quickLoginToRegister: loginState.quickLoginToRegister,
                  email,
                  loading: false,
                  error: void 0,
                  mfaToken: user.mfaToken,
                  step: loginState.flow === LoginFlow.Login ? LoginStep.success : loginState.step,
                  tenants,
                  tenantsLoading: true,
                  isBreachedPassword: user.isBreachedPassword
                },
                isAuthenticated
              });
              if (loginState.flow === LoginFlow.Login) {
                if (securityCenterLoginFlows && user.isBreachedPassword && !isAuthenticated) {
                  setLoginState({
                    step: LoginStep.breachedPassword,
                    loading: false
                  });
                } else {
                  if (isAuthenticated) {
                    const shouldShowPasswordRotationPrompt = shouldShowPasswordRotationPromptFunc(user);
                    if (passwordRotationFlagEnabled && shouldShowPasswordRotationPrompt) {
                      setLoginState({
                        step: LoginStep.passwordRotationNotification,
                        loading: false
                      });
                    } else {
                      const shouldShowPromptPasskeys = await actions.__shouldShowPromptPasskeys();
                      if (shouldShowPromptPasskeys) {
                        setLoginState({
                          step: LoginStep.promptPasskeys,
                          loading: false
                        });
                        onRedirectTo(routes.loginUrl, {
                          preserveQueryParams: true
                        });
                      } else {
                        await actions.afterAuthNavigation();
                      }
                    }
                  }
                }
              }
            }
          }
          if (FronteggNativeModule_default.isSuggestSavePasswordAvailable()) {
            FronteggNativeModule_default.suggestSavePassword(email, password);
          }
          localStorage.removeItem("register-quick-login");
          callback == null ? void 0 : callback(true);
        } catch (e) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          callback == null ? void 0 : callback(false, e);
          setLoginState({
            email,
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const logout = async (payload) => {
        const hostedLoginBox = store.auth.hostedLoginBox;
        actions.setAuthState({
          isLoading: true
        });
        try {
          if (hostedLoginBox) {
            await api2.auth.OAuthLogout();
          } else {
            await api2.auth.logout();
          }
        } catch {
        }
        if (contextHolder.isSessionPerTenantEnabled()) {
          removeTabTenantFromSessionStorage();
        }
        actions.resetAuthState();
        await actions.requestAuthorize(true);
        payload == null ? void 0 : payload();
      };
      const silentLogout = async (payload) => {
        var _payload$callbackTime;
        try {
          await api2.auth.logout();
        } catch {
        }
        if (contextHolder.isSessionPerTenantEnabled()) {
          removeTabTenantFromSessionStorage();
        }
        setTimeout(() => {
          var _payload$callback3;
          return payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
        }, (_payload$callbackTime = payload == null ? void 0 : payload.callbackTimeout) != null ? _payload$callbackTime : 500);
      };
      const recoverMfa = async (payload) => {
        setLoginState({
          loading: true
        });
        try {
          var _payload$callback4;
          await api2.auth.recoverMfaToken(payload);
          setLoginState({
            loading: false,
            error: void 0,
            step: LoginStep.preLogin
          });
          actions.setAuthState({
            user: void 0,
            isAuthenticated: false
          });
          (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, true);
        } catch (e) {
          var _payload$callback5;
          setLoginState({
            error: errorHandler(e),
            loading: false
          });
          (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, false, e);
        }
      };
      const quickSmsPasswordlessPreLogin = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded211);
        try {
          setLoginState({
            loading: true
          });
          const preloginRes = await api2.auth.passwordlessPreLogin(_extends({}, payload, {
            type: AuthStrategyEnum.SmsCode
          }));
          setLoginState({
            step: LoginStep.loginWithQuickSmsOtc,
            loading: false,
            phoneNumber: preloginRes == null ? void 0 : preloginRes.phoneNumber,
            error: void 0
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoginState({
            error: errorHandler(e),
            loading: false
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      const changePhoneNumberWithVerification = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded35);
        try {
          setLoginState({
            loading: true
          });
          const changePhoneRes = await api2.auth.changePhoneNumberWithVerification(payload);
          setLoginState({
            phoneNumber: payload.phoneNumber,
            loading: false,
            changePhoneId: changePhoneRes.changePhoneId,
            step: LoginStep.loginWithQuickSmsOtc,
            error: void 0
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoginState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const verifyChangePhoneNumber = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded43);
        try {
          setLoginState({
            loading: true
          });
          await api2.auth.verifyChangePhoneNumber(payload);
          setLoginState({
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoginState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const passwordlessPreLogin = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded53);
        try {
          setLoginState({
            loading: true
          });
          let email;
          if (isEmailPayload(payload)) {
            email = payload.email;
          }
          const preloginRes = await api2.auth.passwordlessPreLogin(payload);
          const step = authStrategyLoginStepMap[payload.type];
          setLoginState({
            step,
            loading: false,
            phoneNumber: preloginRes == null ? void 0 : preloginRes.phoneNumber,
            email,
            error: void 0
          });
          callback == null ? void 0 : callback();
        } catch (e) {
          setLoginState({
            error: errorHandler(e),
            loading: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const passwordlessPostLogin = async (_payload) => {
        const {
          callback,
          events
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded63);
        try {
          setLoginState({
            loading: true
          });
          const {
            user,
            tenants = [],
            activeTenant
          } = await api2.auth.passwordlessPostLoginV2(payload);
          const {
            routes,
            onRedirectTo
          } = store.auth;
          if (isMfaRequired(user, store.root.appName)) {
            const mfaRequiredState = await actions.getMfaRequiredState(user);
            actions.setAuthState(mfaRequiredState);
            onRedirectTo(routes.loginUrl, {
              preserveQueryParams: true
            });
          } else {
            const loginState = store.auth.loginState;
            if (user.emailVerified) {
              var _events$userVerified;
              const userVerifiedPayload = {
                email: user.email,
                origin: UserVerifiedOriginTypes.PASSWORDLESS,
                id: user.id,
                tenantId: user.tenantId,
                createdAt: /* @__PURE__ */ new Date(),
                name: user.name
              };
              events == null ? void 0 : (_events$userVerified = events.userVerified) == null ? void 0 : _events$userVerified.call(events, userVerifiedPayload);
              reportGTMEvent(GTMEventAction.USER_VERIFIED, userVerifiedPayload);
            }
            if (user.id) {
              localStorage.setItem("userId", user.id);
            }
            actions.afterAuthenticationStateUpdate({
              user,
              tenants,
              activeTenant
            });
            setLoginState({
              error: void 0
            });
            actions.setAuthState({
              isLoading: false
            });
            if (loginState.flow === LoginFlow.Login) {
              const shouldShowPrompt = await actions.__shouldShowPromptPasskeys();
              if (shouldShowPrompt) {
                actions.setLoginState({
                  step: LoginStep.promptPasskeys,
                  loading: false
                });
                onRedirectTo(routes.loginUrl, {
                  preserveQueryParams: true
                });
              } else {
                actions.setAuthState({
                  isAuthenticated: true
                });
                if (_payload.type === AuthStrategyEnum.MagicLink) {
                  actions.setLoginState({
                    step: LoginStep.magicLinkPostLoginSuccess,
                    loading: false
                  });
                  await delay(5e3);
                }
                await actions.afterAuthNavigation();
              }
            } else {
              onRedirectTo(routes.loginUrl, {
                preserveQueryParams: true
              });
            }
            localStorage.removeItem("register-quick-login");
            callback == null ? void 0 : callback(true);
          }
        } catch (e) {
          setLoginState({
            error: errorHandler(e, "Failed to authenticate")
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          setLoginState({
            loading: false
          });
        }
      };
      const verifyInviteToken = async (payload) => {
        try {
          setLoginState({
            loading: true
          });
          const {
            name: inviteTokenTenantName
          } = await api2.auth.verifyInviteToken(payload);
          setLoginState({
            inviteTokenTenantName
          });
        } catch (e) {
          setLoginState({
            inviteTokenError: errorHandler(e, `We couldn't verify your invitation`)
          });
        } finally {
          setLoginState({
            loading: false
          });
        }
      };
      const webAuthnPrelogin = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded73);
        try {
          var _options$allowCredent;
          actions.setPasskeysState({
            loading: true
          });
          setLoginState({
            loading: true
          });
          const {
            options
          } = await api2.auth.webAuthnPreLogin(body);
          options.challenge = base64urlDecode(options.challenge);
          options.allowCredentials = (_options$allowCredent = options.allowCredentials) == null ? void 0 : _options$allowCredent.map((credentials) => _extends({}, credentials, {
            id: base64urlDecode(credentials.id)
          }));
          setLoginState({
            error: void 0
          });
          callback == null ? void 0 : callback(options);
        } catch (e) {
          setLoginState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        } finally {
          actions.setPasskeysState({
            loading: false
          });
          setLoginState({
            loading: false
          });
        }
      };
      const webAuthnPostLogin = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded82);
        try {
          var _publicKey$response$u;
          actions.setPasskeysState({
            loading: true
          });
          setLoginState({
            loading: true
          });
          const publicKey = publicKeyCredentialToJSON(body.publicKey);
          const _await$api$auth$webAu = await api2.auth.webAuthnPostLoginV2(_extends({}, publicKey, {
            response: _extends({}, publicKey.response, {
              userHandle: (_publicKey$response$u = publicKey.response.userHandle) != null ? _publicKey$response$u : void 0
            }),
            recaptchaToken: body.recaptchaToken,
            invitationToken: body.invitationToken
          })), {
            user
          } = _await$api$auth$webAu, rest = _objectWithoutPropertiesLoose(_await$api$auth$webAu, _excluded92);
          if (isMfaRequired(user, store.root.appName)) {
            const {
              routes,
              onRedirectTo
            } = store.auth;
            const mfaRequiredState = await actions.getMfaRequiredState(user);
            actions.setAuthState(mfaRequiredState);
            onRedirectTo(routes.loginUrl, {
              preserveQueryParams: true
            });
          } else {
            if (user.id) {
              localStorage.setItem("userId", user.id);
            }
            actions.afterAuthenticationStateUpdate(_extends({
              user
            }, rest), {
              isAuthenticated: true
            });
            setLoginState({
              error: void 0
            });
            await actions.afterAuthNavigation();
            callback == null ? void 0 : callback(true);
          }
        } catch (e) {
          setLoginState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        } finally {
          actions.setPasskeysState({
            loading: false
          });
          setLoginState({
            loading: false
          });
        }
      };
      const webAuthnCreateNewDeviceSession = async (payload) => {
        const {
          callback
        } = payload;
        try {
          setLoginState({
            loading: true
          });
          const {
            options
          } = await api2.auth.webAuthnCreateNewDeviceSession();
          options.user.id = base64urlDecode(options.user.id);
          options.challenge = base64urlDecode(options.challenge);
          options.excludeCredentials = [];
          callback == null ? void 0 : callback(options);
        } catch (e) {
          setLoginState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        } finally {
          setLoginState({
            loading: false
          });
        }
      };
      const webAuthnVerifyNewDeviceSession = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded102);
        try {
          setLoginState({
            loading: true
          });
          const publicKey = publicKeyCredentialToJSON(body.publicKey);
          const deviceType = (publicKey == null ? void 0 : publicKey.authenticatorAttachment) === "platform" ? WebAuthnDeviceType.Platform : WebAuthnDeviceType.CrossPlatform;
          await api2.auth.verifyNewDeviceSession({
            id: publicKey.id,
            response: publicKey.response,
            deviceType
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoginState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        } finally {
          setLoginState({
            loading: false
          });
        }
      };
      const getUserIP = async (payload) => {
        const {
          callback
        } = payload;
        try {
          actions.setAuthState({
            userIpData: {
              loading: true
            }
          });
          const {
            ip,
            country_code
          } = await api2.metadata.getCurrentUserIpMetadata();
          actions.setAuthState({
            userIpData: {
              ip,
              countryCode: country_code,
              loading: false
            }
          });
          actions.setAuthState({
            userIp: ip
          });
          callback == null ? void 0 : callback({
            ip,
            countryCode: country_code
          });
        } catch (e) {
          actions.setAuthState({
            userIpData: {
              loading: false
            }
          });
          callback == null ? void 0 : callback(false);
        }
      };
      const preEnrollMFAWebAuthnForLogin = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded112);
        setLoginState({
          loading: true
        });
        try {
          var _data$options$exclude;
          const data = await api2.auth.preEnrollMFAWebAuthnForLogin(payload);
          const options = _extends({}, data.options, {
            challenge: base64urlDecode(data.options.challenge),
            user: _extends({}, data.options.user, {
              id: base64urlDecode(data.options.user.id)
            }),
            excludeCredentials: (_data$options$exclude = data.options.excludeCredentials) == null ? void 0 : _data$options$exclude.map((credentials) => _extends({}, credentials, {
              id: base64urlDecode(credentials.id)
            }))
          });
          setLoginState({
            loading: false
          });
          callback == null ? void 0 : callback({
            options,
            webauthnToken: data.webauthnToken
          });
        } catch (e) {
          setLoginState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const enrollMFAWebAuthnForLogin = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded122);
        setLoginState({
          loading: true
        });
        try {
          const publicKey = publicKeyCredentialToJSON(payload.publicKey);
          const data = await api2.auth.enrollMFAWebAuthnForLoginV2(_extends({}, payload, {
            options: publicKey
          }));
          await handleEnrollMFAResponse(data);
          setLoginState({
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoginState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const enrollMFAAuthenticatorAppForLogin = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded132);
        setLoginState({
          loading: true
        });
        try {
          const data = await api2.auth.enrollMFAAuthenticatorAppForLoginV2(payload);
          await handleEnrollMFAResponse(data);
          setLoginState({
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoginState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const preEnrollMFASMSForLogin = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded142);
        setLoginState({
          loading: true
        });
        try {
          const data = await api2.auth.preEnrollMFASMSForLogin(payload);
          actions.setMfaState({
            otcToken: data.otcToken,
            step: MFAStep.smsVerifyCode,
            phoneNumber: data.phoneNumber
          });
          setLoginState({
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoginState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const enrollMFASMSForLogin = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded152);
        setLoginState({
          loading: true
        });
        try {
          const data = await api2.auth.enrollMFASMSForLoginV2(payload);
          await handleEnrollMFAResponse(data);
          setLoginState({
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setLoginState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null);
        }
      };
      const handleEnrollMFAResponse = async (payload) => {
        const {
          user,
          tenants = [],
          activeTenant
        } = payload;
        const mfaState = {
          step: MFAStep.recoveryCode,
          loading: false,
          error: void 0,
          saving: false
        };
        if (user != null && user.recoveryCode) {
          mfaState.recoveryCode = user.recoveryCode;
        }
        actions.setMfaState(mfaState);
        actions.setUser(user);
        actions.setTenantsState({
          tenants,
          activeTenant,
          loading: false
        });
        if (user.id) {
          localStorage.setItem("userId", user.id);
        }
      };
      const resetBreachedPassword = async (payload) => {
        setLoginState({
          loading: true
        });
        try {
          await api2.auth.forgotPassword(payload);
          setLoginState({
            loading: false,
            error: void 0,
            step: LoginStep.breachedPasswordSuccess
          });
          actions.setAuthState({
            isAuthenticated: false
          });
        } catch (e) {
          setLoginState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const __refreshTokenHostedSocialLogins = async () => {
        const {
          user: currentUser
        } = store.auth;
        if (!(currentUser != null && currentUser.refreshToken)) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          actions.setAuthState({
            user: null,
            isAuthenticated: false
          });
          return;
        }
        try {
          const body = {
            grant_type: "refresh_token",
            refresh_token: currentUser == null ? void 0 : currentUser.refreshToken
          };
          const response = await api2.auth.exchangeOAuthTokensV2(body);
          const updatedUser = await __handleUnnecessaryEntitlementsUpdate(response.user);
          actions.afterAuthenticationStateUpdate(_extends({}, response, {
            user: updatedUser
          }), {
            isAuthenticated: true
          });
        } catch (e) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          actions.setAuthState({
            user: null,
            isAuthenticated: false
          });
        }
      };
      const __refreshTokenEmbeddedSocialLogins = async () => {
        try {
          const {
            routes,
            loginState,
            onRedirectTo
          } = store.auth;
          const {
            user,
            tenants = [],
            activeTenant
          } = await api2.auth.refreshTokenV3();
          if (isMfaRequired(user, store.root.appName)) {
            const mfaRequiredState = await actions.getMfaRequiredState(user);
            actions.setAuthState(mfaRequiredState);
            onRedirectTo(routes.loginUrl, {
              preserveQueryParams: true
            });
          } else {
            const updatedUser = await __handleUnnecessaryEntitlementsUpdate(user);
            const shouldShowPrompt = await actions.__shouldShowPromptPasskeys();
            if (shouldShowPrompt) {
              actions.setLoginState({
                step: LoginStep.promptPasskeys,
                loading: false
              });
              actions.afterAuthenticationStateUpdate({
                user: updatedUser,
                tenants,
                activeTenant
              }, {
                isLoading: false
              });
              onRedirectTo(routes.loginUrl, {
                preserveQueryParams: true
              });
            } else {
              var _ref4;
              if (user.id) {
                localStorage.setItem("userId", user.id);
              }
              const quickLoginToRegister = (_ref4 = localStorage.getItem("register-quick-login")) != null ? _ref4 : loginState.quickLoginToRegister;
              const shouldNavigateToRegisterQuickLogin = __shouldNavigateToRegisterQuickLogin(user);
              actions.afterAuthenticationStateUpdate({
                user: updatedUser,
                tenants,
                activeTenant
              }, {
                loginState: _extends({}, loginState, {
                  quickLoginToRegister,
                  flow: shouldNavigateToRegisterQuickLogin ? LoginFlow.RegisterQuickLogin : LoginFlow.Login
                }),
                isAuthenticated: true
              });
              await __handleRedirectRefreshToken(shouldNavigateToRegisterQuickLogin);
            }
          }
        } catch (e) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          actions.setAuthState({
            user: void 0,
            isAuthenticated: false
          });
        }
      };
      const refreshTokenForSocialLogins = async () => {
        if (store.auth.hostedLoginBox) {
          await __refreshTokenHostedSocialLogins();
        } else {
          await __refreshTokenEmbeddedSocialLogins();
        }
      };
      return _extends({
        setLoginState,
        resetLoginState,
        requestAuthorize,
        requestAuthorizeSSR,
        preLogin,
        postLogin,
        login,
        logout,
        silentLogout,
        recoverMfa,
        quickSmsPasswordlessPreLogin,
        changePhoneNumberWithVerification,
        verifyChangePhoneNumber,
        passwordlessPreLogin,
        passwordlessPostLogin,
        verifyInviteToken,
        webAuthnPrelogin,
        webAuthnPostLogin,
        webAuthnCreateNewDeviceSession,
        webAuthnVerifyNewDeviceSession,
        getUserIP,
        preEnrollMFAWebAuthnForLogin,
        enrollMFAWebAuthnForLogin,
        enrollMFAAuthenticatorAppForLogin,
        preEnrollMFASMSForLogin,
        enrollMFASMSForLogin,
        handleEnrollMFAResponse,
        resetBreachedPassword,
        refreshTokenForSocialLogins,
        // protected
        __refreshToken
      }, hostedLoginAuthorize_actions_default(store, api2, sharedActions), afterAuthNavigation_actions_default(store, api2, sharedActions), handleVerifyMFAResponse_actions_default(store, api2, sharedActions), mfaRequiredState_actions_default(store, api2, sharedActions), mfaWithAuthenticator_actions_default(store, api2, sharedActions), mfaWithEmailCode_actions_default(store, api2, sharedActions), mfaWithSMS_actions_default(store, api2, sharedActions), mfaWithWebAuthn_actions_default(store, api2, sharedActions));
    };
  }
});

// node_modules/@frontegg/redux-store/auth/LoginState/index.js
var init_LoginState = __esm({
  "node_modules/@frontegg/redux-store/auth/LoginState/index.js"() {
    init_state13();
    init_actions13();
  }
});

// node_modules/@frontegg/redux-store/auth/MfaState/state.js
var initialState14, state_default14;
var init_state14 = __esm({
  "node_modules/@frontegg/redux-store/auth/MfaState/state.js"() {
    init_interfaces31();
    init_proxy();
    initialState14 = {
      step: MFAStep.verify,
      loading: false,
      saving: false
    };
    state_default14 = (overrideState) => createProxy2(initialState14, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/MfaState/actions.js
var _excluded30, _excluded212, _excluded36, _excluded44, _excluded54, _excluded64, _excluded74, _excluded83, actions_default14;
var init_actions14 = __esm({
  "node_modules/@frontegg/redux-store/auth/MfaState/actions.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_interfaces31();
    init_helpers();
    init_state14();
    _excluded30 = ["callback"];
    _excluded212 = ["callback"];
    _excluded36 = ["user"];
    _excluded44 = ["deviceId"];
    _excluded54 = ["deviceId"];
    _excluded64 = ["callback"];
    _excluded74 = ["callback"];
    _excluded83 = ["deviceId", "callback"];
    actions_default14 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      async function __getMfaStateAfterEnroll(res) {
        const step = store.auth.mfaState.step;
        const mfaState = {
          step: res.recoveryCode ? MFAStep.recoveryCode : step,
          loading: false,
          saving: false,
          error: void 0,
          recoveryCode: res == null ? void 0 : res.recoveryCode
        };
        return mfaState;
      }
      const setMfaState = (state) => {
        Object.assign(store.auth.mfaState, state);
      };
      const resetMfaState = () => {
        deepResetState(store, ["auth", "mfaState"], initialState14);
      };
      const getMFADevices = async () => {
        setMfaState({
          loading: true
        });
        try {
          const mfaDevices = await api2.auth.getMFADevices();
          setMfaState({
            loading: false,
            error: void 0,
            mfaDevices
          });
        } catch (e) {
          setMfaState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const getMFAStrategies = async (payload) => {
        setMfaState({
          loading: true
        });
        try {
          const res = await retryIfNeeded2(() => api2.auth.getMFAStrategiesConfig(), payload == null ? void 0 : payload.retryConfig);
          const mfaStrategies = res.strategies.filter(({
            isActive
          }) => isActive).map(({
            strategy
          }) => strategy);
          setMfaState({
            loading: false,
            error: void 0,
            mfaStrategies
          });
        } catch (e) {
          setMfaState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const enrollMfa = async () => {
        setMfaState({
          saving: true
        });
        try {
          const {
            qrCode
          } = await api2.auth.enrollMfa();
          setMfaState({
            saving: false,
            error: void 0,
            qrCode
          });
        } catch (e) {
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
        }
      };
      const verifyMfa = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded30);
        setMfaState({
          saving: true
        });
        try {
          const user = store.auth.user;
          const data = await api2.auth.verifyMfa(payload);
          const mfaDevices = await api2.auth.getMFADevices();
          const mfaState = await __getMfaStateAfterEnroll(data);
          setMfaState(_extends({}, mfaState, {
            mfaDevices
          }));
          actions.setUser(_extends({}, user, {
            mfaEnrolled: true
          }));
          callback == null ? void 0 : callback(mfaState.recoveryCode);
        } catch (e) {
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const verifyMfaAfterForce = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded212);
        setMfaState({
          loading: true
        });
        try {
          const _await$api$auth$login = await api2.auth.loginWithMfaV2(payload), {
            user
          } = _await$api$auth$login, rest = _objectWithoutPropertiesLoose(_await$api$auth$login, _excluded36);
          const mfaState = {
            step: MFAStep.recoveryCode,
            loading: false,
            saving: false,
            error: void 0
          };
          if (user != null && user.recoveryCode) {
            mfaState.recoveryCode = user.recoveryCode;
          }
          setMfaState(mfaState);
          await actions.afterAuthenticationStateUpdate(_extends({
            user
          }, rest));
          callback == null ? void 0 : callback(mfaState.recoveryCode);
        } catch (e) {
          setMfaState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const disableMfa = async (payload) => {
        setMfaState({
          saving: true
        });
        try {
          var _payload$callback;
          await api2.auth.disableMfa(payload);
          const mfaDevices = await api2.auth.getMFADevices();
          setMfaState({
            saving: false,
            error: void 0,
            mfaDevices
          });
          (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
        } catch (e) {
          var _payload$callback2;
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, false, e);
        }
      };
      const preDisableMfaSms = async (_payload) => {
        const {
          deviceId
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded44);
        setMfaState({
          saving: true
        });
        try {
          var _payload$callback3;
          const res = await api2.auth.preDisableMFASMS(deviceId);
          setMfaState({
            saving: false,
            error: void 0,
            otcToken: res.otcToken,
            phoneNumber: res.phoneNumber
          });
          (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
        } catch (e) {
          var _payload$callback4;
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, false, e);
        }
      };
      const disableMfaSms = async (_payload) => {
        const {
          deviceId
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded54);
        setMfaState({
          saving: true
        });
        try {
          var _payload$callback5;
          await api2.auth.disableMFASMS(deviceId, payload);
          const mfaDevices = await api2.auth.getMFADevices();
          setMfaState({
            saving: false,
            error: void 0,
            mfaDevices
          });
          (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, true);
        } catch (e) {
          var _payload$callback6;
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          (_payload$callback6 = payload.callback) == null ? void 0 : _payload$callback6.call(payload, false, e);
        }
      };
      const preEnrollMfaSms = async (payload) => {
        setMfaState({
          saving: true
        });
        try {
          var _payload$callback7;
          const res = await api2.auth.preEnrollMFASMS(payload);
          setMfaState({
            saving: false,
            error: void 0,
            otcToken: res.otcToken,
            phoneNumber: res.phoneNumber
          });
          (_payload$callback7 = payload.callback) == null ? void 0 : _payload$callback7.call(payload, true);
        } catch (e) {
          var _payload$callback8;
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          (_payload$callback8 = payload.callback) == null ? void 0 : _payload$callback8.call(payload, false, e);
        }
      };
      const enrollMfaSms = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded64);
        setMfaState({
          saving: true
        });
        try {
          const data = await api2.auth.enrollMFASMS(payload);
          const mfaDevices = await api2.auth.getMFADevices();
          const mfaState = await __getMfaStateAfterEnroll(data);
          setMfaState(_extends({}, mfaState, {
            mfaDevices
          }));
          callback == null ? void 0 : callback(mfaState.recoveryCode);
        } catch (e) {
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const preEnrollMfaWebAuthn = async (payload) => {
        setMfaState({
          saving: true
        });
        try {
          var _data$options$exclude, _payload$callback9;
          const data = await api2.auth.preEnrollMFAWebAuthn();
          const options = _extends({}, data.options, {
            challenge: base64urlDecode(data.options.challenge),
            user: _extends({}, data.options.user, {
              id: base64urlDecode(data.options.user.id)
            }),
            excludeCredentials: (_data$options$exclude = data.options.excludeCredentials) == null ? void 0 : _data$options$exclude.map((credentials) => _extends({}, credentials, {
              id: base64urlDecode(credentials.id)
            }))
          });
          setMfaState({
            saving: false
          });
          (_payload$callback9 = payload.callback) == null ? void 0 : _payload$callback9.call(payload, {
            options,
            webauthnToken: data.webauthnToken
          });
        } catch (e) {
          var _payload$callback10;
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          (_payload$callback10 = payload.callback) == null ? void 0 : _payload$callback10.call(payload, null, e);
        }
      };
      const enrollMfaWebAuthn = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded74);
        setMfaState({
          saving: true
        });
        try {
          const publicKey = publicKeyCredentialToJSON(payload.publicKey);
          const data = await api2.auth.enrollMFAWebAuthn(_extends({}, payload, {
            options: publicKey
          }));
          const mfaDevices = await api2.auth.getMFADevices();
          const mfaState = await __getMfaStateAfterEnroll(data);
          setMfaState(_extends({}, mfaState, {
            mfaDevices
          }));
          callback == null ? void 0 : callback(mfaState.recoveryCode);
        } catch (e) {
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const preDisableMfaWebAuthn = async (_payload) => {
        const {
          deviceId,
          callback
        } = _payload;
        setMfaState({
          saving: true
        });
        try {
          var _data$options$allowCr;
          const data = await api2.auth.preDisableMFAWebAuthn(deviceId);
          const options = _extends({}, data.options, {
            challenge: base64urlDecode(data.options.challenge),
            allowCredentials: (_data$options$allowCr = data.options.allowCredentials) == null ? void 0 : _data$options$allowCr.map((credentials) => _extends({}, credentials, {
              id: base64urlDecode(credentials.id)
            }))
          });
          setMfaState({
            saving: false
          });
          callback == null ? void 0 : callback({
            options,
            webauthnToken: data.webauthnToken
          });
        } catch (e) {
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const disableMfaWebAuthn = async (_payload) => {
        const {
          deviceId,
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded83);
        setMfaState({
          saving: true
        });
        try {
          const publicKey = publicKeyCredentialToJSON(payload.publicKey);
          await api2.auth.disableMFAWebAuthn(deviceId, _extends({}, payload, {
            options: publicKey
          }));
          const mfaDevices = await api2.auth.getMFADevices();
          setMfaState({
            saving: false,
            error: void 0,
            mfaDevices
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      return {
        setMfaState,
        resetMfaState,
        getMFADevices,
        getMFAStrategies,
        enrollMfa,
        verifyMfa,
        verifyMfaAfterForce,
        disableMfa,
        preDisableMfaSms,
        disableMfaSms,
        preEnrollMfaSms,
        enrollMfaSms,
        preEnrollMfaWebAuthn,
        enrollMfaWebAuthn,
        preDisableMfaWebAuthn,
        disableMfaWebAuthn,
        __getMfaStateAfterEnroll
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/MfaState/index.js
var init_MfaState = __esm({
  "node_modules/@frontegg/redux-store/auth/MfaState/index.js"() {
    init_state14();
    init_actions14();
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/state.js
var initialState15, state_default15;
var init_state15 = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/state.js"() {
    init_rest_api();
    init_proxy();
    initialState15 = {
      loaders: {},
      errors: {},
      accounts: {
        tenantId: "",
        children: []
      },
      accountsQueryParams: {
        _limit: 50,
        _offset: 0,
        _filter: "",
        _subTenantId: ""
      },
      searchAccountsData: [],
      rootAccount: {
        tenantId: ""
      },
      selectedAccount: {
        tenantId: "",
        userJwt: {
          accessToken: "",
          expiresIn: 0,
          expires: ""
        },
        users: [],
        usersQueryParams: {
          _offset: 0,
          _limit: 10,
          _order: PaginationOrderEnum.DESC,
          _sortBy: SortByEnum.name
        },
        usersPageOffset: 0,
        accountSettings: {}
      }
    };
    state_default15 = (overrideState) => createProxy2(initialState15, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/interfaces/dialogsStateTypes.js
var init_dialogsStateTypes = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/interfaces/dialogsStateTypes.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/interfaces/stateTypes.js
var AllAccountsStateKeys;
var init_stateTypes = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/interfaces/stateTypes.js"() {
    (function(AllAccountsStateKeys2) {
      AllAccountsStateKeys2["GET_ACCOUNTS"] = "GET_ACCOUNTS";
      AllAccountsStateKeys2["SEARCH_ACCOUNTS"] = "SEARCH_ACCOUNTS";
      AllAccountsStateKeys2["SET_ROOT_ACCOUNT_DATA"] = "SET_ROOT_ACCOUNT_DATA";
      AllAccountsStateKeys2["SET_SELECTED_SUB_ACCOUNT_DATA"] = "SET_SELECTED_SUB_ACCOUNT_DATA";
      AllAccountsStateKeys2["LOAD_NUMBER_OF_USERS_FOR_ACCOUNT"] = "LOAD_NUMBER_OF_USERS_FOR_ACCOUNT";
      AllAccountsStateKeys2["UPDATE_SUB_ACCOUNT_ACCESS_FOR_USER"] = "UPDATE_SUB_ACCOUNT_ACCESS_FOR_USER";
      AllAccountsStateKeys2["CREATE_SUB_ACCOUNT"] = "CREATE_SUB_ACCOUNT";
      AllAccountsStateKeys2["UPDATE_SUB_ACCOUNT"] = "UPDATE_SUB_ACCOUNT";
      AllAccountsStateKeys2["DELETE_SUB_ACCOUNT"] = "DELETE_SUB_ACCOUNT";
      AllAccountsStateKeys2["GET_ACCOUNT_USERS"] = "GET_ACCOUNT_USERS";
      AllAccountsStateKeys2["ADD_USERS_TO_ACCOUNT"] = "ADD_USERS_TO_ACCOUNT";
      AllAccountsStateKeys2["DELETE_USERS_FROM_ACCOUNT"] = "DELETE_USERS_FROM_ACCOUNT";
      AllAccountsStateKeys2["SET_USER_ROLES_FOR_SUB_ACCOUNT"] = "SET_USER_ROLES_FOR_SUB_ACCOUNT";
      AllAccountsStateKeys2["UPDATE_SUB_ACCOUNT_SETTINGS"] = "UPDATE_SUB_ACCOUNT_SETTINGS";
      AllAccountsStateKeys2["UPDATE_SUB_ACCOUNT_MANAGEMENT"] = "UPDATE_SUB_ACCOUNT_MANAGEMENT";
      AllAccountsStateKeys2["UPDATE_SUB_ACCOUNT_HIERARCHY_SETTINGS"] = "UPDATE_SUB_ACCOUNT_HIERARCHY_SETTINGS";
      AllAccountsStateKeys2["GET_USER_JWT"] = "GET_USER_JWT";
      AllAccountsStateKeys2["GET_TEAM_USERS"] = "GET_TEAM_USERS";
    })(AllAccountsStateKeys || (AllAccountsStateKeys = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/interfaces/index.js
var init_interfaces39 = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/interfaces/index.js"() {
    init_dialogsStateTypes();
    init_stateTypes();
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/helpers/appendChildrenToNode.js
function appendChildrenToNode(treeNode, id, newChildren) {
  var _treeNode$children$ma, _treeNode$children2;
  if (treeNode.tenantId === id) {
    var _treeNode$children;
    const combinedChildren = [...(_treeNode$children = treeNode == null ? void 0 : treeNode.children) != null ? _treeNode$children : [], ...newChildren];
    const uniqueChildren = combinedChildren.filter((child, index, self) => index === self.findIndex((t) => t.tenantId === child.tenantId));
    return _extends({}, treeNode, {
      children: uniqueChildren
    });
  }
  return _extends({}, treeNode, {
    children: (_treeNode$children$ma = treeNode == null ? void 0 : (_treeNode$children2 = treeNode.children) == null ? void 0 : _treeNode$children2.map((child) => appendChildrenToNode(child, id, newChildren))) != null ? _treeNode$children$ma : []
  });
}
var init_appendChildrenToNode = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/helpers/appendChildrenToNode.js"() {
    init_extends();
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/helpers/getAccountsWithUsersCount.js
var getAccountsWithUsersCount;
var init_getAccountsWithUsersCount = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/helpers/getAccountsWithUsersCount.js"() {
    getAccountsWithUsersCount = ({
      items: accounts
    }, tenantsUsersCountArray) => {
      return accounts.map((account) => {
        var _tenantsUsersCountArr, _tenantsUsersCountArr2;
        return {
          name: account.name,
          tenantId: account.tenantId,
          numberOfUsers: (_tenantsUsersCountArr = (_tenantsUsersCountArr2 = tenantsUsersCountArray.find((i) => i.tenantId === account.tenantId)) == null ? void 0 : _tenantsUsersCountArr2.totalUsers) != null ? _tenantsUsersCountArr : 0,
          createdAt: account.createdAt,
          metadata: account.metadata,
          isReseller: account.isReseller,
          subAccountAccessType: account.subAccountAccessType
        };
      });
    };
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/helpers/removeNodeFromTree.js
function removeNodeFromTree(treeNode, idToRemove) {
  var _treeNode$children;
  return _extends({}, treeNode, {
    children: (_treeNode$children = treeNode.children) != null && _treeNode$children.length ? treeNode.children.filter((child) => child.tenantId !== idToRemove).map((child) => removeNodeFromTree(child, idToRemove)) : []
  });
}
var init_removeNodeFromTree = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/helpers/removeNodeFromTree.js"() {
    init_extends();
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/helpers/updateNodeName.js
var updateNodeName;
var init_updateNodeName = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/helpers/updateNodeName.js"() {
    init_extends();
    updateNodeName = (treeNode, id, newName) => {
      var _treeNode$children$ma, _treeNode$children;
      if (treeNode.tenantId === id) {
        return _extends({}, treeNode, {
          name: newName
        });
      }
      return _extends({}, treeNode, {
        children: (_treeNode$children$ma = treeNode == null ? void 0 : (_treeNode$children = treeNode.children) == null ? void 0 : _treeNode$children.map((child) => updateNodeName(child, id, newName))) != null ? _treeNode$children$ma : []
      });
    };
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/helpers/updateNodeSubAccountAccessType.js
var updateNodeSubAccountAccessType;
var init_updateNodeSubAccountAccessType = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/helpers/updateNodeSubAccountAccessType.js"() {
    init_extends();
    updateNodeSubAccountAccessType = (treeNode, id, subAccountAccessType) => {
      var _treeNode$children$ma, _treeNode$children;
      if (treeNode.tenantId === id) {
        return _extends({}, treeNode, {
          subAccountAccessType
        });
      }
      return _extends({}, treeNode, {
        children: (_treeNode$children$ma = treeNode == null ? void 0 : (_treeNode$children = treeNode.children) == null ? void 0 : _treeNode$children.map((child) => updateNodeSubAccountAccessType(child, id, subAccountAccessType))) != null ? _treeNode$children$ma : []
      });
    };
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/helpers/index.js
var init_helpers7 = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/helpers/index.js"() {
    init_appendChildrenToNode();
    init_getAccountsWithUsersCount();
    init_removeNodeFromTree();
    init_updateNodeName();
    init_updateNodeSubAccountAccessType();
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/helpers/updateNodeIsReseller.js
var updateNodeIsReseller;
var init_updateNodeIsReseller = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/helpers/updateNodeIsReseller.js"() {
    init_extends();
    updateNodeIsReseller = (treeNode, id, isReseller) => {
      var _treeNode$children$ma, _treeNode$children;
      if (!treeNode) return {};
      if (treeNode.tenantId === id) {
        return _extends({}, treeNode, {
          isReseller
        });
      }
      return _extends({}, treeNode, {
        children: (_treeNode$children$ma = treeNode == null ? void 0 : (_treeNode$children = treeNode.children) == null ? void 0 : _treeNode$children.map((child) => updateNodeIsReseller(child, id, isReseller))) != null ? _treeNode$children$ma : []
      });
    };
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/actions.js
var actions_default15;
var init_actions15 = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/actions.js"() {
    init_extends();
    init_interfaces39();
    init_helpers();
    init_state15();
    init_helpers7();
    init_updateNodeIsReseller();
    actions_default15 = (store, api2, sharedActions) => {
      const setAllAccountsLoader = (payload) => {
        Object.assign(store.auth.allAccountsState, {
          loaders: _extends({}, store.auth.allAccountsState.loaders, {
            [payload.key]: payload.value
          })
        });
      };
      const setAllAccountsError = (payload) => {
        Object.assign(store.auth.allAccountsState, {
          errors: _extends({}, store.auth.allAccountsState.errors, {
            [payload.key]: payload.value
          }),
          loaders: _extends({}, store.auth.allAccountsState.loaders, {
            [payload.key]: false
          })
        });
      };
      const setAllAccountsState = (state) => {
        Object.assign(store.auth.allAccountsState, state);
      };
      const setSelectedAccountState = (payload) => {
        Object.assign(store.auth.allAccountsState.selectedAccount, payload);
      };
      const resetAllAccountsState = () => {
        deepResetState(store, ["auth", "allAccountsState"], initialState15);
      };
      const clearSelectedAccount = () => {
        deepResetState(store, ["auth", "allAccountsState", "selectedAccount"], initialState15.selectedAccount);
      };
      const selectAllAccountsState = () => {
        return store.auth.allAccountsState;
      };
      const loadAccounts = async (payload) => {
        const key = AllAccountsStateKeys.GET_ACCOUNTS;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          accountsQueryParams
        } = selectAllAccountsState();
        const {
          jwt,
          _limit,
          _offset
        } = payload;
        const searchSubTenantsQueryParams = {
          _offset: _offset != null ? _offset : accountsQueryParams._offset,
          _limit: _limit != null ? _limit : accountsQueryParams._limit,
          _subTenantId: payload == null ? void 0 : payload._subTenantId
        };
        try {
          const isSelectedAccountChange = !!jwt;
          if (isSelectedAccountChange) {
            var _payload$_subTenantId;
            const {
              selectedAccount
            } = selectAllAccountsState();
            const {
              items,
              _links
            } = await api2.tenants.searchSubTenants(searchSubTenantsQueryParams, {
              jwt
            });
            const tenantsUsersCountArray = await api2.tenants.getTenantsUsersCount({
              tenantIds: items.map((tenant) => tenant.tenantId)
            }, {
              jwt
            });
            const accountsWithUsersCount = getAccountsWithUsersCount({
              items
            }, tenantsUsersCountArray);
            const updatedSingleAccountViewAccounts = appendChildrenToNode(selectedAccount.accounts ? selectedAccount.accounts : selectedAccount, (_payload$_subTenantId = payload == null ? void 0 : payload._subTenantId) != null ? _payload$_subTenantId : "", accountsWithUsersCount.map((account) => ({
              name: account.name,
              tenantId: account.tenantId,
              numberOfUsers: account.numberOfUsers,
              createdAt: account.createdAt,
              metadata: account.metadata,
              children: [],
              loadMoreLink: _links == null ? void 0 : _links.next,
              isReseller: account.isReseller
            })));
            setSelectedAccountState({
              accounts: updatedSingleAccountViewAccounts
            });
          } else {
            var _payload$_subTenantId2;
            const {
              accounts
            } = selectAllAccountsState();
            const {
              items,
              _links
            } = await api2.tenants.searchSubTenants(searchSubTenantsQueryParams);
            const tenantsUsersCountArray = await api2.tenants.getTenantsUsersCount({
              tenantIds: items.map((i) => i.tenantId)
            });
            const accountsWithUsersCount = getAccountsWithUsersCount({
              items
            }, tenantsUsersCountArray);
            const updatedAccounts = appendChildrenToNode(accounts, (_payload$_subTenantId2 = payload == null ? void 0 : payload._subTenantId) != null ? _payload$_subTenantId2 : "", accountsWithUsersCount.map((account) => ({
              name: account.name,
              tenantId: account.tenantId,
              numberOfUsers: account.numberOfUsers,
              createdAt: account.createdAt,
              metadata: account.metadata,
              children: [],
              loadMoreLink: _links == null ? void 0 : _links.next,
              isReseller: account.isReseller
            })));
            setAllAccountsState({
              accounts: updatedAccounts
            });
          }
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const searchAccounts = async (payload) => {
        const {
          jwt
        } = payload;
        const key = AllAccountsStateKeys.SEARCH_ACCOUNTS;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          rootAccount
        } = selectAllAccountsState();
        try {
          if (payload != null && payload._subTenantId) {
            var _payload$_filter;
            const {
              items
            } = await api2.tenants.searchSubTenants({
              _offset: 0,
              _limit: 50,
              _filter: (_payload$_filter = payload == null ? void 0 : payload._filter) != null ? _payload$_filter : "",
              _subTenantId: payload._subTenantId
            }, {
              jwt
            });
            setAllAccountsState({
              searchAccountsData: [...items, {
                name: rootAccount.name,
                tenantId: rootAccount.tenantId
              }]
            });
          }
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const updateSubAccountAccessForUser = async (payload) => {
        const key = AllAccountsStateKeys.UPDATE_SUB_ACCOUNT_ACCESS_FOR_USER;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          selectedAccount
        } = selectAllAccountsState();
        const {
          userId,
          allowAccess,
          jwt,
          callback
        } = payload;
        try {
          var _selectedAccount$user;
          await api2.subTenants.updateSubAccountAccess(userId, {
            allowAccess
          }, {
            jwt
          });
          setSelectedAccountState({
            users: selectedAccount == null ? void 0 : (_selectedAccount$user = selectedAccount.users) == null ? void 0 : _selectedAccount$user.map((user) => {
              if (user.id === userId) {
                return _extends({}, user, {
                  subAccountAccessAllowed: allowAccess
                });
              }
              return user;
            })
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const createSubAccount = async (payload) => {
        const key = AllAccountsStateKeys.CREATE_SUB_ACCOUNT;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          name,
          parentTenantId,
          tenantId,
          jwt,
          callback
        } = payload;
        try {
          const isSelectedAccountChange = !!jwt;
          if (isSelectedAccountChange) {
            const {
              accounts,
              selectedAccount
            } = selectAllAccountsState();
            const createdSubTenant = await api2.subTenants.createSubTenant({
              name,
              parentTenantId,
              tenantId
            }, {
              jwt
            });
            const updatedAllAccountPageAccounts = appendChildrenToNode(accounts, parentTenantId != null ? parentTenantId : "", [{
              name: createdSubTenant.name,
              tenantId: createdSubTenant.tenantId,
              numberOfUsers: 0,
              createdAt: /* @__PURE__ */ new Date()
            }]);
            const updatedSingleAccountViewAccounts = appendChildrenToNode(_extends({
              name: "",
              tenantId: ""
            }, selectedAccount == null ? void 0 : selectedAccount.accounts), parentTenantId != null ? parentTenantId : "", [{
              name: createdSubTenant.name,
              tenantId: createdSubTenant.tenantId,
              numberOfUsers: 0,
              createdAt: /* @__PURE__ */ new Date()
            }]);
            setAllAccountsState({
              accounts: updatedAllAccountPageAccounts
            });
            setSelectedAccountState({
              accounts: updatedSingleAccountViewAccounts
            });
          } else {
            const {
              accounts
            } = selectAllAccountsState();
            const createdSubTenant = await api2.subTenants.createSubTenant({
              name,
              tenantId,
              parentTenantId
            });
            const updatedAccounts = appendChildrenToNode(accounts, parentTenantId != null ? parentTenantId : "", [{
              name: createdSubTenant.name,
              tenantId: createdSubTenant.tenantId,
              numberOfUsers: 0,
              createdAt: /* @__PURE__ */ new Date()
            }]);
            setAllAccountsState({
              accounts: updatedAccounts
            });
          }
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const updateSubAccount = async (payload) => {
      };
      const deleteSubAccount = async (payload) => {
        const key = AllAccountsStateKeys.DELETE_SUB_ACCOUNT;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          jwt,
          tenantId,
          callback
        } = payload;
        try {
          const isSelectedAccountChange = !!jwt;
          if (isSelectedAccountChange) {
            const {
              selectedAccount,
              accounts
            } = selectAllAccountsState();
            await api2.subTenants.deleteSubTenant(tenantId, {
              jwt
            });
            const udpatedAccounts = removeNodeFromTree(accounts, tenantId);
            const updatedAccountsForSelectedAccount = removeNodeFromTree(selectedAccount.accounts, tenantId);
            setAllAccountsState({
              accounts: udpatedAccounts
            });
            setSelectedAccountState({
              accounts: updatedAccountsForSelectedAccount
            });
          } else {
            const {
              accounts
            } = selectAllAccountsState();
            await api2.subTenants.deleteSubTenant(tenantId);
            const udpatedAccounts = removeNodeFromTree(accounts, tenantId);
            setAllAccountsState({
              accounts: udpatedAccounts
            });
          }
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const updateSubAccountHierarchySettings = async (payload) => {
        const key = AllAccountsStateKeys.UPDATE_SUB_ACCOUNT_HIERARCHY_SETTINGS;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          jwt,
          callback,
          tenantId,
          subAccountAccessType
        } = payload;
        if (!subAccountAccessType) {
          return;
        }
        try {
          const isSelectedAccountChange = !!jwt;
          if (isSelectedAccountChange) {
            const {
              selectedAccount,
              accounts
            } = selectAllAccountsState();
            await api2.subTenants.updateSubTenantHierarchySettings({
              tenantId
            }, {
              subAccountAccessType
            }, {
              jwt
            });
            const updatedAccounts = updateNodeSubAccountAccessType(selectedAccount.accounts, tenantId, subAccountAccessType);
            setSelectedAccountState({
              subAccountAccessType,
              accounts: updatedAccounts
            });
            const updatedAccountsForAllAccountsPage = updateNodeSubAccountAccessType(accounts, tenantId, subAccountAccessType);
            setAllAccountsState({
              accounts: updatedAccountsForAllAccountsPage
            });
          } else {
            const {
              accounts
            } = selectAllAccountsState();
            await api2.subTenants.updateSubTenantHierarchySettings({
              tenantId
            }, {
              subAccountAccessType
            });
            const updatedAccounts = updateNodeSubAccountAccessType(accounts, tenantId, subAccountAccessType);
            setAllAccountsState({
              accounts: updatedAccounts
            });
          }
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const updateSubAccountSettings = async (payload) => {
        const key = AllAccountsStateKeys.UPDATE_SUB_ACCOUNT_HIERARCHY_SETTINGS;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          jwt,
          name,
          callback,
          tenantId
        } = payload;
        try {
          const isSelectedAccountChange = !!jwt;
          if (isSelectedAccountChange) {
            const {
              selectedAccount,
              accounts
            } = selectAllAccountsState();
            await api2.subTenants.updateSubTenant({
              tenantId
            }, {
              name
            }, {
              jwt
            });
            const udpatedAccs = updateNodeName(selectedAccount.accounts, tenantId, name);
            setSelectedAccountState({
              name,
              accounts: udpatedAccs
            });
            const udpatedAccsForAllAccountsPage = updateNodeName(accounts, tenantId, name);
            setAllAccountsState({
              accounts: udpatedAccsForAllAccountsPage
            });
          } else {
            const {
              accounts
            } = selectAllAccountsState();
            await api2.subTenants.updateSubTenant({
              tenantId
            }, {
              name
            });
            const udpatedAccs = updateNodeName(accounts, tenantId, name);
            setAllAccountsState({
              accounts: udpatedAccs
            });
          }
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const updateSubAccountManagement = async (payload) => {
        const key = AllAccountsStateKeys.UPDATE_SUB_ACCOUNT_MANAGEMENT;
        sharedActions.setAllAccountsLoader({
          key,
          value: true
        });
        const {
          jwt,
          isReseller,
          callback,
          tenantId,
          shouldUpdateSelectedAccount
        } = payload;
        const isChildUpdated = !!jwt;
        try {
          if (shouldUpdateSelectedAccount) {
            const {
              selectedAccount,
              accounts
            } = store.auth.allAccountsState;
            await api2.subTenants.updateSubTenantManagement({
              tenantId
            }, {
              isReseller
            }, jwt ? {
              jwt
            } : void 0);
            const updatedAccs = updateNodeIsReseller(selectedAccount.accounts, tenantId, isReseller != null ? isReseller : false);
            setSelectedAccountState({
              accounts: updatedAccs
            });
            if (!isChildUpdated) {
              setSelectedAccountState({
                isReseller
              });
            }
            const udpatedAccsForAllAccountsPage = updateNodeIsReseller(accounts, tenantId, isReseller != null ? isReseller : false);
            setAllAccountsState({
              accounts: udpatedAccsForAllAccountsPage
            });
          } else {
            const {
              accounts
            } = store.auth.allAccountsState;
            api2.subTenants.updateSubTenantManagement({
              tenantId
            }, {
              isReseller
            }, jwt ? {
              jwt
            } : void 0);
            const udpatedAccs = updateNodeIsReseller(accounts, tenantId, isReseller != null ? isReseller : false);
            setAllAccountsState({
              accounts: udpatedAccs
            });
          }
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const addUsersToAccount = async (payload) => {
        const {
          users,
          tenantId,
          jwt,
          callback,
          allowSubAccountAccess = false,
          roleIds
        } = payload;
        const key = AllAccountsStateKeys.ADD_USERS_TO_ACCOUNT;
        try {
          setAllAccountsLoader({
            key,
            value: true
          });
          await api2.subTenants.addUsersToSubTenant({
            users,
            tenantId,
            allowSubAccountAccess,
            roleIds
          }, {
            jwt
          });
          await getAccountUsers({
            jwt,
            _tenantId: tenantId
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const getAccountUsers = async (payload) => {
        var _ref, _payload$_offset, _allAccountsState$sel, _allAccountsState$sel2, _ref2, _payload$_limit, _allAccountsState$sel3, _allAccountsState$sel4;
        const {
          jwt,
          _tenantId,
          _email
        } = payload;
        const key = AllAccountsStateKeys.GET_ACCOUNT_USERS;
        setAllAccountsLoader({
          key,
          value: true
        });
        const allAccountsState = selectAllAccountsState();
        const _offset = (_ref = (_payload$_offset = payload == null ? void 0 : payload._offset) != null ? _payload$_offset : allAccountsState == null ? void 0 : (_allAccountsState$sel = allAccountsState.selectedAccount) == null ? void 0 : (_allAccountsState$sel2 = _allAccountsState$sel.usersQueryParams) == null ? void 0 : _allAccountsState$sel2._offset) != null ? _ref : 0;
        const _limit = (_ref2 = (_payload$_limit = payload == null ? void 0 : payload._limit) != null ? _payload$_limit : allAccountsState == null ? void 0 : (_allAccountsState$sel3 = allAccountsState.selectedAccount) == null ? void 0 : (_allAccountsState$sel4 = _allAccountsState$sel3.usersQueryParams) == null ? void 0 : _allAccountsState$sel4._limit) != null ? _ref2 : 10;
        const getAccountUsersQueryParams = _extends({
          _offset,
          _limit,
          _tenantId,
          _includeSubTenants: false
        }, !!_email && {
          _email
        });
        try {
          const {
            items: usersItems,
            _metadata: {
              totalItems,
              totalPages
            }
          } = await api2.users.getUsersV3(getAccountUsersQueryParams, {
            jwt
          });
          const selectedAccountStateObj = {
            totalUsersItems: totalItems,
            totalUsersPages: totalPages,
            usersQueryParams: _extends({
              _offset: _offset != null ? _offset : 0,
              _limit: _limit != null ? _limit : 10
            }, !!_email && {
              _email
            })
          };
          if (usersItems.length) {
            const usersIds = usersItems.map((user) => user.id);
            const allRoles = await api2.roles.getRoles();
            const usersRoles = await api2.users.getUsersRoles({
              ids: usersIds
            }, {
              jwt
            });
            const usersWithRoles = usersItems.map((user) => {
              var _usersRoles$find, _ref3;
              const userRolesIds = usersRoles == null ? void 0 : (_usersRoles$find = usersRoles.find((role) => role.userId === user.id)) == null ? void 0 : _usersRoles$find.roleIds;
              return _extends({}, user, {
                roles: (_ref3 = userRolesIds == null ? void 0 : userRolesIds.map((roleId) => {
                  var _allRoles$find;
                  return (_allRoles$find = allRoles == null ? void 0 : allRoles.find((role) => role.id === roleId)) != null ? _allRoles$find : [];
                })) != null ? _ref3 : []
              });
            });
            setSelectedAccountState(_extends({
              users: usersWithRoles
            }, selectedAccountStateObj));
          } else {
            setSelectedAccountState(_extends({
              users: []
            }, selectedAccountStateObj));
          }
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const deleteUsersFromAccount = async (payload) => {
        const key = AllAccountsStateKeys.DELETE_USERS_FROM_ACCOUNT;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          userId,
          subTenants,
          jwt,
          callback
        } = payload;
        try {
          await api2.subTenants.removeUserFromTenantAndSubTenants({
            userId,
            subTenants
          }, {
            jwt
          });
          await getAccountUsers({
            jwt,
            _tenantId: subTenants[0].tenantId
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const setUserRolesForSubAccount = async (payload) => {
        const {
          userId,
          subTenantsRoles,
          jwt,
          callback
        } = payload;
        const key = AllAccountsStateKeys.SET_USER_ROLES_FOR_SUB_ACCOUNT;
        try {
          setAllAccountsLoader({
            key,
            value: true
          });
          const {
            selectedAccount
          } = selectAllAccountsState();
          await api2.subTenants.setUserRolesForSubTenants(userId, {
            subTenantsRoles
          }, {
            jwt
          });
          await getAccountUsers({
            jwt,
            _tenantId: selectedAccount.tenantId
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const getUserJwtForSubAccount = async (payload) => {
        const {
          tenantId,
          callback
        } = payload;
        const key = AllAccountsStateKeys.GET_USER_JWT;
        try {
          setAllAccountsLoader({
            key,
            value: true
          });
          const userJwt = await api2.users.GetUserJwt({
            tenantId
          });
          setSelectedAccountState({
            userJwt,
            accessPermission: true
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
          setSelectedAccountState({
            accessPermission: false
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const setRootAccountData = async () => {
        const key = AllAccountsStateKeys.SET_ROOT_ACCOUNT_DATA;
        setAllAccountsLoader({
          key,
          value: true
        });
        const {
          activeTenant
        } = store.auth.tenantsState;
        const {
          accounts
        } = selectAllAccountsState();
        if (!activeTenant) return;
        try {
          var _tenantUsersCount$;
          const tenantUsersCount = await api2.tenants.getTenantsUsersCount({
            tenantIds: [activeTenant == null ? void 0 : activeTenant.tenantId]
          });
          const rootAccount = {
            name: activeTenant == null ? void 0 : activeTenant.name,
            tenantId: activeTenant == null ? void 0 : activeTenant.tenantId,
            numberOfUsers: (_tenantUsersCount$ = tenantUsersCount[0]) == null ? void 0 : _tenantUsersCount$.totalUsers,
            createdAt: activeTenant == null ? void 0 : activeTenant.createdAt
          };
          setAllAccountsState({
            rootAccount,
            accounts: _extends({}, accounts, rootAccount)
          });
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const setSelectedSubAccountData = async (payload) => {
        const {
          jwt
        } = payload;
        const key = AllAccountsStateKeys.SET_SELECTED_SUB_ACCOUNT_DATA;
        try {
          var _accountSettings$tena, _accountSettings$tena2, _accountSettings$tena3, _subAccountsAmount$, _accountSettings$tena4, _numberOfUsersArray$, _accountSettings$tena5;
          setAllAccountsLoader({
            key,
            value: true
          });
          const accountSettings = await api2.accountSettings.getSettings({
            jwt
          });
          const [numberOfUsersArray, parentsAccounts, subAccountsAmount] = await Promise.all([api2.tenants.getTenantsUsersCount({
            tenantIds: [(_accountSettings$tena = accountSettings == null ? void 0 : accountSettings.tenantId) != null ? _accountSettings$tena : ""]
          }, {
            jwt
          }), api2.tenants.getParentTenants({
            jwt
          }), api2.tenants.getHierarchyMetadata({
            _tenantIds: [(_accountSettings$tena2 = accountSettings == null ? void 0 : accountSettings.tenantId) != null ? _accountSettings$tena2 : ""]
          }, {
            jwt
          })]);
          setSelectedAccountState({
            tenantId: (_accountSettings$tena3 = accountSettings.tenantId) != null ? _accountSettings$tena3 : "",
            name: accountSettings.name,
            numberOfUsersObject: numberOfUsersArray[0],
            parentsAccounts,
            numberOfSubAccounts: (_subAccountsAmount$ = subAccountsAmount[0]) == null ? void 0 : _subAccountsAmount$.totalSubTenants,
            accountSettings,
            accounts: {
              name: accountSettings.name,
              tenantId: (_accountSettings$tena4 = accountSettings.tenantId) != null ? _accountSettings$tena4 : "",
              numberOfUsers: (_numberOfUsersArray$ = numberOfUsersArray[0]) == null ? void 0 : _numberOfUsersArray$.totalUsers,
              //Not implemented on backend yet
              createdAt: void 0,
              children: []
            }
          });
          await getAccountUsers({
            jwt,
            _tenantId: (_accountSettings$tena5 = accountSettings == null ? void 0 : accountSettings.tenantId) != null ? _accountSettings$tena5 : ""
          });
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      const loadNumberOfUsersForSelectedSubAccount = async (payload) => {
        const {
          tenantId,
          jwt
        } = payload;
        const key = AllAccountsStateKeys.LOAD_NUMBER_OF_USERS_FOR_ACCOUNT;
        try {
          setAllAccountsLoader({
            key,
            value: true
          });
          const numberOfUsersArray = await api2.tenants.getTenantsUsersCount({
            tenantIds: [tenantId]
          }, {
            jwt
          });
          setSelectedAccountState({
            numberOfUsersObject: numberOfUsersArray[0]
          });
        } catch (e) {
          setAllAccountsError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setAllAccountsLoader({
            key,
            value: false
          });
        }
      };
      return {
        // reducers
        setAllAccountsLoader,
        setAllAccountsError,
        setAllAccountsState,
        setSelectedAccountState,
        resetAllAccountsState,
        clearSelectedAccount,
        // actions
        loadAccounts,
        searchAccounts,
        updateSubAccountAccessForUser,
        createSubAccount,
        updateSubAccount,
        deleteSubAccount,
        updateSubAccountSettings,
        updateSubAccountManagement,
        updateSubAccountHierarchySettings,
        addUsersToAccount,
        getAccountUsers,
        deleteUsersFromAccount,
        setUserRolesForSubAccount,
        getUserJwtForSubAccount,
        setRootAccountData,
        setSelectedSubAccountData,
        loadNumberOfUsersForSelectedSubAccount
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/dialogs/state.js
var initialState16, state_default16;
var init_state16 = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/dialogs/state.js"() {
    init_proxy();
    init_rest_api();
    initialState16 = {
      createSubAccountDialog: {
        loading: false,
        open: false,
        error: false,
        jwt: "",
        canSelectParentAccount: false
      },
      updateSubAccountDialog: {
        accountId: "",
        accountName: "",
        loading: false,
        open: false,
        error: false,
        jwt: ""
      },
      disableSubAccountManagementDialog: {
        accountId: "",
        accountName: "",
        loading: false,
        open: false,
        error: false
      },
      enableSubAccountManagementDialog: {
        accountId: "",
        accountName: "",
        loading: false,
        open: false,
        error: false
      },
      updateSubAccountHierarchySettingsDialog: {
        accountId: "",
        accountName: "",
        subAccountAccessType: SubAccountAccessTypeEnum.DEFAULT_OFF,
        loading: false,
        open: false,
        error: false
      },
      deleteSubAccountDialog: {
        accountId: "",
        accountName: "",
        isParentAccount: false,
        loading: false,
        open: false,
        error: false,
        jwt: ""
      },
      addUsersToAccountDialog: {
        loading: false,
        open: false,
        accountName: "",
        accountId: "",
        permissionToGiveAccessToSubAccounts: false,
        jwt: ""
      },
      deleteUserFromAccountDialog: {
        userId: "",
        userName: "",
        accountId: "",
        loading: false,
        open: false,
        jwt: ""
      },
      editUserRolesDialog: {
        loading: false,
        open: false,
        jwt: "",
        accountId: "",
        userId: "",
        userName: "",
        userRoles: []
      }
    };
    state_default16 = (overrideState) => createProxy2(initialState16, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/dialogs/actions.js
var actions_default16;
var init_actions16 = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/dialogs/actions.js"() {
    init_extends();
    init_helpers();
    init_state16();
    actions_default16 = (store, api2, sharedActions) => {
      const setAllAccountDialogsState = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState, payload);
      };
      const resetAllAccountDialogsState = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState"], initialState16);
      };
      const openCreateSubAccountDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.createSubAccountDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeCreateSubAccountDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "createSubAccountDialog"], initialState16.createSubAccountDialog);
      };
      const openUpdateSubAccountDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.updateSubAccountDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeUpdateSubAccountDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "updateSubAccountDialog"], initialState16.updateSubAccountDialog);
      };
      const openEnableSubAccountManagementDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.enableSubAccountManagementDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeEnableSubAccountManagementDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "enableSubAccountManagementDialog"], initialState16.enableSubAccountManagementDialog);
      };
      const openUpdateSubAccountHierarchySettingsDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.updateSubAccountHierarchySettingsDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeUpdateSubAccountHierarchySettingsDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "updateSubAccountHierarchySettingsDialog"], initialState16.updateSubAccountHierarchySettingsDialog);
      };
      const openDisableSubAccountManagementDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.disableSubAccountManagementDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeDisableSubAccountManagementDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "disableSubAccountManagementDialog"], initialState16.disableSubAccountManagementDialog);
      };
      const openDeleteSubAccountDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.deleteSubAccountDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeDeleteSubAccountDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "deleteSubAccountDialog"], initialState16.deleteSubAccountDialog);
      };
      const openAddUsersToAccountDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.addUsersToAccountDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeAddUsersToAccountDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "addUsersToAccountDialog"], initialState16.addUsersToAccountDialog);
      };
      const openDeleteUserFromAccountDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.deleteUserFromAccountDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeDeleteUserFromAccountDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "deleteUserFromAccountDialog"], initialState16.deleteUserFromAccountDialog);
      };
      const openEditUserRolesDialog = (payload) => {
        Object.assign(store.auth.allAccountsDialogsState.editUserRolesDialog, _extends({}, payload, {
          open: true
        }));
      };
      const closeEditUserRolesDialog = () => {
        deepResetState(store, ["auth", "allAccountsDialogsState", "editUserRolesDialog"], initialState16.editUserRolesDialog);
      };
      return {
        setAllAccountDialogsState,
        resetAllAccountDialogsState,
        openCreateSubAccountDialog,
        closeCreateSubAccountDialog,
        openUpdateSubAccountDialog,
        closeUpdateSubAccountDialog,
        openEnableSubAccountManagementDialog,
        closeEnableSubAccountManagementDialog,
        openUpdateSubAccountHierarchySettingsDialog,
        closeUpdateSubAccountHierarchySettingsDialog,
        openDisableSubAccountManagementDialog,
        closeDisableSubAccountManagementDialog,
        openDeleteSubAccountDialog,
        closeDeleteSubAccountDialog,
        openAddUsersToAccountDialog,
        closeAddUsersToAccountDialog,
        openDeleteUserFromAccountDialog,
        closeDeleteUserFromAccountDialog,
        openEditUserRolesDialog,
        closeEditUserRolesDialog
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/MSP/index.js
var init_MSP = __esm({
  "node_modules/@frontegg/redux-store/auth/MSP/index.js"() {
    init_state15();
    init_actions15();
    init_state16();
    init_actions16();
  }
});

// node_modules/@frontegg/redux-store/auth/PasskeysState/state.js
var initialState17, state_default17;
var init_state17 = __esm({
  "node_modules/@frontegg/redux-store/auth/PasskeysState/state.js"() {
    init_proxy();
    initialState17 = {
      devices: [],
      loading: false,
      error: null
    };
    state_default17 = (overrideState) => createProxy2(initialState17, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/PasskeysState/actions.js
var actions_default17;
var init_actions17 = __esm({
  "node_modules/@frontegg/redux-store/auth/PasskeysState/actions.js"() {
    init_helpers();
    init_state17();
    init_rest_api();
    actions_default17 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setPasskeysState = (payload) => {
        Object.assign(store.auth.passkeysState, payload);
      };
      const resetPasskeysState = () => {
        deepResetState(store, ["auth", "passkeysState"], initialState17);
      };
      const loadWebAuthnDevices = async () => {
        setPasskeysState({
          loading: true
        });
        try {
          const {
            devices
          } = await api2.auth.getWebAuthnDevices();
          setPasskeysState({
            devices,
            loading: false
          });
        } catch (e) {
          setPasskeysState({
            loading: false,
            error: errorHandler(e, null)
          });
        }
      };
      const deleteWebAuthnDevice = async (_payload) => {
        const {
          callback,
          deviceId
        } = _payload;
        setPasskeysState({
          loading: true
        });
        try {
          await api2.auth.deleteWebAuthnDevice(deviceId);
          const devices = store.auth.passkeysState.devices;
          const newDevices = devices.filter((device) => device.id !== deviceId);
          setPasskeysState({
            devices: newDevices,
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setPasskeysState({
            loading: false,
            error: errorHandler(e, null)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      async function getPasskeysVendorPolicy(policy) {
        var _policy$secondaryAuth;
        return !!(policy != null && (_policy$secondaryAuth = policy.secondaryAuthStrategies) != null && _policy$secondaryAuth.some(({
          isActive,
          strategy
        }) => isActive && strategy === SecondaryAuthStrategy.Passkeys));
      }
      async function __shouldShowPromptPasskeys() {
        const {
          publicAuthStrategyPolicy
        } = store.auth.securityPolicyState;
        const {
          policy
        } = publicAuthStrategyPolicy;
        const isPasskeysEnabledByVendor = await getPasskeysVendorPolicy(policy);
        const isLoggedInWithPasskeys = localStorage.getItem("preferred-login-method") === "Passkeys";
        const isMarkedDontShowAgainPrompt = localStorage.getItem("dont-show-again-prompt-passkeys") === "true";
        const [showPasskeys] = await actions.getFeatureFlags(["show-passkeys-new"]);
        if (!showPasskeys || !isPasskeysEnabledByVendor || isLoggedInWithPasskeys || isMarkedDontShowAgainPrompt) {
          return false;
        } else {
          const {
            devices
          } = await api2.auth.getWebAuthnDevices();
          setPasskeysState({
            devices: devices != null ? devices : []
          });
          const numOfDevices = !(devices != null && devices.length) ? 0 : devices.length;
          return numOfDevices === 0;
        }
      }
      return {
        setPasskeysState,
        resetPasskeysState,
        loadWebAuthnDevices,
        deleteWebAuthnDevice,
        __shouldShowPromptPasskeys
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/PasskeysState/index.js
var init_PasskeysState = __esm({
  "node_modules/@frontegg/redux-store/auth/PasskeysState/index.js"() {
    init_state17();
    init_actions17();
  }
});

// node_modules/@frontegg/redux-store/auth/ProfileState/state.js
var initialState18, state_default18;
var init_state18 = __esm({
  "node_modules/@frontegg/redux-store/auth/ProfileState/state.js"() {
    init_proxy();
    initialState18 = {
      loading: false,
      error: null
    };
    state_default18 = (overrideState) => createProxy2(initialState18, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/ProfileState/actions.js
var _excluded31, actions_default18;
var init_actions18 = __esm({
  "node_modules/@frontegg/redux-store/auth/ProfileState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_helpers();
    init_state18();
    _excluded31 = ["callback", "profilePictureUrl"];
    actions_default18 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setProfileState = (state) => {
        Object.assign(store.auth.profileState, state);
      };
      const resetProfileState = () => {
        deepResetState(store, ["auth", "profileState"], initialState18);
      };
      const loadProfile = async () => {
        setProfileState({
          loading: true
        });
        try {
          const profile = await retry(api2.teams.getProfile, 3, 2e3);
          const currentUser = store.auth.user;
          actions.setUser(_extends({}, currentUser, profile));
          setProfileState({
            profile,
            loading: false
          });
        } catch (e) {
          setProfileState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const saveProfile = async (_payload) => {
        const {
          callback,
          profilePictureUrl
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded31);
        setProfileState({
          saving: true,
          error: null,
          loading: true
        });
        try {
          var _store$auth$profileSt;
          const oldProfileData = (_store$auth$profileSt = store.auth.profileState.profile) != null ? _store$auth$profileSt : {};
          let newProfilePictureUrl = oldProfileData.profilePictureUrl;
          if (profilePictureUrl !== oldProfileData.profilePictureUrl && profilePictureUrl) {
            const matchResult = (profilePictureUrl || "").match(/^data:image\/([A-Za-z-+\/]+);base64,(.+)$/);
            if (matchResult) {
              const profileImage = base64ToFormData(profilePictureUrl, "image");
              if (profileImage) {
                newProfilePictureUrl = await api2.teams.updateProfileImage(profileImage);
                const imageTimeStamp = Date.now().toString();
                const urlTemplate = new URL(newProfilePictureUrl);
                urlTemplate.searchParams.set("t", imageTimeStamp);
                newProfilePictureUrl = urlTemplate.href;
              }
            }
          }
          const newProfileData = _extends({}, oldProfileData, payload, {
            profilePictureUrl: newProfilePictureUrl
          });
          const profile = await api2.users.updateUserProfileV2(newProfileData);
          const currentUser = store.auth.user;
          actions.setUser(_extends({}, currentUser, profile));
          actions.setProfileState({
            profile,
            saving: false,
            loading: false
          });
          callback == null ? void 0 : callback(newProfileData);
        } catch (e) {
          setProfileState({
            saving: false,
            error: errorHandler(e),
            loading: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const changePassword = async (payload) => {
        setProfileState({
          loading: true
        });
        try {
          var _payload$callback;
          await api2.teams.changePassword(payload);
          setProfileState({
            loading: false,
            error: void 0
          });
          (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
        } catch (e) {
          var _payload$callback2;
          setProfileState({
            loading: false,
            error: errorHandler(e)
          });
          (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
        }
      };
      return {
        setProfileState,
        resetProfileState,
        loadProfile,
        saveProfile,
        changePassword
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ProfileState/index.js
var init_ProfileState = __esm({
  "node_modules/@frontegg/redux-store/auth/ProfileState/index.js"() {
    init_state18();
    init_actions18();
  }
});

// node_modules/@frontegg/redux-store/auth/ProvisioningState/state.js
var initialState19, state_default19;
var init_state19 = __esm({
  "node_modules/@frontegg/redux-store/auth/ProvisioningState/state.js"() {
    init_proxy();
    initialState19 = {
      loading: false
    };
    state_default19 = (overrideState) => createProxy2(initialState19, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/ProvisioningState/actions.js
var _excluded37, _excluded213, actions_default19;
var init_actions19 = __esm({
  "node_modules/@frontegg/redux-store/auth/ProvisioningState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_helpers();
    init_state19();
    _excluded37 = ["callback"];
    _excluded213 = ["id"];
    actions_default19 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setProvisioningState = (state) => {
        Object.assign(store.auth.provisioningState, state);
      };
      const resetProvisioningState = () => {
        deepResetState(store, ["auth", "provisioningState"], initialState19);
      };
      const __loadCountForConnection = async (connection, retryConfig) => {
        const {
          count
        } = await retryIfNeeded2(() => api2.directory.countConfigurationUsers(connection.id), retryConfig);
        return _extends({}, connection, {
          count
        });
      };
      const loadProvisionConnections = async (payload) => {
        setProvisioningState({
          loading: true,
          error: null
        });
        try {
          const retryConfig = payload == null ? void 0 : payload.retryConfig;
          const connections = await retryIfNeeded2(() => api2.directory.getConfigs(), retryConfig);
          const connectionsWithCount = await Promise.all(connections.map((connection) => __loadCountForConnection(connection, retryConfig)));
          setProvisioningState({
            connections: connectionsWithCount,
            loading: false
          });
        } catch (e) {
          setProvisioningState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const createProvisionConnection = async (payload) => {
        const {
          callback
        } = payload, newConnectionBody = _objectWithoutPropertiesLoose(payload, _excluded37);
        setProvisioningState({
          loading: true,
          error: null
        });
        try {
          const newConnectionResponse = await api2.directory.createConfiguration(newConnectionBody);
          const connections = await api2.directory.getConfigs();
          const connectionsWithCount = await Promise.all(connections.map((connection) => __loadCountForConnection(connection)));
          setProvisioningState({
            connections: connectionsWithCount,
            loading: false
          });
          callback == null ? void 0 : callback(newConnectionResponse);
        } catch (e) {
          setProvisioningState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const deleteProvisionConnection = async (payload) => {
        const {
          id,
          callback
        } = payload;
        setProvisioningState({
          loading: true,
          error: null
        });
        try {
          await api2.directory.deleteConfiguration(id, payload.deleteAll);
          const connections = await api2.directory.getConfigs();
          const connectionsWithCount = await Promise.all(connections.map((connection) => __loadCountForConnection(connection)));
          setProvisioningState({
            connections: connectionsWithCount,
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setProvisioningState({
            error: errorHandler(e),
            loading: false
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      const updateProvisionConnection = async (payload) => {
        const {
          id
        } = payload, updateRequest = _objectWithoutPropertiesLoose(payload, _excluded213);
        setProvisioningState({
          loading: true,
          error: null
        });
        try {
          await api2.directory.updateConfiguration(id, updateRequest);
          const connections = await api2.directory.getConfigs();
          const connectionsWithCount = await Promise.all(connections.map((connection) => __loadCountForConnection(connection)));
          setProvisioningState({
            connections: connectionsWithCount,
            loading: false
          });
        } catch (e) {
          setProvisioningState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      return {
        setProvisioningState,
        resetProvisioningState,
        __loadCountForConnection,
        loadProvisionConnections,
        createProvisionConnection,
        deleteProvisionConnection,
        updateProvisionConnection
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ProvisioningState/index.js
var init_ProvisioningState = __esm({
  "node_modules/@frontegg/redux-store/auth/ProvisioningState/index.js"() {
    init_state19();
    init_actions19();
  }
});

// node_modules/@frontegg/redux-store/auth/ResetPhoneNumberState/interfaces.js
var ResetPhoneNumberStep;
var init_interfaces40 = __esm({
  "node_modules/@frontegg/redux-store/auth/ResetPhoneNumberState/interfaces.js"() {
    (function(ResetPhoneNumberStep2) {
      ResetPhoneNumberStep2["ResetPhoneNumber"] = "ResetPhoneNumber";
      ResetPhoneNumberStep2["VerifyResetPhoneNumber"] = "VerifyResetPhoneNumber";
      ResetPhoneNumberStep2["ChangePhoneNumber"] = "ChangePhoneNumber";
    })(ResetPhoneNumberStep || (ResetPhoneNumberStep = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/ResetPhoneNumberState/state.js
var initialState20, state_default20;
var init_state20 = __esm({
  "node_modules/@frontegg/redux-store/auth/ResetPhoneNumberState/state.js"() {
    init_interfaces40();
    init_proxy();
    initialState20 = {
      step: ResetPhoneNumberStep.ResetPhoneNumber,
      loading: false
    };
    state_default20 = (overrideState) => createProxy2(initialState20, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/ResetPhoneNumberState/actions.js
var _excluded38, _excluded214, _excluded39, actions_default20;
var init_actions20 = __esm({
  "node_modules/@frontegg/redux-store/auth/ResetPhoneNumberState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_rest_api();
    init_interfaces40();
    init_helpers();
    init_state20();
    init_interfaces28();
    _excluded38 = ["callback"];
    _excluded214 = ["callback"];
    _excluded39 = ["callback"];
    actions_default20 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setResetPhoneNumberState = (state) => {
        Object.assign(store.auth.resetPhoneNumberState, state);
      };
      const resetResetPhoneNumberState = () => {
        deepResetState(store, ["auth", "resetPhoneNumberState"], initialState20);
      };
      const resetPhoneNumber = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded38);
        setResetPhoneNumberState({
          loading: true
        });
        try {
          const res = await api2.auth.resetPhoneNumber(body);
          setResetPhoneNumberState({
            loading: false,
            error: void 0,
            resetPhoneNumberToken: res.resetPhoneNumberToken,
            step: ResetPhoneNumberStep.VerifyResetPhoneNumber
          });
          actions.setLoginState({
            email: body.email
          });
        } catch (e) {
          setResetPhoneNumberState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const verifyResetPhoneNumber = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded214);
        setResetPhoneNumberState({
          loading: true
        });
        try {
          const res = await api2.auth.verifyResetPhoneNumber(body);
          setResetPhoneNumberState({
            loading: false,
            error: void 0,
            changePhoneNumberToken: res.changePhoneNumberToken,
            step: ResetPhoneNumberStep.ChangePhoneNumber
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setResetPhoneNumberState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const changePhoneNumber = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded39);
        setResetPhoneNumberState({
          loading: true
        });
        try {
          const {
            onRedirectTo,
            routes
          } = store.auth;
          await api2.auth.changePhoneNumber({
            phoneNumber: body.phoneNumber,
            changePhoneNumberToken: body.changePhoneNumberToken
          });
          actions.setLoginState({
            step: LoginStep.loginWithSmsOtc
          });
          await actions.passwordlessPreLogin({
            type: AuthStrategyEnum.SmsCode,
            email: body.email,
            recaptchaToken: body.recaptchaToken
          });
          onRedirectTo(routes.loginUrl);
          setResetPhoneNumberState({
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setResetPhoneNumberState({
            loading: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      return {
        setResetPhoneNumberState,
        resetResetPhoneNumberState,
        resetPhoneNumber,
        verifyResetPhoneNumber,
        changePhoneNumber
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/ResetPhoneNumberState/index.js
var init_ResetPhoneNumberState = __esm({
  "node_modules/@frontegg/redux-store/auth/ResetPhoneNumberState/index.js"() {
    init_state20();
    init_actions20();
  }
});

// node_modules/@frontegg/redux-store/auth/RolesState/state.js
var initialState21, state_default21;
var init_state21 = __esm({
  "node_modules/@frontegg/redux-store/auth/RolesState/state.js"() {
    init_proxy();
    initialState21 = {
      loaders: {},
      errors: {},
      roles: [],
      permissions: [],
      permissionCategories: []
    };
    state_default21 = (overrideState) => createProxy2(initialState21, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/RolesState/interfaces.js
var RolesStateKeys;
var init_interfaces41 = __esm({
  "node_modules/@frontegg/redux-store/auth/RolesState/interfaces.js"() {
    (function(RolesStateKeys2) {
      RolesStateKeys2["EDIT_ROLE_DIALOG"] = "editRoleDialog";
      RolesStateKeys2["DELETE_ROLE_DIALOG"] = "deleteRoleDialog";
      RolesStateKeys2["LOAD_ROLES"] = "loadRoles";
      RolesStateKeys2["ADD_ROLE"] = "addRole";
      RolesStateKeys2["MANAGE_PERMISSIONS"] = "managePermissions";
    })(RolesStateKeys || (RolesStateKeys = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/RolesState/actions.js
var _excluded40, _excluded215, _excluded310, _excluded45, _excluded55, _excluded65, actions_default21;
var init_actions21 = __esm({
  "node_modules/@frontegg/redux-store/auth/RolesState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_interfaces41();
    init_state21();
    init_helpers();
    _excluded40 = ["callback"];
    _excluded215 = ["callback"];
    _excluded310 = ["callback"];
    _excluded45 = ["callback"];
    _excluded55 = ["callback"];
    _excluded65 = ["callback"];
    actions_default21 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setRolesState = (state) => {
        Object.assign(store.auth.rolesState, state);
      };
      const resetRolesState = () => {
        deepResetState(store, ["auth", "rolesState"], initialState21);
      };
      const setRolesStateLoader = (payload) => {
        Object.assign(store.auth.rolesState, {
          loaders: _extends({}, store.auth.rolesState.loaders, {
            [payload.key]: payload.value
          })
        });
      };
      const setRolesStateError = (payload) => {
        Object.assign(store.auth.rolesState, {
          errors: _extends({}, store.auth.rolesState.errors, {
            [payload.key]: payload.value
          }),
          loaders: _extends({}, store.auth.rolesState.loaders, {
            [payload.key]: false
          })
        });
      };
      const loadRolesAndPermissions = async (payload) => {
        var _payload$silentLoadin;
        const key = RolesStateKeys.LOAD_ROLES;
        setRolesStateLoader({
          key,
          value: !((_payload$silentLoadin = payload == null ? void 0 : payload.silentLoading) != null ? _payload$silentLoadin : false)
        });
        try {
          const retryConfig = payload == null ? void 0 : payload.retryConfig;
          const [roles, permissions, permissionCategories] = await Promise.all([retryIfNeeded2(() => api2.roles.getRoles(), retryConfig), retryIfNeeded2(() => api2.roles.getPermissions(), retryConfig), retryIfNeeded2(() => api2.roles.getPermissionCategories(), retryConfig)]);
          const {
            selectedRole
          } = store.auth.rolesState;
          const updatedSelectedRole = roles == null ? void 0 : roles.find(({
            id: roleId
          }) => (selectedRole == null ? void 0 : selectedRole.id) === roleId);
          setRolesState({
            roles,
            permissions,
            permissionCategories,
            selectedRole: updatedSelectedRole
          });
        } catch (e) {
          setRolesStateError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setRolesStateLoader({
            key,
            value: false
          });
        }
      };
      const addRole = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded40);
        const key = RolesStateKeys.ADD_ROLE;
        setRolesStateLoader({
          key,
          value: true
        });
        try {
          const role = await api2.roles.addRole(body);
          await loadRolesAndPermissions({
            silentLoading: true
          });
          callback == null ? void 0 : callback(role);
        } catch (e) {
          setRolesStateError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          setRolesStateLoader({
            key,
            value: false
          });
        }
      };
      const addRoleV2 = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded215);
        const key = RolesStateKeys.ADD_ROLE;
        setRolesStateLoader({
          key,
          value: true
        });
        try {
          const role = await api2.roles.addRoleV2(body);
          await loadRolesAndPermissions({
            silentLoading: true
          });
          callback == null ? void 0 : callback(role);
        } catch (e) {
          setRolesStateError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          setRolesStateLoader({
            key,
            value: false
          });
        }
      };
      const updateRole = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded310);
        const key = RolesStateKeys.EDIT_ROLE_DIALOG;
        setRolesStateLoader({
          key,
          value: true
        });
        try {
          const role = await api2.roles.updateRole(body);
          await loadRolesAndPermissions({
            silentLoading: true
          });
          setRolesState({
            saving: false
          });
          callback == null ? void 0 : callback(role);
        } catch (e) {
          setRolesStateError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          setRolesStateLoader({
            key,
            value: false
          });
        }
      };
      const deleteRole = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded45);
        const key = RolesStateKeys.DELETE_ROLE_DIALOG;
        setRolesStateLoader({
          key,
          value: true
        });
        try {
          await api2.roles.deleteRole(body);
          await loadRolesAndPermissions({
            silentLoading: true
          });
          setRolesState({
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setRolesStateError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        } finally {
          setRolesStateLoader({
            key,
            value: false
          });
        }
      };
      const attachPermissionsToRole = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded55);
        const key = RolesStateKeys.MANAGE_PERMISSIONS;
        setRolesStateLoader({
          key,
          value: true
        });
        try {
          const role = await api2.roles.attachPermissionsToRole(body);
          await loadRolesAndPermissions({
            silentLoading: true
          });
          setRolesState({
            saving: false
          });
          callback == null ? void 0 : callback(role);
        } catch (e) {
          setRolesStateError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          setRolesStateLoader({
            key,
            value: false
          });
        }
      };
      const attachPermissionToRoles = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded65);
        const key = RolesStateKeys.MANAGE_PERMISSIONS;
        setRolesStateLoader({
          key,
          value: true
        });
        try {
          await Promise.all(body.roleIds.map((roleId) => attachPermissionsToRole({
            roleId,
            permissionIds: [body.permissionId]
          })));
          await loadRolesAndPermissions({
            silentLoading: true
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setRolesStateError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          setRolesStateLoader({
            key,
            value: false
          });
        }
      };
      return {
        setRolesState,
        setRolesStateLoader,
        setRolesStateError,
        resetRolesState,
        loadRolesAndPermissions,
        addRole,
        addRoleV2,
        updateRole,
        deleteRole,
        attachPermissionsToRole,
        /**
         * @deprecated removed in v6.176.x
         *
         * https://github.com/frontegg/admin-box/commit/2f9d3b515b560e6197f61a36327be31ad71d79a2#diff-9aad7a2338a48d5d9d0eb9e90e438b36c496e3628ff106b3a11aa1f02bc483b1
         */
        attachPermissionToRoles
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/RolesState/index.js
var init_RolesState = __esm({
  "node_modules/@frontegg/redux-store/auth/RolesState/index.js"() {
    init_state21();
    init_actions21();
  }
});

// node_modules/@frontegg/redux-store/auth/Security/RestrictionsState/state.js
var initialState22, state_default22;
var init_state22 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/RestrictionsState/state.js"() {
    init_rest_api();
    init_proxy();
    initialState22 = {
      ipRestrictions: {
        loading: false,
        pagination: {
          _offset: 0,
          _limit: 4,
          _filter: RestrictionType.ALLOW
        },
        totalPages: 1,
        userIpValid: false
      },
      emailDomainRestrictions: {
        loading: false
      }
    };
    state_default22 = (overrideState) => createProxy2(initialState22, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/Security/RestrictionsState/actions.js
var _excluded41, _excluded216, _excluded311, _excluded46, actions_default22;
var init_actions22 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/RestrictionsState/actions.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_helpers();
    init_rest_api();
    _excluded41 = ["callback"];
    _excluded216 = ["callback"];
    _excluded311 = ["callback"];
    _excluded46 = ["callback"];
    actions_default22 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __getPagination = (statePagination) => {
        var _statePagination$_fil, _statePagination$_lim, _statePagination$_off;
        return {
          _filter: (_statePagination$_fil = statePagination == null ? void 0 : statePagination._filter) != null ? _statePagination$_fil : RestrictionType.ALLOW,
          _limit: (_statePagination$_lim = statePagination == null ? void 0 : statePagination._limit) != null ? _statePagination$_lim : 10,
          _offset: (_statePagination$_off = statePagination == null ? void 0 : statePagination._offset) != null ? _statePagination$_off : 0
        };
      };
      const __securityCenterSagaWrapper = (action) => {
        return async (...args) => {
          const [securityCenterFeatureFlag] = await actions.getFeatureFlags(["security-center-admin-portal-major-version"]);
          await action(...args);
          if (securityCenterFeatureFlag) {
            await actions.loadRecommendations(withRetryConfig());
            await actions.loadInsights(withRetryConfig());
          }
        };
      };
      const setRestrictionsState = (state) => {
        Object.assign(store.auth.restrictionsState, state);
      };
      const setIpRestrictionsState = (state) => {
        Object.assign(store.auth.restrictionsState.ipRestrictions, state);
      };
      const setEmailDomainRestrictionsState = (state) => {
        Object.assign(store.auth.restrictionsState.emailDomainRestrictions, state);
      };
      const loadIpRestrictions = async () => {
        setIpRestrictionsState({
          loading: true,
          error: null
        });
        try {
          const ipRestrictionState = store.auth.restrictionsState.ipRestrictions;
          const restrictionsConfig = await api2.auth.getIPRestrictionsConfig();
          const pagination = __getPagination({
            _filter: restrictionsConfig.strategy,
            _limit: ipRestrictionState.pagination._limit,
            _offset: ipRestrictionState.pagination._offset
          });
          const {
            items,
            _metadata: {
              totalPages
            }
          } = await api2.auth.getIPRestrictions(pagination);
          const restrictions = items;
          setIpRestrictionsState({
            data: {
              restrictions,
              config: restrictionsConfig
            },
            totalPages,
            pagination,
            loading: false
          });
        } catch (e) {
          setIpRestrictionsState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const saveIpRestriction = async (payload) => {
        const {
          callback
        } = payload, newRestriction = _objectWithoutPropertiesLoose(payload, _excluded41);
        setIpRestrictionsState({
          saving: true,
          error: null
        });
        try {
          var _ipRestrictionsState$, _ipRestrictionsState$2;
          await api2.auth.createIPRestriction(newRestriction);
          const ipRestrictionsState = store.auth.restrictionsState.ipRestrictions;
          const pagination = __getPagination(ipRestrictionsState.pagination);
          const {
            items,
            _metadata: {
              totalPages
            }
          } = await api2.auth.getIPRestrictions(pagination);
          const restrictions = items;
          await checkIfUserIpValid();
          setIpRestrictionsState({
            data: {
              config: (_ipRestrictionsState$ = (_ipRestrictionsState$2 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$2.config) != null ? _ipRestrictionsState$ : {
                isActive: false,
                strategy: RestrictionType.ALLOW
              },
              restrictions
            },
            pagination,
            totalPages,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setIpRestrictionsState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const saveIpRestrictionsConfig = async (payload) => {
        const {
          callback
        } = payload, config = _objectWithoutPropertiesLoose(payload, _excluded216);
        setIpRestrictionsState({
          saving: true,
          error: null
        });
        try {
          await api2.auth.updateIPRestrictionConfig(config);
          const ipRestrictionsState = store.auth.restrictionsState.ipRestrictions;
          const restrictionsConfig = await api2.auth.getIPRestrictionsConfig();
          const pagination = __getPagination(_extends({}, ipRestrictionsState.pagination, {
            _filter: restrictionsConfig.strategy
          }));
          const {
            items,
            _metadata: {
              totalPages
            }
          } = await api2.auth.getIPRestrictions(pagination);
          const restrictions = items;
          await checkIfUserIpValid();
          setIpRestrictionsState({
            data: {
              config: restrictionsConfig,
              restrictions
            },
            pagination,
            totalPages,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setIpRestrictionsState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const deleteIpRestriction = async (payload) => {
        const {
          id,
          callback
        } = payload;
        setIpRestrictionsState({
          saving: true,
          error: null
        });
        try {
          var _ipRestrictionsState$3;
          await api2.auth.deleteIPRestriction(id);
          const ipRestrictionsState = store.auth.restrictionsState.ipRestrictions;
          const pagination = __getPagination(ipRestrictionsState.pagination);
          const {
            items,
            _metadata: {
              totalPages
            }
          } = await api2.auth.getIPRestrictions(pagination);
          const restrictions = items;
          await checkIfUserIpValid();
          setIpRestrictionsState({
            data: {
              config: ((_ipRestrictionsState$3 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$3.config) || {
                isActive: false,
                strategy: RestrictionType.ALLOW
              },
              restrictions
            },
            pagination,
            totalPages,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setIpRestrictionsState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const checkIfUserIpValid = async () => {
        try {
          const {
            valid: userIpValid
          } = await api2.auth.testCurrentIpInAllowList();
          setIpRestrictionsState({
            userIpValid
          });
        } catch (e) {
          setIpRestrictionsState({
            error: errorHandler(e)
          });
        }
      };
      const addCurrentUserIpAndActivate = async (payload) => {
        const {
          callback
        } = payload;
        setIpRestrictionsState({
          saving: true,
          error: null
        });
        try {
          var _ref, _store$auth$userIpDat;
          const userIp = (_ref = ((_store$auth$userIpDat = store.auth.userIpData) == null ? void 0 : _store$auth$userIpDat.ip) || store.auth.userIp) != null ? _ref : "";
          await Promise.all([api2.auth.createIPRestriction({
            ip: userIp,
            isActive: true,
            description: "My IP",
            strategy: RestrictionType.ALLOW
          }), api2.auth.updateIPRestrictionConfig({
            isActive: true
          })]);
          const ipRestrictionState = store.auth.restrictionsState.ipRestrictions;
          const pagination = __getPagination(ipRestrictionState.pagination);
          const {
            items,
            _metadata: {
              totalPages
            }
          } = await api2.auth.getIPRestrictions(pagination);
          const restrictions = items;
          setIpRestrictionsState({
            data: {
              config: {
                isActive: true,
                strategy: RestrictionType.ALLOW
              },
              restrictions
            },
            userIpValid: true,
            pagination,
            totalPages,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setIpRestrictionsState({
            saving: false,
            error: e
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      const loadEmailDomainRestrictions = async () => {
        setEmailDomainRestrictionsState({
          loading: true,
          error: null
        });
        try {
          const restrictionsConfig = await api2.auth.getDomainRestrictionsConfig();
          const restrictions = await api2.auth.getDomainRestrictions();
          const filteredRestrictions = restrictions.items.filter((restriction) => restriction.type === restrictionsConfig.listType);
          setEmailDomainRestrictionsState({
            data: {
              restrictions: filteredRestrictions,
              config: restrictionsConfig
            },
            loading: false
          });
        } catch (e) {
          setEmailDomainRestrictionsState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const saveEmailDomainRestriction = async (payload) => {
        const {
          callback
        } = payload, newRestriction = _objectWithoutPropertiesLoose(payload, _excluded311);
        setEmailDomainRestrictionsState({
          saving: true,
          error: null
        });
        const emailDomainRestrictionsState = store.auth.restrictionsState.emailDomainRestrictions;
        try {
          var _emailDomainRestricti2;
          await api2.auth.createDomainRestriction(newRestriction);
          const restrictions = await api2.auth.getDomainRestrictions();
          const filteredRestrictions = restrictions.items.filter((restriction) => {
            var _emailDomainRestricti;
            return restriction.type === ((_emailDomainRestricti = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti.config.listType);
          });
          setEmailDomainRestrictionsState({
            data: {
              config: ((_emailDomainRestricti2 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti2.config) || {
                active: false,
                blockPublicDomains: false,
                listType: newRestriction.type
              },
              restrictions: filteredRestrictions
            },
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setEmailDomainRestrictionsState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const saveEmailDomainRestrictionsConfig = async (payload) => {
        const {
          callback
        } = payload, config = _objectWithoutPropertiesLoose(payload, _excluded46);
        setEmailDomainRestrictionsState({
          saving: true,
          error: null
        });
        try {
          const updatedConfig = await api2.auth.updateDomainRestrictionConfig(config);
          const restrictions = await api2.auth.getDomainRestrictions();
          const filteredRestrictions = restrictions.items.filter((restriction) => restriction.type === updatedConfig.listType);
          setEmailDomainRestrictionsState({
            data: {
              config: updatedConfig,
              restrictions: filteredRestrictions
            },
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setEmailDomainRestrictionsState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const deleteEmailDomainRestriction = async (payload) => {
        const {
          id
        } = payload;
        setEmailDomainRestrictionsState({
          saving: true,
          error: null
        });
        const emailDomainRestrictionsState = store.auth.restrictionsState.emailDomainRestrictions;
        try {
          var _emailDomainRestricti4;
          await api2.auth.deleteDomainRestriction(id);
          const restrictions = await api2.auth.getDomainRestrictions();
          const filteredRestrictions = restrictions.items.filter((restriction) => {
            var _emailDomainRestricti3;
            return restriction.type === ((_emailDomainRestricti3 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti3.config.listType);
          });
          setEmailDomainRestrictionsState({
            data: {
              config: ((_emailDomainRestricti4 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti4.config) || {
                active: false,
                blockPublicDomains: false,
                listType: RestrictionType.ALLOW
              },
              restrictions: filteredRestrictions
            },
            saving: false
          });
        } catch (e) {
          setEmailDomainRestrictionsState({
            saving: false,
            error: errorHandler(e)
          });
        }
      };
      const wrappedLoadIpRestrictions = __securityCenterSagaWrapper(loadIpRestrictions);
      const wrappedSaveIpRestriction = __securityCenterSagaWrapper(saveIpRestriction);
      const wrappedSaveIpRestrictionsConfig = __securityCenterSagaWrapper(saveIpRestrictionsConfig);
      const wrappedDeleteIpRestriction = __securityCenterSagaWrapper(deleteIpRestriction);
      const wrappedCheckIfUserIpValid = __securityCenterSagaWrapper(checkIfUserIpValid);
      const wrappedAddCurrentUserIpAndActivate = __securityCenterSagaWrapper(addCurrentUserIpAndActivate);
      const wrappedLoadEmailDomainRestrictions = __securityCenterSagaWrapper(loadEmailDomainRestrictions);
      const wrappedSaveEmailDomainRestriction = __securityCenterSagaWrapper(saveEmailDomainRestriction);
      const wrappedSaveEmailDomainRestrictionsConfig = __securityCenterSagaWrapper(saveEmailDomainRestrictionsConfig);
      const wrappedDeleteEmailDomainRestriction = __securityCenterSagaWrapper(deleteEmailDomainRestriction);
      return {
        // reducers
        setRestrictionsState,
        setIpRestrictionsState,
        setEmailDomainRestrictionsState,
        __securityCenterSagaWrapper,
        // actions
        loadIpRestrictions: wrappedLoadIpRestrictions,
        saveIpRestriction: wrappedSaveIpRestriction,
        saveIpRestrictionsConfig: wrappedSaveIpRestrictionsConfig,
        deleteIpRestriction: wrappedDeleteIpRestriction,
        checkIfUserIpValid: wrappedCheckIfUserIpValid,
        addCurrentUserIpAndActivate: wrappedAddCurrentUserIpAndActivate,
        loadEmailDomainRestrictions: wrappedLoadEmailDomainRestrictions,
        saveEmailDomainRestriction: wrappedSaveEmailDomainRestriction,
        saveEmailDomainRestrictionsConfig: wrappedSaveEmailDomainRestrictionsConfig,
        deleteEmailDomainRestriction: wrappedDeleteEmailDomainRestriction
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/Security/RestrictionsState/index.js
var init_RestrictionsState = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/RestrictionsState/index.js"() {
    init_state22();
    init_actions22();
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityCenterState/state.js
var initialState23, state_default23;
var init_state23 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityCenterState/state.js"() {
    init_proxy();
    initialState23 = {
      loaders: {},
      errors: {},
      recommendations: void 0,
      insights: void 0,
      hasSecurityChanges: false,
      score: 0,
      breachedPasswordUsersTable: {
        users: [],
        usersPageOffset: 0,
        totalUsersItems: 0,
        totalUsersPages: 0,
        queryParams: {
          _offset: 0,
          _limit: 10
        }
      },
      unenrolledMfaUsersTable: {
        users: [],
        usersPageOffset: 0,
        totalUsersItems: 0,
        totalUsersPages: 0,
        queryParams: {
          _offset: 0,
          _limit: 10
        }
      },
      inactiveUsersTable: {
        users: [],
        usersPageOffset: 0,
        totalUsersItems: 0,
        totalUsersPages: 0,
        queryParams: {
          _offset: 0,
          _limit: 10,
          _maxInactiveSeconds: 7776e3
        }
      }
    };
    state_default23 = (overrideState) => createProxy2(initialState23, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityCenterState/interfaces.js
var SecurityCenterStateKeys;
var init_interfaces42 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityCenterState/interfaces.js"() {
    (function(SecurityCenterStateKeys2) {
      SecurityCenterStateKeys2["RECOMMENDATIONS"] = "recommendations";
      SecurityCenterStateKeys2["INSIGHTS"] = "insights";
      SecurityCenterStateKeys2["SEND_BULK_RESET_BREACHED_PASSWORD_EMAILS"] = "sendBulkResetBreachedPasswordEmails";
      SecurityCenterStateKeys2["SEND_BREACHED_PASSWORD_EMAIL"] = "sendBreachedPasswordEmail";
      SecurityCenterStateKeys2["BREACHED_PASSWORD_USERS_TABLE"] = "breachedPasswordUsersTable";
      SecurityCenterStateKeys2["UNENROLLED_MFA_USERS_TABLE"] = "unenrolledMfaUsersTable";
      SecurityCenterStateKeys2["INACTIVE_USERS_TABLE"] = "inactiveUsersTable";
    })(SecurityCenterStateKeys || (SecurityCenterStateKeys = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityCenterState/actions.js
var _excluded47, actions_default23;
var init_actions23 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityCenterState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_interfaces42();
    init_rest_api();
    init_helpers();
    init_state23();
    _excluded47 = ["callback"];
    actions_default23 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __getUsersWithRoles = async (users) => {
        const usersIds = users.map((user) => user.id);
        const allRoles = await api2.roles.getRoles();
        const usersRoles = await api2.users.getUsersRoles({
          ids: usersIds
        });
        const usersWithRoles = users.map((user) => {
          var _usersRoles$find, _ref;
          const userRolesIds = usersRoles == null ? void 0 : (_usersRoles$find = usersRoles.find((role) => role.userId === user.id)) == null ? void 0 : _usersRoles$find.roleIds;
          return _extends({}, user, {
            roles: (_ref = userRolesIds == null ? void 0 : userRolesIds.map((roleId) => {
              var _allRoles$find;
              return (_allRoles$find = allRoles == null ? void 0 : allRoles.find((role) => role.id === roleId)) != null ? _allRoles$find : [];
            })) != null ? _ref : []
          });
        });
        return usersWithRoles;
      };
      const __loadUsersTableSecurityCenter = async (payload) => {
        var _ref2, _tableState$queryPara, _ref3, _tableState$queryPara2;
        const {
          key,
          tableState,
          updateStateKey,
          _offset: offset,
          _limit: limit,
          _preset,
          _email,
          _maxInactiveSeconds
        } = payload;
        setSecurityCenterStateError({
          key,
          value: false
        });
        setSecurityCenterStateLoader({
          key,
          value: true
        });
        const _offset = (_ref2 = offset != null ? offset : tableState == null ? void 0 : (_tableState$queryPara = tableState.queryParams) == null ? void 0 : _tableState$queryPara._offset) != null ? _ref2 : 0;
        const _limit = (_ref3 = limit != null ? limit : tableState == null ? void 0 : (_tableState$queryPara2 = tableState.queryParams) == null ? void 0 : _tableState$queryPara2._limit) != null ? _ref3 : 10;
        const tableStateQueryParams = _extends({
          _offset,
          _limit,
          _includeSubTenants: false,
          _preset,
          _maxInactiveSeconds
        }, !!_email && {
          _email
        });
        try {
          const {
            items: usersItems,
            _metadata: {
              totalItems,
              totalPages
            }
          } = await api2.users.getUsersV3(tableStateQueryParams);
          const partialTableObj = {
            totalUsersItems: totalItems,
            totalUsersPages: totalPages,
            usersPageOffset: _offset,
            queryParams: _extends({
              _offset,
              _limit,
              _maxInactiveSeconds
            }, !!_email && {
              _email
            })
          };
          if (usersItems.length) {
            const usersWithRoles = await __getUsersWithRoles(usersItems);
            actions.setSecurityCenterState({
              [updateStateKey]: _extends({
                users: usersWithRoles
              }, partialTableObj)
            });
          } else {
            setSecurityCenterState({
              [updateStateKey]: _extends({
                users: []
              }, partialTableObj)
            });
          }
        } catch (e) {
          setSecurityCenterStateError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setSecurityCenterStateLoader({
            key,
            value: false
          });
        }
      };
      const setSecurityCenterState = (state) => {
        Object.assign(store.auth.securityCenterState, state);
      };
      const resetSecurityCenterState = () => {
        deepResetState(store, ["auth", "securityCenterState"], initialState23);
      };
      const setSecurityCenterStateLoader = (payload) => {
        Object.assign(store.auth.securityCenterState, {
          loaders: _extends({}, store.auth.securityCenterState.loaders, {
            [payload.key]: payload.value
          })
        });
      };
      const setSecurityCenterStateError = (payload) => {
        Object.assign(store.auth.securityCenterState, {
          errors: _extends({}, store.auth.securityCenterState.errors, {
            [payload.key]: payload.value
          }),
          loaders: _extends({}, store.auth.securityCenterState.loaders, {
            [payload.key]: false
          })
        });
      };
      const loadRecommendations = async (payload) => {
        const key = SecurityCenterStateKeys.RECOMMENDATIONS;
        setSecurityCenterStateLoader({
          key,
          value: true
        });
        try {
          var _scoring$score;
          const {
            recommendations,
            scoring
          } = await retryIfNeeded2(() => api2.securityCenter.getRecommendations(), payload == null ? void 0 : payload.retryConfig);
          setSecurityCenterState({
            recommendations: recommendations.items,
            score: (_scoring$score = scoring == null ? void 0 : scoring.score) != null ? _scoring$score : 0
          });
        } catch (e) {
          setSecurityCenterStateError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setSecurityCenterStateLoader({
            key,
            value: false
          });
        }
      };
      const loadInsights = async (payload) => {
        const key = SecurityCenterStateKeys.INSIGHTS;
        setSecurityCenterStateLoader({
          key,
          value: true
        });
        try {
          const {
            insights
          } = await await retryIfNeeded2(() => api2.securityCenter.getInsights(), payload == null ? void 0 : payload.retryConfig);
          setSecurityCenterState({
            insights: insights.items
          });
        } catch (e) {
          setSecurityCenterStateError({
            key,
            value: errorHandler(e)
          });
        } finally {
          setSecurityCenterStateLoader({
            key,
            value: false
          });
        }
      };
      const sendResetBreachedPasswordEmail = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded47);
        const key = SecurityCenterStateKeys.SEND_BREACHED_PASSWORD_EMAIL;
        setSecurityCenterStateError({
          key,
          value: false
        });
        setSecurityCenterStateLoader({
          key,
          value: true
        });
        try {
          await api2.auth.forgotPassword(payload);
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSecurityCenterStateError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        } finally {
          setSecurityCenterStateLoader({
            key,
            value: false
          });
        }
      };
      const sendBulkResetBreachedPasswordEmails = async (payload) => {
        const {
          callback
        } = payload;
        const key = SecurityCenterStateKeys.SEND_BULK_RESET_BREACHED_PASSWORD_EMAILS;
        setSecurityCenterStateError({
          key,
          value: false
        });
        setSecurityCenterStateLoader({
          key,
          value: true
        });
        try {
          await api2.users.sendResetBreachedPasswordEmails();
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSecurityCenterStateError({
            key,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false);
        } finally {
          setSecurityCenterStateLoader({
            key,
            value: false
          });
        }
      };
      const loadBreachedPasswordUsers = async (payload) => {
        var _store$auth$securityC;
        const key = SecurityCenterStateKeys.BREACHED_PASSWORD_USERS_TABLE;
        const breachedPasswordUsersTable = (_store$auth$securityC = store.auth.securityCenterState) == null ? void 0 : _store$auth$securityC.breachedPasswordUsersTable;
        await __loadUsersTableSecurityCenter(_extends({
          key,
          updateStateKey: "breachedPasswordUsersTable",
          _preset: GetUsersFilterPreset.BREACHED_PASSWORDS,
          tableState: breachedPasswordUsersTable
        }, payload));
      };
      const loadUnenrolledMfaUsers = async (payload) => {
        var _store$auth$securityC2;
        const key = SecurityCenterStateKeys.UNENROLLED_MFA_USERS_TABLE;
        const unenrolledMfaUsersTable = (_store$auth$securityC2 = store.auth.securityCenterState) == null ? void 0 : _store$auth$securityC2.unenrolledMfaUsersTable;
        await __loadUsersTableSecurityCenter(_extends({
          key,
          updateStateKey: "unenrolledMfaUsersTable",
          _preset: GetUsersFilterPreset.MFA_UNENROLLED,
          tableState: unenrolledMfaUsersTable
        }, payload));
      };
      const loadInactiveUsers = async (payload) => {
        var _store$auth$securityC3;
        const key = SecurityCenterStateKeys.INACTIVE_USERS_TABLE;
        const inactiveUsersTable = (_store$auth$securityC3 = store.auth.securityCenterState) == null ? void 0 : _store$auth$securityC3.inactiveUsersTable;
        await __loadUsersTableSecurityCenter(_extends({
          key,
          updateStateKey: "inactiveUsersTable",
          _preset: GetUsersFilterPreset.INACTIVE,
          tableState: inactiveUsersTable
        }, payload));
      };
      const markSecurityCenterStateAsChanged = (changed = true) => {
        setSecurityCenterState({
          hasSecurityChanges: changed
        });
      };
      return {
        setSecurityCenterState,
        resetSecurityCenterState,
        setSecurityCenterStateLoader,
        setSecurityCenterStateError,
        loadRecommendations,
        loadInsights,
        sendResetBreachedPasswordEmail,
        sendBulkResetBreachedPasswordEmails,
        loadBreachedPasswordUsers,
        loadUnenrolledMfaUsers,
        loadInactiveUsers,
        markSecurityCenterStateAsChanged
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityCenterState/index.js
var init_SecurityCenterState = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityCenterState/index.js"() {
    init_state23();
    init_actions23();
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/state.js
var initialState24, state_default24;
var init_state24 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/state.js"() {
    init_proxy();
    initialState24 = {
      globalPolicy: {
        loading: true
      },
      publicPolicy: {
        loading: false
      },
      vendorMfaPolicy: {
        loading: true
      },
      mfaPolicy: {
        loading: true
      },
      vendorLockoutPolicy: {
        loading: true
      },
      lockoutPolicy: {
        loading: true
      },
      captchaPolicy: {
        loading: true
      },
      passwordHistoryPolicy: {
        loading: true
      },
      passwordPolicy: {
        loading: true
      },
      vendorPasswordHistoryPolicy: {
        loading: true
      },
      publicAuthStrategyPolicy: {
        loading: true
      },
      passwordRotationPolicy: {
        loading: true
      }
    };
    state_default24 = (overrideState) => createProxy2(initialState24, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/helpers/helpers.js
function getTenantRotationPeriod(vendorRotationPeriod, tenantRotationPeriod) {
  const tenantRotationExists = tenantRotationPeriod !== null && tenantRotationPeriod !== void 0;
  const vendorRotationExists = vendorRotationPeriod !== null && vendorRotationPeriod !== void 0;
  if (!tenantRotationExists && !vendorRotationExists) {
    return;
  }
  if (!tenantRotationExists) {
    return vendorRotationPeriod;
  }
  if (!vendorRotationExists) {
    return tenantRotationPeriod;
  }
  return Math.min(vendorRotationPeriod, tenantRotationPeriod);
}
var init_helpers8 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/helpers/helpers.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/actions.js
var _excluded48, _excluded217, _excluded312, _excluded49, actions_default24;
var init_actions24 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_helpers();
    init_helpers8();
    init_state24();
    _excluded48 = ["callback"];
    _excluded217 = ["callback"];
    _excluded312 = ["callback"];
    _excluded49 = ["callback"];
    actions_default24 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __getSecurityPolicyPublicStateWithCustomLogin = async (securityPolicyPublicState, retryConfig) => {
        var _authStrategies$mainA, _authStrategies$mainA2;
        const isCustomLoginEnabled = await actions.customLoginEnabled();
        if (!isCustomLoginEnabled) {
          return securityPolicyPublicState;
        }
        const authStrategies = await __getAuthStrategy(retryConfig);
        if (!(authStrategies != null && (_authStrategies$mainA = authStrategies.mainAuthStrategies) != null && (_authStrategies$mainA2 = _authStrategies$mainA[0]) != null && _authStrategies$mainA2.strategy)) {
          return securityPolicyPublicState;
        }
        return _extends({}, securityPolicyPublicState, {
          authStrategy: authStrategies.mainAuthStrategies[0].strategy
        });
      };
      const __getAuthStrategy = async (retryConfig) => {
        const isAuthenticated = store.auth.isAuthenticated;
        let policy;
        if (isAuthenticated) {
          policy = await retryIfNeeded2(api2.auth.getPublicAuthStrategiesConfigForAuthenticatedUser, retryConfig);
        } else {
          policy = await retryIfNeeded2(api2.auth.getVendorPublicAuthStrategiesConfig, retryConfig);
        }
        return policy;
      };
      const __setSecurityPolicyPublicStateForCustomLogin = async (authStrategy) => {
        var _store$auth$securityP, _store$auth$securityP2;
        const isCustomLoginEnabled = await actions.customLoginEnabled();
        if (!authStrategy || !isCustomLoginEnabled) {
          return;
        }
        const {
          policy
        } = (_store$auth$securityP = (_store$auth$securityP2 = store.auth.securityPolicyState) == null ? void 0 : _store$auth$securityP2.publicPolicy) != null ? _store$auth$securityP : {
          policy: null
        };
        setSecurityPolicyPublicState({
          policy: _extends({}, policy, {
            authStrategy
          }),
          loading: false
        });
      };
      const setSecurityPolicyState = (state) => {
        Object.assign(store.auth.securityPolicyState, state);
      };
      const setSecurityPolicyGlobalState = (state) => {
        Object.assign(store.auth.securityPolicyState.globalPolicy, state);
      };
      const setSecurityPolicyPublicState = (state) => {
        Object.assign(store.auth.securityPolicyState.publicPolicy, state);
      };
      const setSecurityPolicyMfaState = (state) => {
        Object.assign(store.auth.securityPolicyState.mfaPolicy, state);
      };
      const setSecurityPolicyVendorMfaState = (state) => {
        Object.assign(store.auth.securityPolicyState.vendorMfaPolicy, state);
      };
      const setSecurityPolicyLockoutState = (state) => {
        Object.assign(store.auth.securityPolicyState.lockoutPolicy, state);
      };
      const setSecurityPolicyVendorLockoutState = (state) => {
        Object.assign(store.auth.securityPolicyState.vendorLockoutPolicy, state);
      };
      const setSecurityPolicyCaptchaState = (state) => {
        Object.assign(store.auth.securityPolicyState.captchaPolicy, state);
      };
      const setSecurityPolicyPasswordHistoryState = (state) => {
        Object.assign(store.auth.securityPolicyState.passwordHistoryPolicy, state);
      };
      const setSecurityPolicyVendorPasswordHistoryState = (state) => {
        Object.assign(store.auth.securityPolicyState.vendorPasswordHistoryPolicy, state);
      };
      const setSecurityPolicyPasswordRotationState = (state) => {
        Object.assign(store.auth.securityPolicyState.passwordRotationPolicy, state);
      };
      const setSecurityPolicyPasswordState = (state) => {
        Object.assign(store.auth.securityPolicyState.passwordPolicy, state);
      };
      const setSecurityPolicyAuthStrategyPublicState = (state) => {
        Object.assign(store.auth.securityPolicyState.publicAuthStrategyPolicy, state);
      };
      const resetSecurityPolicyState = () => {
        deepResetState(store, ["auth", "securityPolicyState"], initialState24);
      };
      const loadSecurityPolicy = async (payload) => {
        const actionPayload = {
          retryConfig: payload == null ? void 0 : payload.retryConfig
        };
        await Promise.all([
          // this request tend to fail with 403 so no retry
          loadGlobalSecurityPolicy(),
          // this request tend to fail with 404 when mfa policy is missing
          loadSecurityPolicyMfa(),
          loadSecurityPolicyVendorMfa(actionPayload),
          loadSecurityPolicyLockout(actionPayload),
          // this request tend to fail with 403 so no retry
          loadSecurityPolicyVendorLockout(actionPayload),
          loadSecurityPolicyVendorPasswordHistory(),
          loadSecurityPolicyCaptcha(actionPayload),
          loadPublicAuthStrategiesPolicy(actionPayload)
        ]);
      };
      const loadGlobalSecurityPolicy = async (payload) => {
        setSecurityPolicyGlobalState({
          loading: true,
          error: null
        });
        try {
          const policy = await retryIfNeeded2(() => api2.auth.getGlobalSecurityPolicy(), payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyGlobalState({
            policy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyGlobalState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadPublicSecurityPolicy = async (payload) => {
        setSecurityPolicyPublicState({
          loading: true,
          error: null
        });
        try {
          const policy = await api2.auth.getVendorConfig();
          const policyWithCustomLoginAuthStrategy = await __getSecurityPolicyPublicStateWithCustomLogin(policy, payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyPublicState({
            policy: policyWithCustomLoginAuthStrategy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyPublicState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadVendorPasswordConfig = async (payload) => {
        setSecurityPolicyPasswordState({
          loading: true,
          error: null
        });
        try {
          var _payload$callback;
          const policy = await retryIfNeeded2(() => api2.auth.getPasswordConfigPolicy(), payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyPasswordState({
            policy,
            loading: false
          });
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, policy);
        } catch (e) {
          var _payload$callback2;
          setSecurityPolicyPasswordState({
            error: errorHandler(e),
            loading: false
          });
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
        }
      };
      const loadSecurityPolicyMfa = async (payload) => {
        setSecurityPolicyMfaState({
          loading: true,
          error: null
        });
        try {
          const policy = await retryIfNeeded2(() => api2.auth.getMfaPolicy(), payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyMfaState({
            policy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyMfaState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadSecurityPolicyVendorMfa = async (payload) => {
        setSecurityPolicyMfaState({
          loading: true,
          error: null
        });
        try {
          const policy = await retryIfNeeded2(() => api2.auth.getVendorMfaPolicy(), payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyVendorMfaState({
            policy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyVendorMfaState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadSecurityPolicyLockout = async (payload) => {
        setSecurityPolicyLockoutState({
          loading: true,
          error: null
        });
        try {
          const policy = await retryIfNeeded2(() => api2.auth.getLockoutPolicy(), payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyLockoutState({
            policy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyLockoutState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadSecurityPolicyVendorLockout = async (payload) => {
        setSecurityPolicyVendorLockoutState({
          loading: true,
          error: null
        });
        try {
          const policy = await retryIfNeeded2(() => api2.auth.getVendorLockoutPolicy(), payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyVendorLockoutState({
            policy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyVendorLockoutState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadSecurityPolicyCaptcha = async (payload) => {
        setSecurityPolicyLockoutState({
          loading: true,
          error: null
        });
        try {
          const policy = await retryIfNeeded2(() => api2.auth.getCaptchaPolicy(), payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyCaptchaState({
            policy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyCaptchaState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadSecurityPolicyPasswordHistory = async () => {
        setSecurityPolicyPasswordHistoryState({
          loading: true,
          error: null
        });
        try {
          const policy = await api2.auth.getPasswordHistoryPolicy();
          setSecurityPolicyPasswordHistoryState({
            policy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyPasswordHistoryState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadSecurityPolicyVendorPasswordHistory = async (payload) => {
        setSecurityPolicyVendorPasswordHistoryState({
          loading: true,
          error: null
        });
        try {
          const policy = await retryIfNeeded2(() => api2.auth.getVendorPasswordHistoryPolicy(), payload == null ? void 0 : payload.retryConfig);
          setSecurityPolicyVendorPasswordHistoryState({
            policy,
            loading: false
          });
        } catch (e) {
          setSecurityPolicyVendorPasswordHistoryState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadSecurityPolicyPasswordRotation = async () => {
        setSecurityPolicyPasswordRotationState({
          loading: true,
          error: null
        });
        try {
          const tenantPasswordRotationConfig = await api2.securityPolicy.getPasswordRotationPolicy();
          const vendorPasswordRotationConfig = await api2.securityPolicy.getVendorPasswordRotationPolicy();
          const data = {
            passwordRotationVendorConfig: vendorPasswordRotationConfig
          };
          if (tenantPasswordRotationConfig) {
            if (vendorPasswordRotationConfig != null && vendorPasswordRotationConfig.isActive) {
              data.passwordRotationTenantConfig = tenantPasswordRotationConfig != null && tenantPasswordRotationConfig.isActive ? _extends({}, tenantPasswordRotationConfig, {
                rotationPeriod: getTenantRotationPeriod(vendorPasswordRotationConfig.rotationPeriod, tenantPasswordRotationConfig.rotationPeriod)
              }) : vendorPasswordRotationConfig;
            } else {
              data.passwordRotationTenantConfig = tenantPasswordRotationConfig;
            }
          }
          setSecurityPolicyPasswordRotationState({
            policy: _extends({}, data),
            loading: false
          });
        } catch (e) {
          setSecurityPolicyPasswordRotationState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadPublicAuthStrategiesPolicy = async (payload) => {
        setSecurityPolicyAuthStrategyPublicState({
          loading: true,
          error: null
        });
        try {
          var _policy$mainAuthStrat, _policy$mainAuthStrat2, _payload$callback3;
          const policy = await __getAuthStrategy(payload == null ? void 0 : payload.retryConfig);
          await __setSecurityPolicyPublicStateForCustomLogin(policy == null ? void 0 : (_policy$mainAuthStrat = policy.mainAuthStrategies) == null ? void 0 : (_policy$mainAuthStrat2 = _policy$mainAuthStrat[0]) == null ? void 0 : _policy$mainAuthStrat2.strategy);
          setSecurityPolicyAuthStrategyPublicState({
            policy,
            loading: false
          });
          payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, policy);
        } catch (e) {
          var _payload$callback4;
          setSecurityPolicyAuthStrategyPublicState({
            error: errorHandler(e),
            loading: false
          });
          payload == null ? void 0 : (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, null, e);
        }
      };
      const saveSecurityPolicyMfa = async (payload) => {
        const {
          callback
        } = payload, newSecurityPolicy = _objectWithoutPropertiesLoose(payload, _excluded48);
        setSecurityPolicyMfaState({
          saving: true,
          error: null
        });
        try {
          const policy = await api2.auth.securityPolicy.saveMfaPolicy(newSecurityPolicy);
          setSecurityPolicyMfaState({
            policy,
            saving: false
          });
          callback == null ? void 0 : callback(policy);
        } catch (e) {
          setSecurityPolicyMfaState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const saveSecurityPolicyLockout = async (payload) => {
        const {
          callback
        } = payload, newSecurityPolicy = _objectWithoutPropertiesLoose(payload, _excluded217);
        setSecurityPolicyLockoutState({
          saving: true,
          error: null
        });
        try {
          const policy = await api2.auth.saveLockoutPolicy(newSecurityPolicy);
          setSecurityPolicyLockoutState({
            policy,
            saving: false
          });
          callback == null ? void 0 : callback(policy);
        } catch (e) {
          setSecurityPolicyLockoutState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const saveSecurityPolicyPasswordHistory = async (payload) => {
        const {
          callback
        } = payload, newSecurityPolicy = _objectWithoutPropertiesLoose(payload, _excluded312);
        setSecurityPolicyPasswordHistoryState({
          saving: true,
          error: null
        });
        try {
          const policy = await api2.auth.savePasswordHistoryPolicy(newSecurityPolicy);
          setSecurityPolicyPasswordHistoryState({
            policy,
            saving: false
          });
          callback == null ? void 0 : callback(policy);
        } catch (e) {
          setSecurityPolicyPasswordHistoryState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const saveSecurityPolicyPasswordRotation = async (payload) => {
        const {
          callback
        } = payload, newSecurityPolicy = _objectWithoutPropertiesLoose(payload, _excluded49);
        setSecurityPolicyPasswordRotationState({
          saving: true,
          error: null
        });
        try {
          await api2.securityPolicy.savePasswordRotationPolicy(newSecurityPolicy.passwordRotationTenantConfig || {});
          setSecurityPolicyPasswordRotationState({
            policy: newSecurityPolicy,
            saving: false
          });
          callback == null ? void 0 : callback(newSecurityPolicy);
        } catch (e) {
          setSecurityPolicyPasswordRotationState({
            saving: false,
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      return {
        // reducers
        setSecurityPolicyState,
        setSecurityPolicyGlobalState,
        setSecurityPolicyPublicState,
        setSecurityPolicyMfaState,
        setSecurityPolicyVendorMfaState,
        setSecurityPolicyLockoutState,
        setSecurityPolicyVendorLockoutState,
        setSecurityPolicyCaptchaState,
        setSecurityPolicyPasswordHistoryState,
        setSecurityPolicyVendorPasswordHistoryState,
        setSecurityPolicyPasswordRotationState,
        resetSecurityPolicyState,
        setSecurityPolicyPasswordState,
        setSecurityPolicyAuthStrategyPublicState,
        // actions
        loadSecurityPolicy,
        loadGlobalSecurityPolicy,
        loadPublicSecurityPolicy,
        loadVendorPasswordConfig,
        loadSecurityPolicyMfa,
        loadSecurityPolicyVendorMfa,
        loadSecurityPolicyLockout,
        loadSecurityPolicyVendorLockout,
        loadSecurityPolicyCaptcha,
        loadSecurityPolicyPasswordHistory,
        loadSecurityPolicyVendorPasswordHistory,
        loadSecurityPolicyPasswordRotation,
        loadPublicAuthStrategiesPolicy,
        saveSecurityPolicyMfa,
        saveSecurityPolicyLockout,
        saveSecurityPolicyPasswordHistory,
        saveSecurityPolicyPasswordRotation,
        // protected
        __getSecurityPolicyPublicStateWithCustomLogin
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/index.js
var init_SecurityPolicyState = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/index.js"() {
    init_state24();
    init_actions24();
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SessionsPolicyState/state.js
var initialState25, state_default25;
var init_state25 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SessionsPolicyState/state.js"() {
    init_proxy();
    initialState25 = {
      loading: false,
      configurations: {}
    };
    state_default25 = (overrideState) => createProxy2(initialState25, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SessionsPolicyState/actions.js
var _excluded50, actions_default25;
var init_actions25 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SessionsPolicyState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_helpers();
    init_state25();
    _excluded50 = ["callback"];
    actions_default25 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setSessionsPolicyState = (state) => {
        Object.assign(store.auth.sessionsPolicyState, state);
      };
      const resetSessionsPolicyState = () => {
        deepResetState(store, ["auth", "sessionsPolicyState"], initialState25);
      };
      const loadSessionsPolicy = async () => {
        setSessionsPolicyState({
          loading: true,
          error: null
        });
        try {
          const sessionsPolicy = await api2.auth.getSessionConfigurations();
          setSessionsPolicyState({
            configurations: sessionsPolicy,
            loading: false
          });
        } catch (e) {
          actions.setSessionsState({
            error: e,
            loading: false
          });
        }
      };
      const createOrUpdateSessionsPolicy = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded50);
        try {
          setSessionsPolicyState({
            loading: true,
            error: null
          });
          await api2.auth.createOrUpdateSessionConfigrations(body);
          await actions.loadSessionsPolicy();
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSessionsPolicyState({
            error: e,
            loading: false
          });
        }
      };
      return {
        setSessionsPolicyState,
        resetSessionsPolicyState,
        loadSessionsPolicy,
        createOrUpdateSessionsPolicy
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SessionsPolicyState/index.js
var init_SessionsPolicyState = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SessionsPolicyState/index.js"() {
    init_state25();
    init_actions25();
  }
});

// node_modules/@frontegg/redux-store/auth/SessionsState/state.js
var initialState26, state_default26;
var init_state26 = __esm({
  "node_modules/@frontegg/redux-store/auth/SessionsState/state.js"() {
    init_proxy();
    initialState26 = {
      loading: false,
      sessions: []
    };
    state_default26 = (overrideState) => createProxy2(initialState26, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/SessionsState/actions.js
var actions_default26;
var init_actions26 = __esm({
  "node_modules/@frontegg/redux-store/auth/SessionsState/actions.js"() {
    init_helpers();
    init_state26();
    actions_default26 = (store, api2, sharedActions) => {
      const setSessionsState = (state) => {
        Object.assign(store.auth.sessionsState, state);
      };
      const resetSessionsState = () => {
        deepResetState(store, ["auth", "sessionsState"], initialState26);
      };
      const loadUserSessions = async (payload) => {
        setSessionsState({
          loading: true,
          error: null
        });
        try {
          const sessions = await retryIfNeeded2(() => api2.auth.getCurrentUserSessions(), payload == null ? void 0 : payload.retryConfig);
          setSessionsState({
            sessions,
            loading: false
          });
        } catch (e) {
          setSessionsState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadCurrentUserSession = async () => {
        setSessionsState({
          loading: true,
          error: null
        });
        try {
          const session = await api2.auth.getCurrentUserSession();
          setSessionsState({
            currentSession: session,
            loading: false
          });
        } catch (e) {
          setSessionsState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const deleteUserSession = async (payload) => {
        const {
          id
        } = payload;
        setSessionsState({
          loading: true,
          error: null
        });
        try {
          await api2.auth.deleteSessionForUser(id);
          await loadUserSessions();
        } catch (e) {
          setSessionsState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const deleteAllUserSessions = async () => {
        setSessionsState({
          loading: true,
          error: null
        });
        try {
          await api2.auth.deleteAllSessionsForUser();
          await loadUserSessions();
        } catch (e) {
          setSessionsState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const revokeUserSessions = async (payload) => {
        const {
          callback,
          userId
        } = payload;
        setSessionsState({
          loading: true,
          error: null
        });
        try {
          await api2.auth.revokeSessionsForUser(userId);
          setSessionsState({
            loading: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSessionsState({
            error: errorHandler(e),
            loading: false
          });
          callback == null ? void 0 : callback(false);
        }
      };
      return {
        setSessionsState,
        resetSessionsState,
        loadUserSessions,
        loadCurrentUserSession,
        deleteUserSession,
        deleteAllUserSessions,
        revokeUserSessions
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/SessionsState/index.js
var init_SessionsState = __esm({
  "node_modules/@frontegg/redux-store/auth/SessionsState/index.js"() {
    init_state26();
    init_actions26();
  }
});

// node_modules/@frontegg/redux-store/auth/SignUpState/interfaces.js
var SignUpStage;
var init_interfaces43 = __esm({
  "node_modules/@frontegg/redux-store/auth/SignUpState/interfaces.js"() {
    (function(SignUpStage2) {
      SignUpStage2["SignUp"] = "SignUp";
      SignUpStage2["SignUpSuccess"] = "SignUpSuccess";
      SignUpStage2["VerifyPhone"] = "VerifyPhone";
    })(SignUpStage || (SignUpStage = {}));
  }
});

// node_modules/@frontegg/redux-store/auth/SignUpState/state.js
var initialState27, state_default27;
var init_state27 = __esm({
  "node_modules/@frontegg/redux-store/auth/SignUpState/state.js"() {
    init_interfaces43();
    init_proxy();
    init_rest_api();
    initialState27 = {
      loading: false,
      allowSignUps: false,
      allowNotVerifiedUsersLogin: false,
      firstLoad: true,
      stage: SignUpStage.SignUp,
      strategies: {
        [SignUpStrategyEnum.Email]: {
          enabled: true,
          required: true
        },
        [SignUpStrategyEnum.PhoneNumber]: {
          enabled: false,
          required: false
        }
      }
    };
    state_default27 = (overrideState) => createProxy2(initialState27, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/SignUpState/actions.js
var _excluded51, _excluded218, actions_default27;
var init_actions27 = __esm({
  "node_modules/@frontegg/redux-store/auth/SignUpState/actions.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_interfaces43();
    init_helpers();
    init_state27();
    init_rest_api();
    init_helpers5();
    init_interfaces30();
    init_gtm();
    init_constants3();
    init_toolkit();
    _excluded51 = ["events", "url"];
    _excluded218 = ["events", "url"];
    actions_default27 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const contextHolder = ContextHolder.for(store.root.appName);
      const setSignUpState = (state) => {
        Object.assign(store.auth.signUpState, state);
      };
      const resetSignUpState = () => {
        deepResetState(store, ["auth", "signUpState"], initialState27);
      };
      const resetSignUpStateSoft = () => {
        const {
          allowSignUps,
          allowNotVerifiedUsersLogin
        } = store.auth.signUpState;
        resetSignUpState();
        setSignUpState({
          allowSignUps,
          allowNotVerifiedUsersLogin
        });
      };
      const reportSignupCompletion = (payload, userId, tenantId, activationToken, events, authenticationType = AuthenticationTypes.PASSWORD) => {
        var _events$signUpComplet;
        const {
          email,
          name,
          companyName,
          phoneNumber,
          url
        } = payload;
        const signUpCompletePayload = {
          email,
          name,
          companyName,
          url,
          phoneNumber: phoneNumber || void 0,
          authenticationType,
          id: userId,
          tenantId,
          createdAt: /* @__PURE__ */ new Date(),
          activationToken
        };
        events == null ? void 0 : (_events$signUpComplet = events.signUpComplete) == null ? void 0 : _events$signUpComplet.call(events, signUpCompletePayload);
        reportGTMEvent(GTMEventAction.SIGNUP_COMPLETED, signUpCompletePayload);
      };
      const signUpUserWithPhoneNumber = async (_payload) => {
        const {
          events
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded51);
        setSignUpState({
          loading: true
        });
        if (!payload.phoneNumber) {
          throw new Error("Phone number is required for phone number signup");
        }
        try {
          var _store$auth$securityP, _grecaptcha, _grecaptcha$execute;
          const {
            routes,
            onRedirectTo
          } = store.auth;
          const {
            tenantId,
            userId,
            activationToken
          } = await api2.auth.signUpUserWithPhoneNumber(prepareIdentifiersForSignup(payload));
          if (!payload.invitationToken) {
            reportSignupCompletion(payload, userId, tenantId, activationToken, events, AuthenticationTypes.PHONE_NUMBER);
          }
          const {
            enabled: captchaEnabled,
            siteKey
          } = (_store$auth$securityP = store.auth.securityPolicyState.captchaPolicy.policy) != null ? _store$auth$securityP : {};
          const recaptchaToken = captchaEnabled && siteKey ? await ((_grecaptcha = window.grecaptcha) == null ? void 0 : (_grecaptcha$execute = _grecaptcha.execute) == null ? void 0 : _grecaptcha$execute.call(_grecaptcha, {
            action: "login"
          })) : "";
          actions.passwordlessPreLogin({
            recaptchaToken,
            phoneNumber: payload.phoneNumber,
            type: AuthStrategyEnum.SmsCode,
            callback: (success, error) => {
              if (!success && error) {
                throw error;
              }
              onRedirectTo(routes.loginUrl);
              actions.setLoginState({
                step: LoginStep.loginWithSmsOtc,
                phoneNumber: payload.phoneNumber
              });
            }
          });
        } catch (e) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          setSignUpState({
            error: errorHandler(e)
          });
        } finally {
          setSignUpState({
            loading: false
          });
        }
      };
      const signUpUser = async (_payload) => {
        const {
          events
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded218);
        setSignUpState({
          loading: true
        });
        const phoneNumberStrategy = store.auth.signUpState.strategies.phoneNumber;
        if (phoneNumberStrategy != null && phoneNumberStrategy.required && phoneNumberStrategy != null && phoneNumberStrategy.enabled && payload.phoneNumber) {
          return signUpUserWithPhoneNumber(_payload);
        }
        try {
          const {
            routes,
            onRedirectTo
          } = store.auth;
          const {
            shouldActivate,
            user,
            tenantId,
            userId,
            tenants = [],
            activeTenant,
            activationToken
          } = await api2.auth.signUpUser(prepareIdentifiersForSignup(payload));
          if (!payload.invitationToken) {
            reportSignupCompletion(payload, userId, tenantId, activationToken, events);
          }
          if (!shouldActivate && user && isMfaRequired(user, store.root.appName)) {
            const mfaRequiredState = await actions.getMfaRequiredState(user, DEFAULT_RETRY_CONFIG, true, payload.email);
            actions.setAuthState(mfaRequiredState);
            onRedirectTo(routes.loginUrl);
          } else if (shouldActivate && activationToken) {
            const searchParams = new URLSearchParams({
              userId: userId || "",
              token: activationToken || ""
            });
            const url = `${routes.activateWithOTCUrl}?${searchParams.toString()}`;
            setSignUpState({
              loading: false,
              shouldActivate,
              stage: SignUpStage.SignUpSuccess
            });
            onRedirectTo(url);
          } else {
            const tenantsState = store.auth.tenantsState;
            setSignUpState({
              loading: false,
              shouldActivate,
              stage: SignUpStage.SignUpSuccess
            });
            actions.setAuthState({
              user,
              isAuthenticated: !!(user != null && user.accessToken),
              tenantsState: _extends({}, tenantsState, {
                tenants,
                activeTenant
              })
            });
          }
        } catch (e) {
          contextHolder.setAccessToken(null);
          contextHolder.setUser(null);
          setSignUpState({
            error: errorHandler(e)
          });
        } finally {
          setSignUpState({
            loading: false
          });
        }
      };
      const loadAllowSignUps = async (payload) => {
        setSignUpState({
          loading: true
        });
        try {
          var _payload$callback;
          const policy = await retryIfNeeded2(api2.auth.getVendorConfig, payload == null ? void 0 : payload.retryConfig);
          const policyWithCustomLoginAuthStrategy = await actions.__getSecurityPolicyPublicStateWithCustomLogin(policy, payload == null ? void 0 : payload.retryConfig);
          const {
            allowSignups: allowSignUps,
            allowNotVerifiedUsersLogin
          } = policy;
          setSignUpState({
            loading: false,
            allowSignUps,
            allowNotVerifiedUsersLogin,
            firstLoad: false
          });
          actions.setSecurityPolicyPublicState({
            policy: policyWithCustomLoginAuthStrategy,
            loading: false
          });
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, policyWithCustomLoginAuthStrategy || policy);
        } catch (e) {
          var _payload$callback2;
          setSignUpState({
            loading: false,
            error: errorHandler(e),
            firstLoad: false
          });
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
        }
      };
      const loadSignUpStrategies = async () => {
        try {
          const strategies = await api2.auth.getSignUpStrategies();
          setSignUpState({
            strategies: strategies.reduce((acc, {
              isActive,
              strategy,
              isRequired
            }) => {
              acc[strategy] = {
                enabled: isActive,
                required: isRequired
              };
              return acc;
            }, {})
          });
        } catch (error) {
        }
      };
      return {
        setSignUpState,
        resetSignUpState,
        resetSignUpStateSoft,
        signUpUser,
        signUpUserWithPhoneNumber,
        loadAllowSignUps,
        loadSignUpStrategies
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/SignUpState/index.js
var init_SignUpState = __esm({
  "node_modules/@frontegg/redux-store/auth/SignUpState/index.js"() {
    init_state27();
    init_actions27();
  }
});

// node_modules/@frontegg/redux-store/auth/SmsState/state.js
var initialState28, state_default28;
var init_state28 = __esm({
  "node_modules/@frontegg/redux-store/auth/SmsState/state.js"() {
    init_proxy();
    initialState28 = {
      loading: false,
      error: null,
      phoneNumbers: void 0
    };
    state_default28 = (overrideState) => createProxy2(initialState28, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/SmsState/actions.js
var _excluded56, _excluded219, _excluded313, _excluded410, _excluded57, _excluded66, actions_default28;
var init_actions28 = __esm({
  "node_modules/@frontegg/redux-store/auth/SmsState/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_helpers();
    init_state28();
    _excluded56 = ["callback"];
    _excluded219 = ["callback"];
    _excluded313 = ["callback"];
    _excluded410 = ["callback", "phoneId"];
    _excluded57 = ["callback", "phoneId"];
    _excluded66 = ["callback"];
    actions_default28 = (store, api2, sharedActions) => {
      const setSmsState = (state) => {
        Object.assign(store.auth.smsState, state);
      };
      const resetSmsState = () => {
        deepResetState(store, ["auth", "smsState"], initialState28);
      };
      const loadPhoneNumbers = async () => {
        setSmsState({
          loading: true
        });
        const queryParams = {
          _limit: 10,
          _offset: 0
        };
        try {
          const {
            items
          } = await api2.userPhoneNumbers.getUserPhoneNumbers(queryParams);
          setSmsState({
            phoneNumbers: items
          });
        } catch (e) {
          setSmsState({
            error: errorHandler(e)
          });
        } finally {
          setSmsState({
            loading: false
          });
        }
      };
      const loadUserOwnPhoneNumbers = async () => {
        setSmsState({
          loading: true
        });
        try {
          const phoneNumbers = await api2.userPhoneNumbers.getUserOwnPhoneNumbers();
          setSmsState({
            phoneNumbers
          });
        } catch (e) {
          setSmsState({
            error: errorHandler(e)
          });
        } finally {
          setSmsState({
            loading: false
          });
        }
      };
      const setUpOwnPhoneNumber = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded56);
        try {
          const {
            otcToken
          } = await api2.userPhoneNumbers.createPhoneNumber(payload);
          setSmsState({
            otcToken
          });
          await loadUserOwnPhoneNumbers();
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSmsState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      const setUpPhoneNumber = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded219);
        try {
          const {
            otcToken
          } = await api2.userPhoneNumbers.createPhoneNumber(payload);
          setSmsState({
            otcToken
          });
          await loadPhoneNumbers();
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSmsState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      const verifyPhoneNumber = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded313);
        setSmsState({
          loading: true
        });
        try {
          await api2.userPhoneNumbers.verifyPhoneNumber(payload);
          await loadPhoneNumbers();
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSmsState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        } finally {
          setSmsState({
            loading: false
          });
        }
      };
      const deletePhoneNumber = async (_payload) => {
        const {
          callback,
          phoneId
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded410);
        setSmsState({
          loading: true
        });
        try {
          const {
            otcToken
          } = await api2.userPhoneNumbers.deletePhoneNumber(phoneId);
          setSmsState({
            otcToken
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSmsState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        } finally {
          setSmsState({
            loading: false
          });
        }
      };
      const verifyDeletePhoneNumber = async (_payload) => {
        const {
          callback,
          phoneId
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded57);
        setSmsState({
          loading: true
        });
        try {
          await api2.userPhoneNumbers.verifyDeletePhoneNumber(phoneId, payload);
          await loadPhoneNumbers();
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSmsState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        } finally {
          setSmsState({
            loading: false
          });
        }
      };
      const preVerifyPhoneNumber = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded66);
        setSmsState({
          loading: true
        });
        try {
          const {
            otcToken
          } = await api2.userPhoneNumbers.preVerifyPhoneNumber(payload);
          setSmsState({
            otcToken
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSmsState({
            error: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        } finally {
          setSmsState({
            loading: false
          });
        }
      };
      return {
        setSmsState,
        resetSmsState,
        loadPhoneNumbers,
        loadUserOwnPhoneNumbers,
        setUpPhoneNumber,
        setUpOwnPhoneNumber,
        verifyPhoneNumber,
        deletePhoneNumber,
        verifyDeletePhoneNumber,
        preVerifyPhoneNumber
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/SmsState/index.js
var init_SmsState = __esm({
  "node_modules/@frontegg/redux-store/auth/SmsState/index.js"() {
    init_state28();
    init_actions28();
  }
});

// node_modules/@frontegg/redux-store/auth/SocialLoginState/state.js
var initialState29, state_default29;
var init_state29 = __esm({
  "node_modules/@frontegg/redux-store/auth/SocialLoginState/state.js"() {
    init_proxy();
    initialState29 = {
      firstLoad: true,
      loading: false,
      error: ""
    };
    state_default29 = (overrideState) => createProxy2(initialState29, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/SocialLoginState/actions.js
var _excluded58, _excluded220, actions_default29;
var init_actions29 = __esm({
  "node_modules/@frontegg/redux-store/auth/SocialLoginState/actions.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_helpers();
    init_state29();
    init_interfaces30();
    init_gtm();
    _excluded58 = ["authorizationUrl"];
    _excluded220 = ["events", "url"];
    actions_default29 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __getSocialLoginsConfigurationsV2 = async (retryConfig) => {
        const isAuthenticated = store.auth.isAuthenticated;
        let socialLoginsConfigV2;
        if (isAuthenticated) {
          socialLoginsConfigV2 = await retryIfNeeded2(api2.auth.getSocialLoginProvidersV2ForAuthenticatedUser, retryConfig);
        } else {
          socialLoginsConfigV2 = await retryIfNeeded2(api2.auth.getSocialLoginProvidersV2, retryConfig);
        }
        return socialLoginsConfigV2;
      };
      const setSocialLoginsState = (state) => {
        Object.assign(store.auth.socialLoginState, state);
      };
      const resetSocialLoginsState = () => {
        deepResetState(store, ["auth", "socialLoginState"], initialState29);
      };
      const setSocialLoginError = (payload) => {
        setSocialLoginsState({
          error: payload.error,
          loading: false,
          firstLoad: false
        });
      };
      const loadSocialLoginsConfiguration = async () => {
        try {
          setSocialLoginsState({
            loading: true
          });
          const socialLoginsConfig = await api2.auth.getSocialLoginProviders();
          setSocialLoginsState({
            socialLoginsConfig,
            loading: false,
            firstLoad: false
          });
        } catch (e) {
          setSocialLoginsState({
            error: errorHandler(e),
            loading: false,
            firstLoad: false
          });
        }
      };
      const loadSocialLoginsConfigurationV2 = async (payload) => {
        try {
          var _payload$callback;
          const context = store.root.context;
          setSocialLoginsState({
            loading: true
          });
          const socialLoginsConfigV2 = await __getSocialLoginsConfigurationsV2(payload == null ? void 0 : payload.retryConfig);
          const {
            providers: customSocialLoginsConfig
          } = await retryIfNeeded2(api2.auth.getCustomSocialLoginProvidersV1, payload == null ? void 0 : payload.retryConfig);
          const socialLoginsConfigWithFullUrl = socialLoginsConfigV2.map((_ref) => {
            let {
              authorizationUrl
            } = _ref, config = _objectWithoutPropertiesLoose(_ref, _excluded58);
            const baseUrl = api2.fetch.getBaseUrl(context, authorizationUrl != null ? authorizationUrl : "");
            return _extends({}, config, {
              authorizationUrl: authorizationUrl ? `${baseUrl}${authorizationUrl}` : null
            });
          });
          const newState = {
            socialLoginsConfigV2: socialLoginsConfigWithFullUrl,
            customSocialLoginsConfig,
            loading: false,
            firstLoad: false
          };
          setSocialLoginsState(newState);
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, newState);
        } catch (e) {
          var _payload$callback2;
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
          setSocialLoginsState({
            error: errorHandler(e),
            loading: false,
            firstLoad: false
          });
        }
      };
      const loginViaSocialLogin = async (_payload) => {
        const {
          events,
          url
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded220);
        try {
          setSocialLoginsState({
            loading: true
          });
          const {
            email,
            isNewUser,
            userId,
            tenantId,
            name
          } = await api2.auth.loginViaSocialLogin(payload);
          if (isNewUser) {
            var _events$signUpComplet, _events$userVerified;
            const basePayload = {
              email,
              url,
              createdAt: /* @__PURE__ */ new Date(),
              id: userId,
              tenantId
            };
            const signUpCompletePayload = _extends({}, basePayload, {
              socialProvider: payload.provider,
              authenticationType: AuthenticationTypes.SOCIAL_LOGIN
            });
            events == null ? void 0 : (_events$signUpComplet = events.signUpComplete) == null ? void 0 : _events$signUpComplet.call(events, signUpCompletePayload);
            reportGTMEvent(GTMEventAction.SIGNUP_COMPLETED, signUpCompletePayload);
            const userVerifiedPayload = _extends({}, basePayload, {
              origin: UserVerifiedOriginTypes.SOCIAL_LOGIN,
              name
            });
            events == null ? void 0 : (_events$userVerified = events.userVerified) == null ? void 0 : _events$userVerified.call(events, userVerifiedPayload);
            reportGTMEvent(GTMEventAction.USER_VERIFIED, userVerifiedPayload);
          }
          if (userId) {
            localStorage.setItem("userId", userId);
          }
          actions.setLoginState({
            email,
            isNewUser
          });
          actions.refreshTokenForSocialLogins();
          localStorage.removeItem("register-quick-login");
          setSocialLoginsState({
            loading: false
          });
        } catch (e) {
          setSocialLoginsState({
            loading: false,
            error: errorHandler(e, "Failed to authenticate"),
            firstLoad: false
          });
        }
      };
      return {
        setSocialLoginsState,
        resetSocialLoginsState,
        setSocialLoginError,
        loadSocialLoginsConfiguration,
        loadSocialLoginsConfigurationV2,
        loginViaSocialLogin
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/SocialLoginState/index.js
var init_SocialLoginState = __esm({
  "node_modules/@frontegg/redux-store/auth/SocialLoginState/index.js"() {
    init_state29();
    init_actions29();
  }
});

// node_modules/@frontegg/redux-store/auth/SSOState/state.js
var initialState30, state_default30;
var init_state30 = __esm({
  "node_modules/@frontegg/redux-store/auth/SSOState/state.js"() {
    init_proxy();
    initialState30 = {
      firstLoad: true,
      loading: true,
      saving: false,
      errors: {},
      loaders: {},
      ssoConfigurations: []
    };
    state_default30 = (overrideState) => createProxy2(initialState30, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/SSOState/actions/actions.v1.js
var _excluded59, actions_v1_default;
var init_actions_v1 = __esm({
  "node_modules/@frontegg/redux-store/auth/SSOState/actions/actions.v1.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_interfaces38();
    init_helpers();
    init_state30();
    _excluded59 = ["callback", "samlVendor"];
    actions_v1_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __getAuthorizationRoles = async () => {
        try {
          const data = await api2.auth.getSamlRoles();
          const groupsData = await api2.auth.getSamlRolesGroups();
          setSSOState({
            authorizationRoles: data.roleIds,
            rolesGroups: groupsData,
            error: void 0
          });
        } catch (e) {
          setSSOState({
            error: errorHandler(e)
          });
        }
      };
      const __updateRolesGroups = async (groups) => {
        try {
          await Promise.all(groups.map((group) => api2.auth.updateSamlGroup({
            id: group.id,
            roleIds: group.roleIds,
            group: group.group
          })));
        } catch (e) {
          setSSOState({
            error: errorHandler(e)
          });
        }
      };
      const setSSOState = (state) => {
        Object.assign(store.auth.ssoState, state);
      };
      const resetSSOState = () => {
        deepResetState(store, ["auth", "ssoState"], initialState30);
      };
      const setSSOLoader = (payload) => {
        Object.assign(store.auth.ssoState, {
          loaders: _extends({}, store.auth.ssoState.loaders, {
            [payload.key]: payload.value
          })
        });
      };
      const setSSOError = (payload) => {
        Object.assign(store.auth.ssoState, {
          errors: _extends({}, store.auth.ssoState.errors, {
            [payload.key]: payload.value
          }),
          loaders: _extends({}, store.auth.ssoState.loaders, {
            [payload.key]: false
          })
        });
      };
      const loadSSOConfigurations = async () => {
        try {
          var _samlMetadata$configu, _samlMetadata$configu2;
          setSSOState({
            loading: true
          });
          const samlConfiguration = await api2.auth.getSamlConfiguration();
          const oidcConfiguration = await api2.auth.getOidcConfiguration();
          const samlMetadata = await api2.metadata.getSamlMetadata();
          samlConfiguration.acsUrl = samlMetadata == null ? void 0 : (_samlMetadata$configu = samlMetadata.configuration) == null ? void 0 : _samlMetadata$configu.acsUrl;
          samlConfiguration.spEntityId = samlMetadata == null ? void 0 : (_samlMetadata$configu2 = samlMetadata.configuration) == null ? void 0 : _samlMetadata$configu2.spEntityId;
          samlConfiguration.isSamlActive = samlMetadata == null ? void 0 : samlMetadata.isActive;
          setSSOState({
            samlConfiguration,
            oidcConfiguration,
            loading: false,
            firstLoad: false
          });
        } catch (e) {
          setSSOState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      const loadSSOAuthorizationRoles = async () => {
        try {
          const data = await api2.auth.getSamlRoles();
          const groupsData = await api2.auth.getSamlRolesGroups();
          setSSOState({
            authorizationRoles: data.roleIds,
            rolesGroups: groupsData,
            error: void 0
          });
        } catch (e) {
          setSSOState({
            error: errorHandler(e)
          });
        }
      };
      const saveSSOConfigurations = async (payload) => {
        const {
          callback,
          samlVendor
        } = payload, newSamlConfiguration = _objectWithoutPropertiesLoose(payload, _excluded59);
        const oldSamlConfiguration = store.auth.ssoState.samlConfiguration;
        const samlConfiguration = _extends({}, oldSamlConfiguration, newSamlConfiguration);
        let loaderKey = "saving";
        if ((samlConfiguration == null ? void 0 : samlConfiguration.enabled) !== (oldSamlConfiguration == null ? void 0 : oldSamlConfiguration.enabled)) {
          loaderKey = "loading";
        }
        try {
          const firstTimeConfigure = !(samlConfiguration != null && samlConfiguration.domain);
          if (firstTimeConfigure) {
            setSSOState({
              samlConfiguration: _extends({}, oldSamlConfiguration, samlConfiguration)
            });
            return;
          } else {
            setSSOState({
              error: void 0,
              [loaderKey]: true
            });
          }
          if (payload.type === SamlVendors.Saml) {
            var _samlMetadata$configu3, _samlMetadata$configu4;
            const samlMetadata = await api2.metadata.getSamlMetadata();
            samlConfiguration.acsUrl = samlMetadata == null ? void 0 : (_samlMetadata$configu3 = samlMetadata.configuration) == null ? void 0 : _samlMetadata$configu3.acsUrl;
            samlConfiguration.spEntityId = samlMetadata == null ? void 0 : (_samlMetadata$configu4 = samlMetadata.configuration) == null ? void 0 : _samlMetadata$configu4.spEntityId;
          }
          const updateSamlConfiguration = omitProps(samlConfiguration, ["validated", "generatedVerification", "createdAt", "updatedAt"]);
          if ((oldSamlConfiguration == null ? void 0 : oldSamlConfiguration.domain) !== (updateSamlConfiguration == null ? void 0 : updateSamlConfiguration.domain)) {
            updateSamlConfiguration.ssoEndpoint = "";
            updateSamlConfiguration.publicCertificate = "";
            updateSamlConfiguration.signRequest = false;
          }
          updateSamlConfiguration.type = samlVendor == null ? void 0 : samlVendor.toLowerCase();
          const newSamlConfiguration2 = await api2.auth.updateSamlConfiguration(updateSamlConfiguration);
          newSamlConfiguration2.isSamlActive = oldSamlConfiguration == null ? void 0 : oldSamlConfiguration.isSamlActive;
          setSSOState({
            samlConfiguration: newSamlConfiguration2,
            error: void 0,
            [loaderKey]: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSSOState({
            samlConfiguration: oldSamlConfiguration,
            error: errorHandler(e),
            [loaderKey]: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const saveSSOConfigurationsFile = async (configFile) => {
        const oldSamlConfiguration = store.auth.ssoState.samlConfiguration;
        const loaderKey = "saving";
        setSSOState({
          error: void 0,
          [loaderKey]: true
        });
        try {
          const metadata = await readFileAsText(configFile[0]);
          const newSamlConfiguration = await api2.auth.updateSamlVendorMetadata({
            metadata
          });
          newSamlConfiguration.isSamlActive = oldSamlConfiguration == null ? void 0 : oldSamlConfiguration.isSamlActive;
          setSSOState({
            samlConfiguration: newSamlConfiguration,
            error: void 0,
            [loaderKey]: false
          });
        } catch (e) {
          setSSOState({
            samlConfiguration: oldSamlConfiguration,
            error: errorHandler(e),
            [loaderKey]: false
          });
        }
      };
      const saveSSOConfigurationsFileWithCallback = async (payload) => {
        const {
          configFile,
          callback
        } = payload;
        const oldSamlConfiguration = store.auth.ssoState.samlConfiguration;
        const loaderKey = "saving";
        setSSOState({
          error: void 0,
          [loaderKey]: true
        });
        try {
          const metadata = await readFileAsText(configFile);
          const newSamlConfiguration = await api2.auth.updateSamlVendorMetadata({
            metadata
          });
          newSamlConfiguration.isSamlActive = oldSamlConfiguration == null ? void 0 : oldSamlConfiguration.isSamlActive;
          setSSOState({
            samlConfiguration: newSamlConfiguration,
            error: void 0,
            [loaderKey]: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSSOState({
            samlConfiguration: oldSamlConfiguration,
            error: errorHandler(e),
            [loaderKey]: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const validateSSODomain = async (payload) => {
        const {
          callback
        } = payload != null ? payload : {};
        const samlConfiguration = store.auth.ssoState.samlConfiguration;
        if (!samlConfiguration) {
          const error = new Error("IllegalState: samlConfiguration is not defined");
          console.error(error);
          callback == null ? void 0 : callback(null, error);
          return;
        }
        try {
          setSSOState({
            error: void 0,
            saving: true
          });
          await api2.auth.validateSamlDomain();
          setSSOState({
            samlConfiguration: _extends({}, samlConfiguration, {
              validated: true
            }),
            error: void 0,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSSOState({
            samlConfiguration: _extends({}, samlConfiguration, {
              validated: false
            }),
            error: errorHandler(e),
            saving: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const updateSSOAuthorizationRoles = async (payload) => {
        const {
          callback,
          authorizationRoles,
          groups
        } = payload;
        try {
          setSSOState({
            error: void 0,
            saving: true
          });
          await api2.auth.updateSamlRoles({
            roleIds: authorizationRoles
          });
          if (groups) {
            await __updateRolesGroups(groups);
          }
          await __getAuthorizationRoles();
          setSSOState({
            error: void 0,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSSOState({
            error: errorHandler(e),
            saving: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const deleteSamlGroup = async (payload) => {
        const {
          id,
          callback
        } = payload;
        try {
          setSSOState({
            error: void 0,
            saving: true
          });
          await api2.auth.deleteSamlGroup({
            id
          });
          await __getAuthorizationRoles();
          setSSOState({
            error: void 0,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSSOState({
            error: errorHandler(e),
            saving: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const createSamlGroup = async (payload) => {
        const {
          group,
          roleIds,
          callback
        } = payload;
        try {
          setSSOState({
            error: void 0,
            saving: true
          });
          await api2.auth.createSamlGroup({
            group,
            roleIds
          });
          await __getAuthorizationRoles();
          setSSOState({
            error: void 0,
            saving: false
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          setSSOState({
            error: errorHandler(e),
            saving: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const oidcPostlogin = async (payload) => {
        const data = {
          code: payload.code,
          redirectUri: payload.redirectUri,
          RelayState: payload.state
        };
        try {
          setSSOState({
            loading: true
          });
          await api2.auth.oidcPostLoginV2(data);
          await actions.__refreshToken();
          setSSOState({
            loading: false
          });
        } catch (e) {
          setSSOState({
            loading: false,
            error: errorHandler(e, "Failed to authenticate"),
            firstLoad: false
          });
        }
      };
      return {
        //reducers,
        setSSOState,
        resetSSOState,
        setSSOLoader,
        setSSOError,
        //actions.v1
        loadSSOConfigurations,
        saveSSOConfigurations,
        saveSSOConfigurationsFile,
        saveSSOConfigurationsFileWithCallback,
        validateSSODomain,
        loadSSOAuthorizationRoles,
        updateSSOAuthorizationRoles,
        deleteSamlGroup,
        createSamlGroup,
        oidcPostlogin
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/SSOState/actions/actions.v2.js
var _excluded60, _excluded221, _excluded314, _excluded411, actions_v2_default;
var init_actions_v2 = __esm({
  "node_modules/@frontegg/redux-store/auth/SSOState/actions/actions.v2.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_interfaces38();
    init_helpers();
    _excluded60 = ["callback"];
    _excluded221 = ["callback", "ssoConfigId"];
    _excluded314 = ["callback", "ssoConfigId"];
    _excluded411 = ["callback", "ssoConfigId"];
    actions_v2_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __loadOidc = async (retryConfig) => {
        try {
          return await retryIfNeeded2(() => api2.auth.getOidcConfiguration(), retryConfig);
        } catch (e) {
          return null;
        }
      };
      const __loadSaml = async (retryConfig) => {
        try {
          return await retryIfNeeded2(() => api2.metadata.getSamlMetadata(), retryConfig);
        } catch (e) {
          return null;
        }
      };
      const __ssoTryCatch = async (key, callback, block) => {
        actions.setSSOLoader({
          key,
          value: true
        });
        try {
          await block();
        } catch (error) {
          actions.setSSOError({
            key,
            value: errorHandler(error)
          });
          callback == null ? void 0 : callback(null, error);
        } finally {
          actions.setSSOLoader({
            key,
            value: false
          });
        }
      };
      const loadSSOConfigurationsV2 = async (payload) => {
        await __ssoTryCatch(SSOStateKeys.LOAD_SSO_CONFIGURATIONS, void 0, async () => {
          const [oidcConfiguration, samlMetadata] = await Promise.all([__loadOidc(payload == null ? void 0 : payload.retryConfig), __loadSaml(payload == null ? void 0 : payload.retryConfig)]);
          const ssoConfigurations = await retryIfNeeded2(() => api2.auth.getSSOConfigurations(), payload == null ? void 0 : payload.retryConfig);
          actions.setSSOState({
            ssoConfigurations,
            oidcConfiguration,
            samlMetadata
          });
        });
      };
      const saveSSOConfigurationV2 = async (payload) => {
        const {
          callback
        } = payload, ssoConfiguration = _objectWithoutPropertiesLoose(payload, _excluded60);
        const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
        await __ssoTryCatch(SSOStateKeys.SAVE_SSO_CONFIGURATION, callback, async () => {
          var _ssoConfiguration$ena;
          const newSsoConfiguration = await api2.auth.createSSOConfiguration(_extends({}, ssoConfiguration, {
            enabled: (_ssoConfiguration$ena = ssoConfiguration.enabled) != null ? _ssoConfiguration$ena : false
          }));
          actions.setSSOState({
            ssoConfigurations: [...ssoConfigurations, newSsoConfiguration]
          });
          callback == null ? void 0 : callback(newSsoConfiguration);
        });
      };
      const updateSSOConfiguration = async (payload) => {
        const {
          callback,
          ssoConfigId
        } = payload, ssoConfiguration = _objectWithoutPropertiesLoose(payload, _excluded221);
        const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
        await __ssoTryCatch(SSOStateKeys.UPDATE_SSO_CONFIGURATION, callback, async () => {
          const newSsoConfiguration = await api2.auth.updateSSOConfiguration(ssoConfigId, ssoConfiguration);
          const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(newSsoConfiguration);
        });
      };
      const deleteSSOConfiguration = async (payload) => {
        const {
          ssoConfigId,
          callback
        } = payload;
        const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
        await __ssoTryCatch(SSOStateKeys.DELETE_SSO_CONFIGURATION, callback, async () => {
          await api2.auth.deleteSSOConfiguration(ssoConfigId);
          actions.setSSOState({
            ssoConfigurations: ssoConfigurations.filter(({
              id
            }) => id !== ssoConfigId)
          });
          callback == null ? void 0 : callback(true);
        });
      };
      const saveSSODomain = async (payload) => {
        const {
          callback,
          ssoConfigId
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded314);
        const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
        await __ssoTryCatch(SSOStateKeys.SAVE_SSO_DOMAIN, callback, async () => {
          const domain = await api2.auth.createSSODomain(ssoConfigId, body);
          const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
              return _extends({}, ssoConfig, {
                domains: [...ssoConfig.domains, domain]
              });
            }
            return ssoConfig;
          });
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(domain);
        });
      };
      const deleteSSODomain = async (payload) => {
        const {
          ssoConfigId,
          domainId,
          callback
        } = payload;
        const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
        await __ssoTryCatch(SSOStateKeys.DELETE_SSO_DOMAIN, callback, async () => {
          await api2.auth.deleteSSODomain(ssoConfigId, domainId);
          const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
              return _extends({}, ssoConfig, {
                domains: ssoConfig.domains.filter(({
                  id
                }) => id !== domainId)
              });
            }
            return ssoConfig;
          });
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(true);
        });
      };
      const validateSSODomainV2 = async (payload) => {
        const {
          callback,
          domainId,
          ssoConfigId
        } = payload;
        await __ssoTryCatch(SSOStateKeys.VALIDATE_SSO_DOMAIN, callback, async () => {
          const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
          await api2.auth.validateSSODomainV2(ssoConfigId, domainId);
          const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
              return _extends({}, ssoConfig, {
                domains: ssoConfig.domains.map((ssoDomain) => ssoDomain.id === domainId ? _extends({}, ssoDomain, {
                  validated: true
                }) : ssoDomain)
              });
            }
            return ssoConfig;
          });
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(true);
        });
      };
      const setSSODefaultRoles = async (payload) => {
        const {
          callback,
          ssoConfigId,
          roleIds
        } = payload;
        await __ssoTryCatch(SSOStateKeys.UPDATE_SSO_DEFAULT_ROLES, callback, async () => {
          const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
          await api2.auth.setSSODefaultRoles(ssoConfigId, {
            roleIds
          });
          const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
              return _extends({}, ssoConfig, {
                roleIds
              });
            }
            return ssoConfig;
          });
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(true);
        });
      };
      const setSSOGroups = async (payload) => {
        const {
          groupsToAdd,
          groupsToDelete,
          ssoConfigId,
          callback
        } = payload;
        await __ssoTryCatch(SSOStateKeys.SAVE_SSO_GROUPS, callback, async () => {
          const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
          await Promise.all(groupsToDelete.map((groupId) => api2.auth.deleteSSOGroup(ssoConfigId, groupId)));
          await Promise.all(groupsToAdd.map((group) => api2.auth.createSSOGroup(ssoConfigId, group)));
          const groups = await api2.auth.getSSOGroups(ssoConfigId);
          const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => {
            if (ssoConfig.id === ssoConfigId) {
              return _extends({}, ssoConfig, {
                groups
              });
            }
            return ssoConfig;
          });
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(true);
        });
      };
      const updateSSOGroups = async (payload) => {
        const {
          ssoConfigId,
          changedGroups,
          callback
        } = payload;
        await __ssoTryCatch(SSOStateKeys.SAVE_SSO_GROUPS, callback, async () => {
          await Promise.all(changedGroups.map((group) => api2.auth.updateSSOGroup(ssoConfigId, group)));
          callback == null ? void 0 : callback(true);
        });
      };
      const saveSSOConfigurationByMetadata = async (payload) => {
        const {
          configFile,
          callback
        } = payload;
        await __ssoTryCatch(SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA, callback, async () => {
          const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
          const metadata = await readFileAsText(configFile);
          const newSsoConfiguration = await api2.auth.createSSOConfigurationByMetadata({
            metadata
          });
          actions.setSSOState({
            ssoConfigurations: [...ssoConfigurations, newSsoConfiguration]
          });
          callback == null ? void 0 : callback(newSsoConfiguration);
        });
      };
      const updateSSOConfigurationByMetadata = async (payload) => {
        const {
          callback,
          ssoConfigId,
          configFile
        } = payload;
        await __ssoTryCatch(SSOStateKeys.UPDATE_SSO_CONFIGURATION_BY_METADATA, callback, async () => {
          const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
          const metadata = await readFileAsText(configFile);
          const newSsoConfiguration = await api2.auth.updateSSOConfigurationByMetadata(ssoConfigId, {
            metadata
          });
          const newSsoConfigurations = ssoConfigurations.map((ssoConfig) => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(newSsoConfiguration);
        });
      };
      const saveSSOConfigurationByData = async (payload) => {
        const {
          callback,
          ssoConfigId
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded411);
        const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
        await __ssoTryCatch(SSOStateKeys.SAVE_SSO_CONFIGURATION, callback, async () => {
          let newSsoConfiguration;
          let newSsoConfigurations;
          if (ssoConfigId) {
            newSsoConfiguration = await api2.auth.updateSSOConfiguration(ssoConfigId, body);
            newSsoConfigurations = ssoConfigurations.map((ssoConfig) => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
          } else {
            newSsoConfiguration = await api2.auth.createSSOConfiguration(body);
            newSsoConfigurations = [newSsoConfiguration, ...ssoConfigurations];
          }
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(newSsoConfiguration);
        });
      };
      const saveSSOConfigurationByUrl = async (payload) => {
        const {
          metadataUrl,
          configMetadata,
          ssoConfigId,
          callback
        } = payload;
        await __ssoTryCatch(SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA, callback, async () => {
          const ssoConfigurations = store.auth.ssoState.ssoConfigurations;
          const body = {
            url: metadataUrl,
            configMetadata
          };
          let newSsoConfiguration;
          let newSsoConfigurations;
          if (ssoConfigId) {
            newSsoConfiguration = await api2.auth.updateSSOConfigurationByMetadataUrl(ssoConfigId, body);
            newSsoConfigurations = ssoConfigurations.map((ssoConfig) => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
          } else {
            newSsoConfiguration = await api2.auth.createSSOConfigurationByMetadataUrl(body);
            newSsoConfigurations = [newSsoConfiguration, ...ssoConfigurations];
          }
          actions.setSSOState({
            ssoConfigurations: newSsoConfigurations
          });
          callback == null ? void 0 : callback(newSsoConfiguration);
        });
      };
      return {
        loadSSOConfigurationsV2,
        saveSSOConfigurationV2,
        updateSSOConfiguration,
        deleteSSOConfiguration,
        saveSSODomain,
        deleteSSODomain,
        validateSSODomainV2,
        setSSOGroups,
        updateSSOGroups,
        setSSODefaultRoles,
        saveSSOConfigurationByMetadata,
        updateSSOConfigurationByMetadata,
        saveSSOConfigurationByUrl,
        saveSSOConfigurationByData
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/SSOState/actions/index.js
var actions_default30;
var init_actions30 = __esm({
  "node_modules/@frontegg/redux-store/auth/SSOState/actions/index.js"() {
    init_extends();
    init_actions_v1();
    init_actions_v2();
    actions_default30 = (store, api2, sharedActions) => {
      return _extends({}, actions_v1_default(store, api2, sharedActions), actions_v2_default(store, api2, sharedActions));
    };
  }
});

// node_modules/@frontegg/redux-store/auth/SSOState/index.js
var init_SSOState = __esm({
  "node_modules/@frontegg/redux-store/auth/SSOState/index.js"() {
    init_state30();
    init_actions30();
  }
});

// node_modules/@frontegg/redux-store/auth/StepUpState/state.js
var initialState31, state_default31;
var init_state31 = __esm({
  "node_modules/@frontegg/redux-store/auth/StepUpState/state.js"() {
    init_proxy();
    initialState31 = {
      loading: false,
      mfaDevices: void 0,
      mfaToken: ""
    };
    state_default31 = (overrideState) => createProxy2(initialState31, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/StepUpState/actions/generateStepUpSession.actions.js
var MFA_IS_NOT_ENROLLED_ERROR, isMfaIsNotEnrolledError, generateStepUpSession_actions_default;
var init_generateStepUpSession_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/StepUpState/actions/generateStepUpSession.actions.js"() {
    init_rest_api();
    init_helpers3();
    init_interfaces31();
    init_consts();
    MFA_IS_NOT_ENROLLED_ERROR = "MFA is not enrolled";
    isMfaIsNotEnrolledError = (error) => (error == null ? void 0 : error["message"]) === MFA_IS_NOT_ENROLLED_ERROR;
    generateStepUpSession_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __handleNoNeedToStepUpFlow = async (generateResponse) => {
        await actions.afterAuthenticationStateUpdate(generateResponse);
        await actions.afterStepUpAuthNavigation();
      };
      const __handleNeedToStepUpFlow = async ({
        mfaToken,
        mfaDevices
      }) => {
        actions.setStepUpState({
          mfaDevices,
          mfaToken
        });
        const step = await getMfaStepForEnrolledUsers(mfaDevices);
        actions.setMfaState({
          step
        });
      };
      const __handleStepUpError = async (error) => {
        if (isMfaIsNotEnrolledError(error)) {
          actions.setMfaState({
            step: MFAStep.noMFAEnrolledStepUp
          });
          return;
        }
        window.localStorage.setItem(SHOULD_STEP_UP_KEY, "true");
        const routes = store.auth.routes;
        ContextHolder.for(store.root.appName).onRedirectTo(routes.logoutUrl, {
          preserveQueryParams: true
        });
      };
      const generateStepUpSession = async (payload) => {
        const {
          maxAge,
          callback
        } = payload;
        actions.setStepUpState({
          mfaDevices: void 0,
          mfaToken: ""
        });
        try {
          const response = await api2.auth.generateStepupSession({
            maxAge
          });
          if (response.hasOwnProperty("user")) {
            await __handleNoNeedToStepUpFlow(response);
          } else {
            await __handleNeedToStepUpFlow(response);
          }
          callback == null ? void 0 : callback(true);
        } catch (e) {
          callback == null ? void 0 : callback(false);
          await __handleStepUpError(e);
        }
      };
      return {
        generateStepUpSession
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/StepUpState/actions/stepUpHostedLogin.actions.js
var stepUpHostedLogin_actions_default;
var init_stepUpHostedLogin_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/StepUpState/actions/stepUpHostedLogin.actions.js"() {
    init_consts();
    init_helpers4();
    stepUpHostedLogin_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const stepUpHostedLogin = async (payload) => {
        var _store$auth$tenantsSt, _store$auth$tenantsSt2;
        const params = {
          acr_values: ACR_VALUE
        };
        const {
          maxAge
        } = payload || {};
        if (maxAge !== void 0) {
          params["max_age"] = maxAge.toString();
        }
        const alias = (_store$auth$tenantsSt = store.auth.tenantsState) == null ? void 0 : (_store$auth$tenantsSt2 = _store$auth$tenantsSt.activeTenant) == null ? void 0 : _store$auth$tenantsSt2.alias;
        if (alias) {
          params["organization"] = alias;
        }
        setAfterAuthRedirectUrlForStepUp();
        window.localStorage.setItem(SHOULD_STEP_UP_KEY, "true");
        await actions.__requestHostedLoginAuthorize(params);
      };
      return {
        stepUpHostedLogin
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/StepUpState/actions/index.js
var actions_default31;
var init_actions31 = __esm({
  "node_modules/@frontegg/redux-store/auth/StepUpState/actions/index.js"() {
    init_extends();
    init_helpers();
    init_state31();
    init_generateStepUpSession_actions();
    init_stepUpHostedLogin_actions();
    actions_default31 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setStepUpState = (state) => {
        Object.assign(store.auth.stepUpState, state);
      };
      const resetStepUpState = () => {
        deepResetState(store, ["auth", "stepUpState"], initialState31);
      };
      const stepUpWithAuthenticator = async (payload) => {
        await actions.mfaWithAuthenticator(payload, actions.setStepUpState, true);
      };
      const preVerifyMFASMSForStepUp = async (payload) => {
        await actions.preVerifyMFASMS(payload, actions.setStepUpState);
      };
      const verifyMFASMSForStepUp = async (payload) => {
        await actions.verifyMFASMS(payload, actions.setStepUpState, true);
      };
      const preVerifyMFAWebAuthnForStepUp = async (payload) => {
        await actions.preVerifyMFAWebAuthn(payload, actions.setStepUpState);
      };
      const verifyMFAWebAuthnForStepUp = async (payload) => {
        await actions.verifyMFAWebAuthn(payload, actions.setStepUpState, true);
      };
      const preVerifyMFAEmailCodeForStepUp = async (payload) => {
        await actions.preVerifyMFAEmailCode(payload, actions.setStepUpState);
      };
      const verifyMFAEmailCodeForStepUp = async (payload) => {
        await actions.verifyMFAEmailCode(payload, actions.setStepUpState);
      };
      return _extends({
        setStepUpState,
        resetStepUpState,
        stepUpWithAuthenticator,
        preVerifyMFASMSForStepUp,
        verifyMFASMSForStepUp,
        preVerifyMFAWebAuthnForStepUp,
        verifyMFAWebAuthnForStepUp,
        preVerifyMFAEmailCodeForStepUp,
        verifyMFAEmailCodeForStepUp
      }, generateStepUpSession_actions_default(store, api2, sharedActions), stepUpHostedLogin_actions_default(store, api2, sharedActions));
    };
  }
});

// node_modules/@frontegg/redux-store/auth/StepUpState/index.js
var init_StepUpState = __esm({
  "node_modules/@frontegg/redux-store/auth/StepUpState/index.js"() {
    init_state31();
    init_actions31();
  }
});

// node_modules/@frontegg/redux-store/auth/TeamState/state.js
var initialState32, state_default32;
var init_state32 = __esm({
  "node_modules/@frontegg/redux-store/auth/TeamState/state.js"() {
    init_proxy();
    initialState32 = {
      loaders: {},
      pageOffset: 0,
      pageSize: 20,
      errors: {},
      users: [],
      allUsers: [],
      roles: [],
      permissions: [],
      totalPages: 0,
      shouldShowSubTenantUsersIfReseller: false,
      allUsersQueryParams: {
        _filter: null,
        _offset: 0,
        _limit: 20,
        _order: "DESC",
        _sortBy: "name"
      },
      addUserDialogState: {
        loading: false,
        open: false
      },
      deleteUserDialogState: {
        loading: false,
        open: false
      },
      lockUserDialogState: {
        loading: false,
        open: false
      },
      enableUserDialogState: {
        loading: false,
        open: false
      },
      disableUserDialogState: {
        loading: false,
        open: false
      }
    };
    state_default32 = (overrideState) => createProxy2(initialState32, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/TeamState/actions/users.actions.js
var _excluded61, _excluded222, _excluded315, _excluded412, _excluded510, _excluded67, users_actions_default;
var init_users_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/TeamState/actions/users.actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_rest_api();
    init_interfaces32();
    init_helpers();
    _excluded61 = ["callback", "appIds"];
    _excluded222 = ["roles"];
    _excluded315 = ["callback", "profileImage"];
    _excluded412 = ["callback"];
    _excluded510 = ["callback"];
    _excluded67 = ["callback"];
    users_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __getGroupsForUsers = async (retryConfig) => {
        try {
          const {
            groups
          } = await retryIfNeeded2(() => api2.groups.getGroups({
            _groupsRelations: GroupRelations.roles
          }), retryConfig);
          return groups;
        } catch (e) {
          return [];
        }
      };
      const loadRoles = async (payload) => {
        actions.setTeamLoader({
          key: TeamStateKeys.ROLES_AND_PERMISSIONS,
          value: true
        });
        try {
          var _payload$callback;
          const retryConfig = payload == null ? void 0 : payload.retryConfig;
          const [{
            items: roles
          }, {
            items: permissions
          }] = await Promise.all([retryIfNeeded2(() => api2.teams.loadAvailableRoles(), retryConfig), retryIfNeeded2(() => api2.teams.loadAvailablePermissions(), retryConfig)]);
          actions.setTeamState({
            roles,
            permissions
          });
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, {
            roles,
            permissions
          });
        } catch (e) {
          var _payload$callback2;
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
          actions.setTeamError({
            key: TeamStateKeys.ROLES_AND_PERMISSIONS,
            value: errorHandler(e)
          });
        } finally {
          actions.setTeamLoader({
            key: TeamStateKeys.ROLES_AND_PERMISSIONS,
            value: false
          });
        }
      };
      const loadUsers = async (payload) => {
        var _payload$pageSize, _payload$pageOffset, _payload$filter, _payload$sort;
        const {
          silentLoading,
          callback
        } = payload;
        const teamState = store.auth.teamState;
        const pageSize = (_payload$pageSize = payload.pageSize) != null ? _payload$pageSize : teamState.pageSize;
        const pageOffset = (_payload$pageOffset = payload.pageOffset) != null ? _payload$pageOffset : teamState.pageOffset;
        const filter = (_payload$filter = payload.filter) != null ? _payload$filter : teamState.filter;
        const sort = (_payload$sort = payload.sort) != null ? _payload$sort : teamState.sort;
        actions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: !silentLoading
        });
        actions.setTeamState({
          pageSize,
          pageOffset,
          filter,
          sort
        });
        try {
          const [{
            items: users,
            totalPages,
            totalItems
          }] = await Promise.all([api2.teams.loadUsers({
            pageSize,
            pageOffset,
            filter,
            sort
          }), loadRoles()]);
          actions.setTeamState({
            users,
            totalPages,
            totalItems
          });
          callback == null ? void 0 : callback(users);
        } catch (e) {
          actions.setTeamError({
            key: TeamStateKeys.USERS,
            value: errorHandler(e)
          });
          actions.setTeamState({
            totalPages: 0,
            users: []
          });
          callback == null ? void 0 : callback(null, e);
        }
        actions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: false
        });
      };
      const loadUsersV2 = async (payload) => {
        var _payload$pageSize2, _payload$pageOffset2, _payload$filter2, _payload$sort2, _payload$shouldShowSu;
        const {
          silentLoading,
          callback,
          shouldLoadRoles = true,
          shouldLoadApps,
          retryConfig
        } = payload;
        const teamState = store.auth.teamState;
        const pageSize = (_payload$pageSize2 = payload.pageSize) != null ? _payload$pageSize2 : teamState.pageSize;
        const pageOffset = (_payload$pageOffset2 = payload.pageOffset) != null ? _payload$pageOffset2 : teamState.pageOffset;
        const filter = (_payload$filter2 = payload.filter) != null ? _payload$filter2 : teamState.filterV2;
        const sort = (_payload$sort2 = payload.sort) != null ? _payload$sort2 : teamState.sortV2;
        const shouldIncludeSubTenants = (_payload$shouldShowSu = payload == null ? void 0 : payload.shouldShowSubTenantUsersIfReseller) != null ? _payload$shouldShowSu : teamState == null ? void 0 : teamState.shouldShowSubTenantUsersIfReseller;
        actions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: !silentLoading
        });
        actions.setTeamState({
          pageSize,
          pageOffset,
          filterV2: filter,
          sortV2: sort
        });
        try {
          const [{
            items: users,
            _metadata: {
              totalPages,
              totalItems
            }
          }, {
            items: roles
          }, {
            items: permissions
          }, groups] = await Promise.all([
            retryIfNeeded2(() => api2.users.getUsersV2(_extends({}, (filter == null ? void 0 : filter.length) && {
              _filter: filter
            }, sort && {
              _sortBy: sort
            }, payload.order && {
              _order: payload.order
            }, {
              _offset: pageOffset,
              _limit: pageSize,
              _includeSubTenants: shouldIncludeSubTenants
            })), retryConfig),
            retryIfNeeded2(() => api2.teams.loadAvailableRoles(), retryConfig),
            // TODO: check rest-api types
            retryIfNeeded2(() => api2.teams.loadAvailablePermissions(), retryConfig),
            // TODO: check rest-api types
            __getGroupsForUsers(retryConfig),
            shouldLoadRoles ? loadRoles({
              retryConfig
            }) : void 0
          ]);
          const usersWithGroups = users.map((user) => {
            var _user$groups;
            const userGroupsFullData = user == null ? void 0 : (_user$groups = user.groups) == null ? void 0 : _user$groups.map((group) => groups.filter((g) => g.id === group.id)).flat();
            return _extends({}, user, {
              groups: userGroupsFullData
            });
          });
          const userWithRoleIds = usersWithGroups.map((user) => _extends({}, user, {
            roleIds: user.roles.map((role) => role.id)
          }));
          const mappedUsers = await sharedActions.mapUsersWithApplicationData({
            shouldLoadApps,
            users: userWithRoleIds,
            retryConfig
          });
          sharedActions.setTeamState({
            users: mappedUsers,
            totalPages,
            totalItems,
            roles,
            permissions
          });
          callback == null ? void 0 : callback(users);
        } catch (e) {
          console.error("Failed to load users", e);
          actions.setTeamError({
            key: TeamStateKeys.USERS,
            value: errorHandler(e)
          });
          actions.setTeamState({
            totalPages: 0,
            users: []
          });
          callback == null ? void 0 : callback(null, e);
        }
        actions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: false
        });
      };
      const addUser = async (payload) => {
        const {
          callback,
          appIds
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded61);
        const teamState = store.auth.teamState;
        actions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          })
        });
        try {
          var _roles$map;
          const res = await api2.teams.addUser(body);
          const {
            roles
          } = res, userWithoutRoleIds = _objectWithoutPropertiesLoose(res, _excluded222);
          const roleIds = (_roles$map = roles == null ? void 0 : roles.map((role) => role.id)) != null ? _roles$map : [];
          const newUser = _extends({}, userWithoutRoleIds, {
            roleIds
          });
          const apps = await sharedActions.assignNewUserToApps({
            appIds,
            user: newUser
          });
          if (apps) {
            newUser.applications = apps;
          }
          callback == null ? void 0 : callback(newUser);
          actions.setTeamState({
            users: [newUser, ...teamState.users],
            addUserDialogState: {
              open: false,
              loading: false
            }
          });
        } catch (e) {
          console.error("Failed to add user", e);
          actions.setTeamState({
            addUserDialogState: _extends({}, teamState.addUserDialogState, {
              loading: false,
              error: errorHandler(e)
            })
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const addUsersBulk = async (payload) => {
        const {
          callback
        } = payload;
        const teamState = store.auth.teamState;
        actions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          })
        });
        const allowedEmails = [];
        const unallowedEmails = [];
        const bodies = payload.emails.map((email) => _extends({
          email,
          roleIds: payload.roleIds
        }, payload.expirationInSeconds && {
          expirationInSeconds: payload.expirationInSeconds
        }));
        actions.setTeamState({
          addUserDialogState: {
            open: true,
            loading: true
          }
        });
        for (let i = 0; i < bodies.length; i++) {
          const body = bodies.at(i);
          try {
            await api2.teams.addUser(body);
            allowedEmails.push(body.email);
          } catch (e) {
            unallowedEmails.push(body.email);
          }
        }
        const queryObject = {
          pageOffset: 0,
          pageSize: 10,
          filter: "",
          silentLoading: payload.emails.length > 0
        };
        await actions.loadUsersV2(queryObject);
        actions.setTeamState({
          addUserDialogState: {
            loading: false
          }
        });
        callback == null ? void 0 : callback({
          unallowedEmails,
          allowedEmails
        });
      };
      const updateUser = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded315);
        const {
          id: userId
        } = body;
        const teamState = store.auth.teamState;
        const oldUserData = teamState.users.find((user) => user.id === body.id);
        if (oldUserData === void 0) {
          callback == null ? void 0 : callback(null, "User not in state");
          return;
        }
        actions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER,
          value: userId || ""
        });
        actions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          })
        });
        actions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          }),
          users: teamState.users.map((user) => {
            if (user.id === body.id) {
              return _extends({}, user, body);
            }
            return user;
          })
        });
        try {
          var _body$roleIds;
          if (oldUserData.roleIds.length > 0 && ((_body$roleIds = body.roleIds) == null ? void 0 : _body$roleIds.length) === 0) {
            body.roleIds = [""];
          }
          const {
            item: newUser
          } = await api2.teams.updateUser(body);
          callback == null ? void 0 : callback(newUser);
          actions.setTeamState({
            users: teamState.users.map((user) => {
              return user.id === newUser.id ? _extends({}, user, newUser, {
                groups: user.groups,
                createdAt: user.createdAt,
                customData: user.customData,
                lastLogin: user.lastLogin
              }) : user;
            })
          });
          actions.setTeamLoader({
            key: TeamStateKeys.UPDATE_USER,
            value: false
          });
        } catch (e) {
          actions.setTeamState({
            addUserDialogState: _extends({}, teamState.addUserDialogState, {
              loading: false,
              error: errorHandler(e)
            }),
            users: teamState.users.map((user) => user.id === body.id ? _extends({}, user, oldUserData) : user)
          });
          actions.setTeamLoader({
            key: TeamStateKeys.UPDATE_USER,
            value: false
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const deleteUser = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded412);
        const teamState = store.auth.teamState;
        actions.setTeamState({
          deleteUserDialogState: _extends({}, teamState.deleteUserDialogState, {
            loading: true
          })
        });
        try {
          await api2.teams.deleteUser(body);
          callback == null ? void 0 : callback(true);
          actions.setTeamState({
            users: teamState.users.filter((user) => user.id !== body.userId),
            deleteUserDialogState: {
              open: false,
              loading: false
            }
          });
        } catch (e) {
          actions.setTeamState({
            deleteUserDialogState: _extends({}, teamState.deleteUserDialogState, {
              loading: false,
              error: errorHandler(e)
            })
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const enableUser = async (payload) => {
        const {
          callback,
          userId
        } = payload;
        const teamState = store.auth.teamState;
        actions.setTeamState({
          enableUserDialogState: _extends({}, teamState.enableUserDialogState, {
            loading: true
          })
        });
        try {
          await api2.teams.enableUser(userId);
          callback == null ? void 0 : callback(true);
          actions.setTeamState({
            users: teamState.users.map((user) => user.id === userId ? _extends({}, user, {
              isDisabled: false
            }) : user),
            enableUserDialogState: {
              open: false,
              loading: false
            }
          });
        } catch (e) {
          actions.setTeamState({
            enableUserDialogState: _extends({}, teamState.enableUserDialogState, {
              loading: false,
              error: errorHandler(e)
            })
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const disableUser = async (payload) => {
        const {
          callback,
          userId
        } = payload;
        const teamState = store.auth.teamState;
        actions.setTeamState({
          disableUserDialogState: _extends({}, teamState.disableUserDialogState, {
            loading: true
          })
        });
        try {
          await api2.teams.disableUser(userId);
          callback == null ? void 0 : callback(true);
          actions.setTeamState({
            users: teamState.users.map((user) => user.id === userId ? _extends({}, user, {
              isDisabled: true
            }) : user),
            disableUserDialogState: {
              open: false,
              loading: false
            }
          });
        } catch (e) {
          actions.setTeamState({
            disableUserDialogState: _extends({}, teamState.disableUserDialogState, {
              loading: false,
              error: errorHandler(e)
            })
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const getTemporaryUsersConfig = async (payload) => {
        actions.setTeamError({
          key: TeamStateKeys.CONFIG_TEMPORARY_USERS,
          value: false
        });
        try {
          const temporaryUsersConfig = await retryIfNeeded2(() => api2.teams.getTemporaryUserConfiguration(), payload == null ? void 0 : payload.retryConfig);
          actions.setTeamState({
            temporaryUsersConfig
          });
        } catch (e) {
          actions.setTeamError({
            key: TeamStateKeys.CONFIG_TEMPORARY_USERS,
            value: errorHandler(e)
          });
        }
      };
      const updateUserExpirationTime = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded510);
        const teamState = store.auth.teamState;
        actions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
          value: true
        });
        try {
          const res = await api2.teams.updateUserExpirationTime(body);
          actions.setTeamState({
            users: teamState.users.map((user) => {
              return user.id === body.userId ? _extends({}, user, {
                temporaryExpirationDate: new Date(res.temporaryExpirationDate)
              }) : user;
            })
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          actions.setTeamError({
            key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          actions.setTeamLoader({
            key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
            value: false
          });
        }
      };
      const setUserAsPermanent = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded67);
        const teamState = store.auth.teamState;
        actions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
          value: true
        });
        try {
          await api2.teams.setPermanentUser(body.userId);
          actions.setTeamState({
            users: teamState.users.map((user) => {
              return user.id === body.userId ? _extends({}, user, {
                temporaryExpirationDate: void 0
              }) : user;
            })
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          actions.setTeamError({
            key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(null, e);
        } finally {
          actions.setTeamLoader({
            key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
            value: false
          });
        }
      };
      return {
        loadRoles,
        loadUsers,
        loadUsersV2,
        addUser,
        addUsersBulk,
        updateUser,
        deleteUser,
        enableUser,
        disableUser,
        getTemporaryUsersConfig,
        updateUserExpirationTime,
        setUserAsPermanent
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/TeamState/actions/sub-tenants.actions.js
var _excluded68, _excluded223, _excluded316, sub_tenants_actions_default;
var init_sub_tenants_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/TeamState/actions/sub-tenants.actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_interfaces32();
    init_helpers();
    _excluded68 = ["callback", "userId"];
    _excluded223 = ["callback"];
    _excluded316 = ["callback"];
    sub_tenants_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const loadAllSubTenantsUsers = async (payload) => {
        var _payload$_limit, _payload$_offset, _payload$_filter, _payload$_sortBy, _payload$_order;
        const {
          silentLoading,
          callback
        } = payload;
        const teamState = store.auth.teamState;
        const qParam = teamState.allUsersQueryParams;
        const _limit = (_payload$_limit = payload._limit) != null ? _payload$_limit : qParam._limit;
        const _offset = (_payload$_offset = payload._offset) != null ? _payload$_offset : qParam._offset;
        const _filter = (_payload$_filter = payload._filter) != null ? _payload$_filter : qParam._filter;
        const _sortBy = (_payload$_sortBy = payload._sortBy) != null ? _payload$_sortBy : qParam._sortBy;
        const _order = (_payload$_order = payload._order) != null ? _payload$_order : qParam._order;
        const allUsersQueryParams = {
          _limit: _limit || 20,
          _offset: _offset || 0,
          _filter: _filter || "",
          _sortBy: _sortBy || "name",
          _order: _order || "DESC"
        };
        actions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: !silentLoading
        });
        actions.setTeamState({
          allUsersQueryParams
        });
        try {
          const [
            // @ts-ignore // TODO: fix type in rest-api
            {
              items: users,
              // @ts-ignore // TODO: fix type in rest-api
              _metadata: {
                totalPages,
                totalItems
              }
            },
            // @ts-ignore // TODO: fix type in rest-api
            {
              items: roles
            },
            // @ts-ignore // TODO: fix type in rest-api
            {
              items: permissions
            }
          ] = await Promise.all([api2.subTenants.loadAllUsers(_extends({}, allUsersQueryParams)), api2.teams.loadAvailableRoles(), api2.teams.loadAvailablePermissions()]);
          actions.setTeamState({
            allUsers: users,
            totalPages,
            totalItems,
            roles,
            permissions
          });
          callback == null ? void 0 : callback(users);
        } catch (e) {
          actions.setTeamError({
            key: TeamStateKeys.USERS,
            value: errorHandler(e)
          });
          actions.setTeamState({
            totalPages: 0,
            users: []
          });
          callback == null ? void 0 : callback(null, e);
        }
        actions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: false
        });
      };
      const setUserRolesForSubTenants = async (payload) => {
        const {
          callback,
          userId
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded68);
        const teamState = store.auth.teamState;
        actions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          })
        });
        try {
          await api2.subTenants.setUserRolesForSubTenants(userId, body);
          const updatedUser = teamState.allUsers.find((user) => user.id === userId);
          let newTenants = [];
          if (updatedUser) {
            newTenants = updatedUser.tenants.map((tenant) => {
              var _body$subTenantsRoles;
              return _extends({}, tenant, {
                roles: ((_body$subTenantsRoles = body.subTenantsRoles.find((roleUpdate) => roleUpdate.tenantId === tenant.tenantId)) == null ? void 0 : _body$subTenantsRoles.roleIds.map((roleId) => {
                  const role = teamState.roles.find(({
                    id
                  }) => roleId === id);
                  return role;
                }).filter((role) => role)) || tenant.roles
              });
            });
          }
          actions.setTeamState({
            allUsers: [...teamState.allUsers.filter((user) => user.id !== userId), ...updatedUser ? [_extends({}, updatedUser, {
              tenants: newTenants
            })] : []],
            addUserDialogState: {
              open: false,
              loading: false
            }
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          actions.setTeamState({
            addUserDialogState: _extends({}, teamState.addUserDialogState, {
              loading: false,
              error: errorHandler(e)
            })
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const deleteUserFromSubTenants = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded223);
        const teamState = store.auth.teamState;
        actions.setTeamState({
          deleteUserDialogState: _extends({}, teamState.deleteUserDialogState, {
            loading: true
          })
        });
        try {
          await api2.subTenants.removeUserFromTenantAndSubTenants(body);
          callback == null ? void 0 : callback(true);
          actions.setTeamState({
            allUsers: teamState.allUsers.filter((user) => user.id !== body.userId && user.tenants.length === body.subTenants.length),
            deleteUserDialogState: {
              open: false,
              loading: false
            }
          });
        } catch (e) {
          actions.setTeamState({
            deleteUserDialogState: _extends({}, teamState.deleteUserDialogState, {
              loading: false,
              error: errorHandler(e)
            })
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      const addUserToSubTenants = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded316);
        const teamState = store.auth.teamState;
        actions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          })
        });
        try {
          await api2.subTenants.addUserToTenantAndSubTenants(body);
          const {
            // @ts-ignore // TODO: fix type in rest-api
            items: users,
            // @ts-ignore // TODO: fix type in rest-api
            _metadata: {
              totalPages,
              totalItems
            }
          } = await api2.subTenants.loadAllUsers({
            _limit: 20,
            _offset: 0,
            _filter: "",
            _sortBy: "name",
            _order: "DESC"
          });
          actions.setTeamState({
            allUsers: users,
            totalPages,
            totalItems,
            addUserDialogState: {
              open: false,
              loading: false
            }
          });
          callback == null ? void 0 : callback(null);
        } catch (e) {
          actions.setTeamState({
            addUserDialogState: _extends({}, teamState.addUserDialogState, {
              loading: false,
              error: errorHandler(e)
            })
          });
          callback == null ? void 0 : callback(null, e);
        }
      };
      return {
        loadAllSubTenantsUsers,
        setUserRolesForSubTenants,
        deleteUserFromSubTenants,
        addUserToSubTenants
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/TeamState/actions/activation-link.actions.js
var _excluded69, _excluded224, _excluded317, _excluded413, activation_link_actions_default;
var init_activation_link_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/TeamState/actions/activation-link.actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_helpers();
    init_interfaces32();
    _excluded69 = ["callback"];
    _excluded224 = ["callback"];
    _excluded317 = ["callback"];
    _excluded413 = ["callback"];
    activation_link_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __activateLinkTryCatch = async (key, loadingValue, callback, block) => {
        actions.setTeamLoader({
          key,
          value: loadingValue
        });
        try {
          await block();
        } catch (error) {
          actions.setTeamError({
            key,
            value: errorHandler(error)
          });
          callback == null ? void 0 : callback(null, error);
        } finally {
          actions.setTeamLoader({
            key,
            value: false
          });
        }
      };
      const resendActivationLink = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded69);
        await __activateLinkTryCatch(TeamStateKeys.RESEND_ACTIVATE_LINK, body.userId, callback, async () => {
          await api2.teams.resendActivationLink(body);
          callback == null ? void 0 : callback(true);
        });
      };
      const resendInvitationLink = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded224);
        await __activateLinkTryCatch(TeamStateKeys.RESEND_INVITATION_LINK, body.email, callback, async () => {
          await api2.teams.resendInvitationLink(body);
          callback == null ? void 0 : callback(true);
        });
      };
      const resendInvitationEmail = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded317);
        await __activateLinkTryCatch(TeamStateKeys.RESEND_INVITATION_LINK, callback, body.email, async () => {
          await api2.auth.resendInvitationEmail(body);
          callback == null ? void 0 : callback(true);
        });
      };
      const resendInvitationLinkToAllSubTenants = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded413);
        await __activateLinkTryCatch(TeamStateKeys.RESEND_INVITATION_LINK, body.email, callback, async () => {
          await api2.teams.resendInvitationLinkToAllTenants(body);
          callback == null ? void 0 : callback(true);
        });
      };
      return {
        resendActivationLink,
        resendInvitationLink,
        resendInvitationEmail,
        resendInvitationLinkToAllSubTenants
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/TeamState/actions/invitation-link.actions.js
var invitation_link_actions_default;
var init_invitation_link_actions = __esm({
  "node_modules/@frontegg/redux-store/auth/TeamState/actions/invitation-link.actions.js"() {
    init_extends();
    init_helpers();
    init_interfaces32();
    invitation_link_actions_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const __getInvitationLinkConfig = async (retryConfig) => {
        actions.setTeamError({
          key: TeamStateKeys.CONFIG_TOKEN_LINK,
          value: false
        });
        try {
          const invitationLinkConfig = await retryIfNeeded2(() => api2.teams.getInviteLinkConfiguration(), retryConfig);
          actions.setTeamState({
            inviteTokenState: _extends({}, invitationLinkConfig)
          });
        } catch (e) {
          actions.setTeamError({
            key: TeamStateKeys.CONFIG_TOKEN_LINK,
            value: errorHandler(e)
          });
        }
      };
      const getInvitationLink = async (payload) => {
        actions.setTeamError({
          key: TeamStateKeys.GET_TOKEN_LINK,
          value: false
        });
        try {
          const retryConfig = payload == null ? void 0 : payload.retryConfig;
          await __getInvitationLinkConfig(retryConfig);
          const data = await retryIfNeeded2(() => api2.teams.getInviteUserLink(), retryConfig);
          const {
            inviteTokenState
          } = store.auth.teamState;
          actions.setTeamState({
            inviteTokenState: _extends({}, inviteTokenState, data)
          });
        } catch (e) {
          actions.setTeamError({
            key: TeamStateKeys.GET_TOKEN_LINK,
            value: errorHandler(e)
          });
        }
      };
      const createInvitationLink = async (payload) => {
        const {
          callback
        } = payload;
        actions.setTeamError({
          key: TeamStateKeys.CREATE_TOKEN_LINK,
          value: false
        });
        const {
          inviteTokenState
        } = store.auth.teamState;
        try {
          const data = await api2.teams.createInviteUserLink({
            expiresInMinutes: 43200
          });
          actions.setTeamState({
            inviteTokenState: _extends({}, inviteTokenState, data)
          });
          callback == null ? void 0 : callback(data.token);
        } catch (e) {
          callback == null ? void 0 : callback(null, e);
          actions.setTeamError({
            key: TeamStateKeys.CREATE_TOKEN_LINK,
            value: errorHandler(e)
          });
        }
      };
      const updateInvitationLink = async (payload) => {
        const {
          callback,
          expiresInMinutes,
          shouldSendEmail
        } = payload;
        actions.setTeamError({
          key: TeamStateKeys.UPDATE_TOKEN_LINK,
          value: false
        });
        try {
          const {
            inviteTokenState
          } = store.auth.teamState;
          const data = await api2.teams.updateInviteUserLink({
            expiresInMinutes,
            shouldSendEmail
          });
          actions.setTeamState({
            inviteTokenState: _extends({}, inviteTokenState, data)
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          callback == null ? void 0 : callback(null, e);
          actions.setTeamError({
            key: TeamStateKeys.UPDATE_TOKEN_LINK,
            value: errorHandler(e)
          });
        }
      };
      const deleteInvitationLink = async (payload) => {
        const {
          callback
        } = payload != null ? payload : {};
        actions.setTeamError({
          key: TeamStateKeys.DELETE_TOKEN_LINK,
          value: false
        });
        try {
          await api2.teams.deleteInviteUserLink();
          actions.setTeamState({
            inviteTokenState: void 0
          });
          callback == null ? void 0 : callback(true);
        } catch (e) {
          actions.setTeamError({
            key: TeamStateKeys.DELETE_TOKEN_LINK,
            value: errorHandler(e)
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      return {
        getInvitationLink,
        createInvitationLink,
        updateInvitationLink,
        deleteInvitationLink
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/TeamState/actions/index.js
var actions_default32;
var init_actions32 = __esm({
  "node_modules/@frontegg/redux-store/auth/TeamState/actions/index.js"() {
    init_extends();
    init_users_actions();
    init_sub_tenants_actions();
    init_activation_link_actions();
    init_invitation_link_actions();
    init_helpers();
    init_state32();
    actions_default32 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setTeamState = (payload) => {
        Object.assign(store.auth.teamState, payload);
      };
      const resetTeamState = () => {
        deepResetState(store, ["auth", "teamState"], initialState32);
      };
      const setTeamLoader = (payload) => {
        Object.assign(store.auth.teamState, {
          loaders: _extends({}, store.auth.teamState.loaders, {
            [payload.key]: payload.value
          })
        });
      };
      const setTeamError = (payload) => {
        Object.assign(store.auth.teamState, {
          errors: _extends({}, store.auth.teamState.errors, {
            [payload.key]: payload.value
          }),
          loaders: _extends({}, store.auth.teamState.loaders, {
            [payload.key]: false
          })
        });
      };
      const openAddUserDialog = (payload) => {
        setTeamState({
          addUserDialogState: _extends({
            open: true,
            loading: false,
            error: false
          }, payload)
        });
      };
      const closeAddUserDialog = (payload) => {
        var _store$auth$teamState, _store$auth$teamState2;
        (_store$auth$teamState = (_store$auth$teamState2 = store.auth.teamState.addUserDialogState).onClose) == null ? void 0 : _store$auth$teamState.call(_store$auth$teamState2, payload);
        setTeamState({
          addUserDialogState: {
            loading: false,
            error: false,
            open: false
          }
        });
      };
      const openDeleteUserDialog = (payload) => {
        setTeamState({
          deleteUserDialogState: _extends({
            open: true,
            loading: false,
            error: false
          }, payload)
        });
      };
      const closeDeleteUserDialog = (payload) => {
        var _store$auth$teamState3, _store$auth$teamState4;
        (_store$auth$teamState3 = (_store$auth$teamState4 = store.auth.teamState.deleteUserDialogState).onClose) == null ? void 0 : _store$auth$teamState3.call(_store$auth$teamState4, payload);
        setTeamState({
          deleteUserDialogState: {
            loading: false,
            error: false,
            open: false
          }
        });
      };
      const lockUser = async (payload) => {
      };
      return _extends({
        setTeamLoader,
        setTeamError,
        setTeamState,
        resetTeamState,
        openAddUserDialog,
        closeAddUserDialog,
        openDeleteUserDialog,
        closeDeleteUserDialog,
        lockUser
      }, users_actions_default(store, api2, sharedActions), sub_tenants_actions_default(store, api2, sharedActions), activation_link_actions_default(store, api2, sharedActions), invitation_link_actions_default(store, api2, sharedActions));
    };
  }
});

// node_modules/@frontegg/redux-store/auth/TeamState/index.js
var init_TeamState = __esm({
  "node_modules/@frontegg/redux-store/auth/TeamState/index.js"() {
    init_state32();
    init_actions32();
  }
});

// node_modules/@frontegg/redux-store/auth/TenantsState/state.js
var initialState33, state_default33;
var init_state33 = __esm({
  "node_modules/@frontegg/redux-store/auth/TenantsState/state.js"() {
    init_proxy();
    initialState33 = {
      tenants: [],
      subTenants: [],
      switchingTenant: false,
      loading: true,
      tenantTree: null
    };
    state_default33 = (overrideState) => createProxy2(initialState33, overrideState);
  }
});

// node_modules/@frontegg/redux-store/auth/TenantsState/actions.js
var actions_default33;
var init_actions33 = __esm({
  "node_modules/@frontegg/redux-store/auth/TenantsState/actions.js"() {
    init_state33();
    init_helpers();
    init_rest_api();
    actions_default33 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setTenantsState = (state) => {
        Object.assign(store.auth.tenantsState, state);
      };
      const resetTenantsState = () => {
        deepResetState(store, ["auth", "tenantsState"], initialState33);
      };
      const switchTenant = async (payload) => {
        const {
          tenantId,
          silentReload,
          callback
        } = payload;
        silentReload ? actions.setTenantsState({
          switchingTenant: true
        }) : actions.setAuthState({
          isLoading: true
        });
        try {
          await api2.tenants.switchTenant({
            tenantId
          });
          if (silentReload) {
            actions.resetAuthState({
              isLoading: false,
              isAuthenticated: true,
              user: store.auth.user
            });
          }
          await actions.__refreshToken();
          const callbackConsumed = callback == null ? void 0 : callback(true);
          if (!callbackConsumed) {
            silentReload ? actions.setTenantsState({
              switchingTenant: false
            }) : actions.setAuthState({
              isLoading: false
            });
          }
        } catch (e) {
          silentReload ? actions.setTenantsState({
            switchingTenant: false
          }) : actions.setAuthState({
            isLoading: false
          });
          callback == null ? void 0 : callback(false, e);
        }
      };
      const loadTenants = async (payload) => {
        setTenantsState({
          loading: true
        });
        try {
          var _payload$callback;
          const userTenantsResponseFunc = getCurrentUserTenantsFunction(store.root.appName);
          const userTenantsResponse = await userTenantsResponseFunc();
          setTenantsState({
            tenants: userTenantsResponse.tenants,
            activeTenant: userTenantsResponse.activeTenant,
            loading: false
          });
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, []);
        } catch (e) {
          var _payload$callback2;
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, [], e);
          setTenantsState({
            loading: false
          });
        }
      };
      const loadSubTenants = async (payload) => {
        setTenantsState({
          loading: true
        });
        try {
          var _payload$callback3;
          const subTenants = await retryIfNeeded(() => api2.tenants.getSubTenants(), payload == null ? void 0 : payload.retryConfig);
          setTenantsState({
            subTenants,
            loading: false
          });
          payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
        } catch (e) {
          var _payload$callback4;
          setTenantsState({
            loading: false
          });
          payload == null ? void 0 : (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, null, e);
        }
      };
      const loadSubTenantsTree = async (payload) => {
        setTenantsState({
          loading: true
        });
        try {
          var _payload$callback5;
          const tenantTree = await api2.tenants.getSubTenantsAsTree();
          setTenantsState({
            tenantTree,
            loading: false
          });
          payload == null ? void 0 : (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, true);
        } catch (e) {
          var _payload$callback6;
          setTenantsState({
            loading: false
          });
          payload == null ? void 0 : (_payload$callback6 = payload.callback) == null ? void 0 : _payload$callback6.call(payload, null, e);
        }
      };
      return {
        setTenantsState,
        resetTenantsState,
        switchTenant,
        loadTenants,
        loadSubTenants,
        loadSubTenantsTree
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/TenantsState/index.js
var init_TenantsState = __esm({
  "node_modules/@frontegg/redux-store/auth/TenantsState/index.js"() {
    init_state33();
    init_actions33();
  }
});

// node_modules/@frontegg/redux-store/auth/Entitlements/actions.js
var actions_default34;
var init_actions34 = __esm({
  "node_modules/@frontegg/redux-store/auth/Entitlements/actions.js"() {
    init_helpers2();
    actions_default34 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setEntitlements = (entitlements) => {
        if (store.auth.user) {
          store.auth.user.entitlements = entitlements;
        }
      };
      const handleFetchedEntitlements = (newEntitlementsResponse) => {
        var _store$auth$user;
        const oldEntitlements = (_store$auth$user = store.auth.user) == null ? void 0 : _store$auth$user.entitlements;
        if (isEntitlementsDeeplyEqual(oldEntitlements, newEntitlementsResponse)) {
          return;
        }
        setEntitlements(newEntitlementsResponse);
      };
      const loadEntitlements = async (payload) => {
        const callback = payload == null ? void 0 : payload.callback;
        try {
          const entitlements = await api2.entitlements.loadEntitlementsV2();
          handleFetchedEntitlements(entitlements);
          callback == null ? void 0 : callback(true);
        } catch (e) {
          callback == null ? void 0 : callback(false);
        }
      };
      return {
        setEntitlements,
        handleFetchedEntitlements,
        loadEntitlements
      };
    };
  }
});

// node_modules/@frontegg/redux-store/auth/Entitlements/index.js
var init_Entitlements = __esm({
  "node_modules/@frontegg/redux-store/auth/Entitlements/index.js"() {
    init_actions34();
  }
});

// node_modules/@frontegg/redux-store/auth/AccountSettingsState/interfaces.js
var init_interfaces44 = __esm({
  "node_modules/@frontegg/redux-store/auth/AccountSettingsState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/UnlockAccountState/interfaces.js
var init_interfaces45 = __esm({
  "node_modules/@frontegg/redux-store/auth/UnlockAccountState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/ApplicationsState/interfaces.js
var init_interfaces46 = __esm({
  "node_modules/@frontegg/redux-store/auth/ApplicationsState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/CustomLoginState/interfaces.js
var init_interfaces47 = __esm({
  "node_modules/@frontegg/redux-store/auth/CustomLoginState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/Entitlements/interfaces.js
var init_interfaces48 = __esm({
  "node_modules/@frontegg/redux-store/auth/Entitlements/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/GroupsDialogsState/interfaces.js
var init_interfaces49 = __esm({
  "node_modules/@frontegg/redux-store/auth/GroupsDialogsState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/PasskeysState/interfaces.js
var init_interfaces50 = __esm({
  "node_modules/@frontegg/redux-store/auth/PasskeysState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/ProfileState/interfaces.js
var init_interfaces51 = __esm({
  "node_modules/@frontegg/redux-store/auth/ProfileState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/ProvisioningState/interfaces.js
var init_interfaces52 = __esm({
  "node_modules/@frontegg/redux-store/auth/ProvisioningState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/Security/RestrictionsState/interfaces.js
var init_interfaces53 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/RestrictionsState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/interfaces.js
var init_interfaces54 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SecurityPolicyState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/Security/SessionsPolicyState/interfaces.js
var init_interfaces55 = __esm({
  "node_modules/@frontegg/redux-store/auth/Security/SessionsPolicyState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/SessionsState/interfaces.js
var init_interfaces56 = __esm({
  "node_modules/@frontegg/redux-store/auth/SessionsState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/SmsState/interfaces.js
var init_interfaces57 = __esm({
  "node_modules/@frontegg/redux-store/auth/SmsState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/SocialLoginState/interfaces.js
var init_interfaces58 = __esm({
  "node_modules/@frontegg/redux-store/auth/SocialLoginState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/StepUpState/interfaces.js
var init_interfaces59 = __esm({
  "node_modules/@frontegg/redux-store/auth/StepUpState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/TenantsState/interfaces.js
var init_interfaces60 = __esm({
  "node_modules/@frontegg/redux-store/auth/TenantsState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/auth/index.js
var _excluded70, _excluded225, createAuthState, buildAuthActions;
var init_auth2 = __esm({
  "node_modules/@frontegg/redux-store/auth/index.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_AcceptInvitationState();
    init_AccountSettingsState();
    init_ActivateAccountState();
    init_UnlockAccountState();
    init_ApiTokensState();
    init_ApplicationsState();
    init_CustomLoginState();
    init_ForgotPasswordState();
    init_PasswordRotationState();
    init_GroupsState();
    init_GroupsDialogsState();
    init_ImpersonateState();
    init_LoginState();
    init_MfaState();
    init_MSP();
    init_PasskeysState();
    init_ProfileState();
    init_ProvisioningState();
    init_ResetPhoneNumberState();
    init_RolesState();
    init_RestrictionsState();
    init_SecurityCenterState();
    init_SecurityPolicyState();
    init_SessionsPolicyState();
    init_SessionsState();
    init_SignUpState();
    init_SmsState();
    init_SocialLoginState();
    init_SSOState();
    init_StepUpState();
    init_TeamState();
    init_TenantsState();
    init_consts2();
    init_helpers();
    init_Entitlements();
    init_proxy();
    init_interfaces27();
    init_interfaces44();
    init_interfaces29();
    init_interfaces45();
    init_interfaces33();
    init_interfaces46();
    init_interfaces47();
    init_interfaces48();
    init_helpers2();
    init_interfaces34();
    init_interfaces35();
    init_interfaces36();
    init_interfaces49();
    init_interfaces37();
    init_interfaces28();
    init_interfaces31();
    init_interfaces39();
    init_interfaces50();
    init_interfaces51();
    init_interfaces52();
    init_interfaces40();
    init_interfaces41();
    init_interfaces53();
    init_interfaces42();
    init_interfaces54();
    init_interfaces55();
    init_interfaces56();
    init_interfaces43();
    init_interfaces57();
    init_interfaces58();
    init_interfaces38();
    init_interfaces59();
    init_interfaces32();
    init_interfaces60();
    init_interfaces30();
    _excluded70 = ["routes"];
    _excluded225 = ["requestName"];
    createAuthState = (_overrideState) => {
      const _ref = _overrideState != null ? _overrideState : {}, {
        routes
      } = _ref, overrideState = _objectWithoutPropertiesLoose(_ref, _excluded70);
      return createProxy2(_extends({
        routes: _extends({}, defaultFronteggRoutes, routes),
        onRedirectTo: () => void 0,
        isAuthenticated: false,
        isLoading: true,
        isSSOAuth: false,
        user: null,
        error: void 0,
        errorByRequest: {},
        userIp: void 0,
        userIpData: {
          loading: false
        }
      }, overrideState, {
        // nested states
        acceptInvitationState: state_default(overrideState == null ? void 0 : overrideState.acceptInvitationState),
        accountSettingsState: state_default2(overrideState == null ? void 0 : overrideState.accountSettingsState),
        activateAccountState: state_default3(overrideState == null ? void 0 : overrideState.activateAccountState),
        unlockAccountState: state_default4(overrideState == null ? void 0 : overrideState.unlockAccountState),
        apiTokensState: state_default5(overrideState == null ? void 0 : overrideState.apiTokensState),
        applicationsState: state_default6(overrideState == null ? void 0 : overrideState.applicationsState),
        customLoginState: state_default7(overrideState == null ? void 0 : overrideState.customLoginState),
        forgotPasswordState: state_default8(overrideState == null ? void 0 : overrideState.forgotPasswordState),
        passwordRotationState: state_default9(overrideState == null ? void 0 : overrideState.passwordRotationState),
        groupsState: state_default10(overrideState == null ? void 0 : overrideState.groupsState),
        groupsDialogsState: state_default11(overrideState == null ? void 0 : overrideState.groupsDialogsState),
        impersonateState: state_default12(overrideState == null ? void 0 : overrideState.impersonateState),
        loginState: state_default13(overrideState == null ? void 0 : overrideState.loginState),
        mfaState: state_default14(overrideState == null ? void 0 : overrideState.mfaState),
        allAccountsState: state_default15(overrideState == null ? void 0 : overrideState.allAccountsState),
        allAccountsDialogsState: state_default16(overrideState == null ? void 0 : overrideState.allAccountsDialogsState),
        passkeysState: state_default17(overrideState == null ? void 0 : overrideState.passkeysState),
        profileState: state_default18(overrideState == null ? void 0 : overrideState.profileState),
        provisioningState: state_default19(overrideState == null ? void 0 : overrideState.provisioningState),
        resetPhoneNumberState: state_default20(overrideState == null ? void 0 : overrideState.resetPhoneNumberState),
        rolesState: state_default21(overrideState == null ? void 0 : overrideState.rolesState),
        restrictionsState: state_default22(overrideState == null ? void 0 : overrideState.restrictionsState),
        securityCenterState: state_default23(overrideState == null ? void 0 : overrideState.securityCenterState),
        securityPolicyState: state_default24(overrideState == null ? void 0 : overrideState.securityPolicyState),
        sessionsPolicyState: state_default25(overrideState == null ? void 0 : overrideState.sessionsPolicyState),
        sessionsState: state_default26(overrideState == null ? void 0 : overrideState.sessionsState),
        signUpState: state_default27(overrideState == null ? void 0 : overrideState.signUpState),
        smsState: state_default28(overrideState == null ? void 0 : overrideState.smsState),
        socialLoginState: state_default29(overrideState == null ? void 0 : overrideState.socialLoginState),
        ssoState: state_default30(overrideState == null ? void 0 : overrideState.ssoState),
        stepUpState: state_default31(overrideState == null ? void 0 : overrideState.stepUpState),
        teamState: state_default32(overrideState == null ? void 0 : overrideState.teamState),
        tenantsState: state_default33(overrideState == null ? void 0 : overrideState.tenantsState)
      }));
    };
    buildAuthActions = (store, api2, actions, snapshotAuthState) => {
      const setAuthState = (state) => {
        Object.keys(state).forEach((key) => {
          const authKey = key;
          if (isProxy(store.auth[authKey])) {
            Object.assign(store.auth[authKey], state[authKey]);
          } else {
            store.auth[authKey] = state[authKey];
          }
        });
      };
      const resetAuthState = (state = {}) => {
        deepResetState(store, ["auth"], _extends({}, snapshotAuthState, state));
      };
      const setUser = (user) => {
        setAuthState({
          user
        });
      };
      const setErrorByRequestName = (_ref2) => {
        let {
          requestName
        } = _ref2, data = _objectWithoutPropertiesLoose(_ref2, _excluded225);
        store.auth.errorByRequest = _extends({}, store.auth.errorByRequest, {
          [requestName]: _extends({}, data, {
            isError: true
          })
        });
      };
      const acceptInvitationActions = actions_default(store, api2, actions);
      const accountSettingsActions = actions_default2(store, api2, actions);
      const activateAccountActions = actions_default3(store, api2, actions);
      const unlockAccountActions = actions_default4(store, api2, actions);
      const apiTokensActions = actions_default5(store, api2, actions);
      const applicationsActions = actions_default6(store, api2, actions);
      const customLoginActions = actions_default7(store, api2, actions);
      const entitlementsActions = actions_default34(store, api2, actions);
      const forgotPasswordActions = actions_default8(store, api2, actions);
      const passwordRotationActions = actions_default9(store, api2, actions);
      const groupsActions = actions_default10(store, api2, actions);
      const groupsDialogsActions = actions_default11(store, api2, actions);
      const impersonateActions = actions_default12(store, api2, actions);
      const loginActions = actions_default13(store, api2, actions);
      const mfaActions = actions_default14(store, api2, actions);
      const allAccountsActions = actions_default15(store, api2, actions);
      const allAccountsDialogActions = actions_default16(store, api2, actions);
      const passkeysActions = actions_default17(store, api2, actions);
      const profileActions = actions_default18(store, api2, actions);
      const provisioningActions = actions_default19(store, api2, actions);
      const resetPhoneNumberActions = actions_default20(store, api2, actions);
      const rolesActions = actions_default21(store, api2, actions);
      const restrictionsActions = actions_default22(store, api2, actions);
      const securityCenterActions = actions_default23(store, api2, actions);
      const securityPolicyActions = actions_default24(store, api2, actions);
      const sessionsPolicyActions = actions_default25(store, api2, actions);
      const sessionsActions = actions_default26(store, api2, actions);
      const signUpActions = actions_default27(store, api2, actions);
      const smsActions = actions_default28(store, api2, actions);
      const socialLoginActions = actions_default29(store, api2, actions);
      const ssoActions = actions_default30(store, api2, actions);
      const stepUpActions = actions_default31(store, api2, actions);
      const teamActions = actions_default32(store, api2, actions);
      const tenantsActions = actions_default33(store, api2, actions);
      const stateActions = {
        acceptInvitationActions,
        accountSettingsActions,
        activateAccountActions,
        unlockAccountActions,
        apiTokensActions,
        applicationsActions,
        customLoginActions,
        entitlementsActions,
        forgotPasswordActions,
        passwordRotationActions,
        groupsActions,
        groupsDialogsActions,
        impersonateActions,
        loginActions,
        mfaActions,
        allAccountsActions,
        allAccountsDialogActions,
        passkeysActions,
        profileActions,
        provisioningActions,
        resetPhoneNumberActions,
        rolesActions,
        restrictionsActions,
        securityCenterActions,
        securityPolicyActions,
        sessionsPolicyActions,
        sessionsActions,
        signUpActions,
        smsActions,
        socialLoginActions,
        ssoActions,
        stepUpActions,
        teamActions,
        tenantsActions
      };
      return [_extends({
        setAuthState,
        setErrorByRequestName,
        /** @deprecated use setAuthState instead */
        setState: setAuthState,
        resetAuthState,
        setUser
      }, Object.values(stateActions).reduce((acc, actions2) => _extends({}, acc, actions2), {})), stateActions];
    };
  }
});

// node_modules/@frontegg/redux-store/connectivity/state.js
var initialState34, state_default34;
var init_state34 = __esm({
  "node_modules/@frontegg/redux-store/connectivity/state.js"() {
    init_proxy();
    initialState34 = {
      isLoading: false,
      isSaving: false,
      list: [],
      processIds: [],
      slackChannels: {
        isLoading: false
      }
    };
    state_default34 = (overrideState) => createProxy2(initialState34, overrideState);
  }
});

// node_modules/@frontegg/redux-store/connectivity/consts.js
var channels, channels2Platform;
var init_consts3 = __esm({
  "node_modules/@frontegg/redux-store/connectivity/consts.js"() {
    channels = ["email", "slack", "sms", "webhook"];
    channels2Platform = {
      sms: {
        title: "connectivity.sms",
        events: (data) => (data == null ? void 0 : data.length) || 0,
        isActive: (data) => {
          var _some;
          return (_some = data == null ? void 0 : data.some(({
            enabled
          }) => enabled)) != null ? _some : false;
        },
        image: "sms"
      },
      email: {
        title: "common.email",
        events: (data) => (data == null ? void 0 : data.length) || 0,
        isActive: (data) => {
          var _some2;
          return (_some2 = data == null ? void 0 : data.some(({
            enabled
          }) => enabled)) != null ? _some2 : false;
        },
        image: "email"
      },
      slack: {
        title: "connectivity.slack",
        events: (data) => {
          var _slackSubscriptions;
          return (data == null ? void 0 : (_slackSubscriptions = data.slackSubscriptions) == null ? void 0 : _slackSubscriptions.length) || 0;
        },
        isActive: (data) => !!(data != null && data.slackSubscriptions.some(({
          isActive
        }) => isActive)),
        image: "slack"
      },
      webhook: {
        title: "connectivity.webhook",
        events: (data) => (data == null ? void 0 : data.length) || 0,
        isActive: (data) => {
          var _some3;
          return (_some3 = data == null ? void 0 : data.some(({
            isActive
          }) => isActive)) != null ? _some3 : false;
        },
        image: "webhook"
      }
    };
  }
});

// node_modules/@frontegg/redux-store/connectivity/actions.js
var _excluded71, _excluded226, actions_default35;
var init_actions35 = __esm({
  "node_modules/@frontegg/redux-store/connectivity/actions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_consts3();
    init_helpers();
    init_state34();
    init_constants3();
    _excluded71 = ["id"];
    _excluded226 = ["id", "enabled"];
    actions_default35 = (store, api2, sharedActions) => {
      const type2ApiGet = {
        slack: api2.connectivity.getSlackConfiguration,
        email: api2.connectivity.getEmailConfiguration,
        sms: api2.connectivity.getSMSConfiguration,
        webhook: api2.connectivity.getWebhooksConfigurations,
        categories: api2.connectivity.getCategories,
        channelMap: api2.connectivity.getChannelMaps
      };
      const addApi = ["categories", "channelMap"];
      const type2ApiPost = {
        slack: api2.connectivity.postSlackConfiguration,
        email: api2.connectivity.postEmailConfiguration,
        sms: api2.connectivity.postSMSConfiguration,
        webhook: api2.connectivity.postWebhooksConfiguration
      };
      const setConnectivityState = (state) => {
        Object.assign(store.connectivity, state);
      };
      const postWebhookRetryResult = (result) => {
        var _store$connectivity$r;
        const retryResult = (_store$connectivity$r = store.connectivity.retryResult) != null ? _store$connectivity$r : {};
        store.connectivity.retryResult = _extends({}, retryResult, result);
      };
      const resetConnectivityState = () => {
        deepResetState(store, ["connectivity"], initialState34);
      };
      const loadConfigurationFor = async (api3, params, retryConfig) => {
        try {
          return await retryIfNeeded2(() => type2ApiGet[api3](params), retryConfig);
        } catch (e) {
          return void 0;
        }
      };
      const loadSlackChannels = async () => {
        try {
          setConnectivityState({
            slackChannels: {
              isLoading: true
            }
          });
          const data = await api2.connectivity.getSlackChannels();
          setConnectivityState({
            error: void 0,
            slackChannels: {
              isLoading: false,
              data
            }
          });
        } catch (e) {
          setConnectivityState({
            error: void 0,
            slackChannels: {
              isLoading: false
            }
          });
        }
      };
      const loadConnectivityChannels = async (_payload) => {
        const payload = _payload != null ? _payload : channels;
        setConnectivityState({
          isLoading: true
        });
        try {
          const values = await Promise.all([
            // @ts-ignore
            ...payload.map((a) => loadConfigurationFor(a, void 0, DEFAULT_RETRY_CONFIG)),
            // @ts-ignore
            loadConfigurationFor("categories", void 0, DEFAULT_RETRY_CONFIG),
            // @ts-ignore
            (async () => {
              const res = await Promise.all(payload.map((ch) => loadConfigurationFor("channelMap", ch, DEFAULT_RETRY_CONFIG)));
              return res.reduce((acc, curr, idx) => _extends({}, acc, {
                [`${payload[idx]}`]: curr
              }), {});
            })()
          ]);
          const webhooks = await loadConfigurationFor("webhook", void 0, DEFAULT_RETRY_CONFIG);
          const data = values.reduce((acc, curr, idx) => {
            if (payload[idx]) {
              if (values[values.length - 1][payload[idx]].length) {
                return _extends({}, acc, {
                  [`${payload[idx]}`]: curr,
                  list: [...acc.list, {
                    id: idx,
                    key: payload[idx],
                    events: channels2Platform[payload[idx]].events(curr),
                    active: channels2Platform[payload[idx]].isActive(curr),
                    platform: channels2Platform[payload[idx]].title,
                    image: channels2Platform[payload[idx]].image
                  }]
                });
              } else {
                return acc;
              }
            } else {
              return _extends({}, acc, {
                [`${addApi[idx - payload.length]}`]: curr
              });
            }
          }, {
            list: [],
            webhook: webhooks
          });
          setConnectivityState(_extends({}, data, {
            error: void 0,
            isSaving: false,
            isLoading: false
          }));
        } catch (e) {
          setConnectivityState({
            isLoading: false,
            error: errorHandler(e)
          });
        }
      };
      const postSlackData = async (payload) => {
        var _store$connectivity$s;
        const stateSlackSubscriptions = (_store$connectivity$s = store.connectivity.slack) == null ? void 0 : _store$connectivity$s.slackSubscriptions;
        if (!stateSlackSubscriptions) {
          return;
        }
        const {
          slackSubscriptions
        } = payload;
        await Promise.all([...slackSubscriptions.reduce((acc, curr) => {
          var _curr$slackEvents$0$c, _curr$slackEvents$0$c2;
          if (!curr.id && curr.slackEvents && (_curr$slackEvents$0$c = curr.slackEvents[0].channelIds) != null && _curr$slackEvents$0$c.length) {
            return [...acc, curr];
          }
          const el = stateSlackSubscriptions == null ? void 0 : stateSlackSubscriptions.find((_ref) => {
            let {
              id
            } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded71);
            return id === curr.id && JSON.stringify(_extends({
              id
            }, props)) !== JSON.stringify(curr);
          });
          if (el && curr.slackEvents && (_curr$slackEvents$0$c2 = curr.slackEvents[0].channelIds) != null && _curr$slackEvents$0$c2.length) {
            return [...acc, curr];
          }
          return acc;
        }, []).map((el) => type2ApiPost.slack(el)), ...slackSubscriptions.reduce((acc, curr) => {
          if (curr.id && !curr.slackEvents[0].channelIds.length) {
            return [...acc, curr];
          }
          return acc;
        }, []).map((el) => api2.connectivity.deleteSlackConfiguration(el))]);
      };
      const postEmailSMSData = async (payload, type) => {
        const processIds = store.connectivity.processIds;
        const stateData = store.connectivity[type];
        if (!stateData) return;
        let actionsResult = [];
        try {
          actionsResult = await Promise.all([
            // create new
            ...payload.reduce((acc, curr) => {
              const state = stateData.find(({
                eventKey
              }) => eventKey === curr.eventKey);
              if (!state && curr.subscriptions[0].recipients.filter((el) => el).length) {
                return [...acc, curr];
              }
              return acc;
            }, []).map((data) => {
              if (type === "email") {
                return api2.connectivity.postEmailConfiguration(data);
              } else {
                return api2.connectivity.postSMSConfiguration(data);
              }
            }),
            ...payload.reduce((acc, curr) => {
              const state = stateData.find(({
                eventKey
              }) => eventKey === curr.eventKey);
              if (state && JSON.stringify(state) !== JSON.stringify(curr)) {
                return [...acc, curr];
              }
              return acc;
            }, []).map((data) => {
              const {
                subscriptions,
                eventKey
              } = data;
              const _subscriptions$ = subscriptions[0], {
                id = "",
                enabled
              } = _subscriptions$, body = _objectWithoutPropertiesLoose(_subscriptions$, _excluded226);
              return Promise.all([type === "email" ? api2.connectivity.patchEmailConfiguration({
                eventKey,
                enabled
              }) : api2.connectivity.patchSMSConfiguration({
                eventKey,
                enabled
              }), type === "email" ? api2.connectivity.putEmailSubscriptions(id, eventKey, _extends({}, body, {
                enabled
              })) : api2.connectivity.putSMSSubscriptions(id, eventKey, _extends({}, body, {
                enabled
              }))]);
            }),
            // delete record with empty recipients
            ...payload.reduce((acc, curr) => {
              const state = stateData.find(({
                eventKey
              }) => eventKey === curr.eventKey);
              if (state && state.subscriptions[0].recipients.length && !curr.subscriptions[0].recipients.filter((el) => !!el).length) {
                return [...acc, curr];
              }
              return acc;
            }, []).map(({
              eventKey,
              subscriptions
            }) => {
              if (type === "email") {
                return api2.connectivity.deleteEmailSubscriptions(eventKey, subscriptions[0].id || "");
              } else {
                return api2.connectivity.deleteSMSSubscriptions(eventKey, subscriptions[0].id || "");
              }
            })
          ]);
        } catch {
        }
        if (actionsResult.length) {
          const newData = await loadConfigurationFor(type);
          setConnectivityState({
            error: void 0,
            isSaving: false,
            [`${type}`]: newData,
            processIds: newData.id ? processIds.filter((el) => el !== newData.id) : processIds
          });
          await checkNewStatus(type, newData);
        } else {
          setConnectivityState({
            error: void 0,
            isSaving: false,
            [`${type}`]: stateData,
            processIds
          });
        }
      };
      const checkNewStatus = async (platform, data) => {
        const {
          list
        } = store.connectivity;
        const currPlatform = list.find(({
          key
        }) => key === platform);
        if (!currPlatform) return;
        const newActive = channels2Platform[platform].isActive(data);
        if (newActive === currPlatform.active) return;
        setConnectivityState({
          list: list.map((elm) => elm.key === platform ? _extends({}, elm, {
            active: newActive
          }) : elm)
        });
      };
      const postChannelData = async (payload) => {
        const {
          platform,
          data,
          callback
        } = payload;
        const processIds = store.connectivity.processIds;
        try {
          setConnectivityState({
            isSaving: true,
            //@ts-ignore
            processIds: platform === "webhook" ? [data._id, ...processIds] : processIds
          });
          if (platform === "slack") {
            await postSlackData(data);
          } else if (["sms", "email"].includes(platform)) {
            await postEmailSMSData(data, platform);
          } else {
            await type2ApiPost[platform](data);
          }
          if (!["sms", "email"].includes(platform)) {
            const newData = await loadConfigurationFor(platform);
            if (platform === "webhook") {
              newData.id = data._id;
            }
            setConnectivityState({
              error: void 0,
              isSaving: false,
              [`${platform}`]: newData,
              processIds: newData.id ? processIds.filter((el) => el !== newData.id) : processIds
            });
            await checkNewStatus(platform, newData);
            callback == null ? void 0 : callback(true);
          }
        } catch (e) {
          setConnectivityState({
            error: errorHandler(e),
            isSaving: false,
            isLoading: false
          });
        }
      };
      const postSlackCode = async (payload) => {
        try {
          await api2.connectivity.postSlackCode(payload);
        } catch {
        }
        setConnectivityState({
          error: void 0,
          isSaving: false
        });
      };
      const loadSlackPermissions = async () => {
        const slackChannels = store.connectivity.slackChannels;
        try {
          setConnectivityState({
            slackChannels: _extends({}, slackChannels, {
              isLoadingScope: true
            })
          });
          const {
            clientId
          } = await api2.connectivity.getSlackScope();
          setConnectivityState({
            slackChannels: {
              error: void 0,
              clientId,
              isLoadingScope: false,
              isLoading: false
            }
          });
        } catch {
          setConnectivityState({
            slackChannels: {
              error: void 0,
              isLoadingScope: false,
              isLoading: false
            }
          });
        }
      };
      const deleteWebhookConfig = async (payload) => {
        const {
          callback,
          webhookId
        } = payload;
        const processIds = store.connectivity.processIds;
        try {
          setConnectivityState({
            isSaving: true
          });
          await api2.connectivity.deleteWebhooksConfiguration(webhookId);
        } catch (e) {
          callback == null ? void 0 : callback(null, errorHandler(e));
        }
        const newData = await loadConfigurationFor("webhook");
        if (newData) {
          setConnectivityState({
            error: void 0,
            isSaving: false,
            webhook: newData,
            processIds: newData.id ? processIds.filter((el) => el !== newData.id) : processIds
          });
        }
        callback == null ? void 0 : callback(true);
      };
      const postWebhookTest = async (payload) => {
        try {
          setConnectivityState({
            isTesting: true
          });
          const {
            statusCode,
            body
          } = await api2.connectivity.postWebhookTest(payload);
          if ([201, 200].includes(statusCode)) {
            const message = JSON.stringify(body, null, 2);
            setConnectivityState({
              isTesting: false,
              testResult: {
                status: "success",
                message
              }
            });
          } else {
            setConnectivityState({
              isTesting: false,
              testResult: {
                status: "failed"
              }
            });
          }
        } catch (e) {
          setConnectivityState({
            isTesting: false,
            testResult: {
              status: "failed",
              message: errorHandler(e)
            }
          });
        }
      };
      const postWebhookRetry = async (payload) => {
        try {
          const {
            statusCode
          } = await api2.connectivity.postWebhookRetry(payload);
          postWebhookRetryResult({
            [payload]: {
              isProcess: false,
              success: statusCode === 202
            }
          });
        } catch (e) {
          postWebhookRetryResult({
            [payload]: {
              isProcess: false,
              success: false
            }
          });
        }
      };
      const loadWebhookLogs = async (payload) => {
        const {
          id,
          limit,
          offset
        } = payload;
        const webhookLogs = store.connectivity.webhookLogs;
        try {
          setConnectivityState({
            webhookLogs: _extends({}, webhookLogs, {
              isLoading: true
            })
          });
          const data = await api2.connectivity.getWebhookLog(id, offset, limit);
          setConnectivityState({
            error: void 0,
            webhookLogs: _extends({
              isLoading: false
            }, data)
          });
        } catch (e) {
          setConnectivityState({
            error: void 0,
            webhookLogs: {
              isLoading: false
            }
          });
        }
      };
      const cleanWebhookTestData = () => {
        setConnectivityState({
          testResult: void 0
        });
      };
      const cleanWebhookLogsData = async () => {
        setConnectivityState({
          webhookLogs: void 0
        });
      };
      const cleanWebhookTestMessage = async (state) => {
        var _state$testResult;
        setConnectivityState({
          testResult: {
            status: (_state$testResult = state.testResult) == null ? void 0 : _state$testResult.status,
            message: void 0
          }
        });
      };
      const cleanError = async () => {
        setConnectivityState({
          error: void 0
        });
      };
      const cleanSlackData = async () => {
        setConnectivityState({
          slackChannels: {
            isLoading: false
          }
        });
      };
      return {
        setConnectivityState,
        // @deprecated Use  resetConnectivityState
        initData: resetConnectivityState,
        resetConnectivityState,
        // @deprecated Use loadSlackChannels
        loadSlackActions: loadSlackChannels,
        loadSlackChannels,
        // @deprecated Use loadConnectivityChannels
        loadDataAction: loadConnectivityChannels,
        loadConnectivityChannels,
        // @deprecated Use postChannelData
        postDataAction: postChannelData,
        postChannelData,
        // @deprecated Use postSlackCode
        postCodeAction: postSlackCode,
        postSlackCode,
        // @deprecated Use loadSlackPermissions
        loadScope: loadSlackPermissions,
        loadSlackPermissions,
        // @deprecated Use deleteWebhookConfig
        deleteWebhookConfigAction: deleteWebhookConfig,
        deleteWebhookConfig,
        // @deprecated Use postWebhookTest
        postWebhookTestAction: postWebhookTest,
        postWebhookTest,
        // @deprecated Use postWebhookRetry
        postWebhookRetryAction: postWebhookRetry,
        postWebhookRetry,
        // @deprecated Use loadWebhookLogs
        loadWebhookLogsAction: loadWebhookLogs,
        loadWebhookLogs,
        cleanWebhookTestData,
        cleanWebhookLogsData,
        cleanWebhookTestMessage,
        cleanError,
        cleanSlackData
      };
    };
  }
});

// node_modules/@frontegg/redux-store/connectivity/index.js
var init_connectivity2 = __esm({
  "node_modules/@frontegg/redux-store/connectivity/index.js"() {
    init_state34();
    init_actions35();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Checkout/interfaces.js
var init_interfaces61 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Checkout/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Information/interfaces.js
var init_interfaces62 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Information/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/PaymentMethod/interfaces.js
var PaymentMethodType2;
var init_interfaces63 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/PaymentMethod/interfaces.js"() {
    (function(PaymentMethodType3) {
      PaymentMethodType3["UNKNWON"] = "unknown";
      PaymentMethodType3["CARD"] = "card";
    })(PaymentMethodType2 || (PaymentMethodType2 = {}));
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Invoices/interfaces.js
var init_interfaces64 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Invoices/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Subscription/interfaces.js
var init_interfaces65 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Subscription/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/interfaces.js
var init_interfaces66 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/interfaces.js"() {
    init_interfaces62();
    init_interfaces63();
    init_interfaces64();
    init_interfaces65();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Plans/interfaces.js
var init_interfaces67 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Plans/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Stripe/interfaces.js
var init_interfaces68 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Stripe/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Config/interfaces.js
var init_interfaces69 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Config/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/subscriptions/VendorPublicConfig/interfaces.js
var init_interfaces70 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/VendorPublicConfig/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Config/state.js
var initialState35, state_default35;
var init_state35 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Config/state.js"() {
    init_proxy();
    initialState35 = {
      loading: false,
      error: null,
      fetching: true,
      config: null
    };
    state_default35 = (overrideState) => createProxy2(initialState35, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/interfaces.js
var PaymentProvider, SubscriptionStatus, SubscriptionCancellationPolicy;
var init_interfaces71 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/interfaces.js"() {
    (function(PaymentProvider2) {
      PaymentProvider2["STRIPE"] = "Stripe";
    })(PaymentProvider || (PaymentProvider = {}));
    (function(SubscriptionStatus2) {
      SubscriptionStatus2["ACTIVE"] = "ACTIVE";
      SubscriptionStatus2["CANCELED"] = "CANCELED";
      SubscriptionStatus2["INCOMPLETE"] = "INCOMPLETE";
      SubscriptionStatus2["EXPIRED"] = "EXPIRED";
      SubscriptionStatus2["TRIALING"] = "TRIALING";
    })(SubscriptionStatus || (SubscriptionStatus = {}));
    (function(SubscriptionCancellationPolicy2) {
      SubscriptionCancellationPolicy2["AT_PERIOD_END"] = "atPeriodEnd";
    })(SubscriptionCancellationPolicy || (SubscriptionCancellationPolicy = {}));
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Config/actions.js
var actions_default36;
var init_actions36 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Config/actions.js"() {
    init_helpers();
    init_state35();
    init_rest_api();
    init_interfaces71();
    actions_default36 = (store, api2, sharedActions) => {
      const setPaymentConfigState = (state) => {
        Object.assign(store.subscriptions.config, state);
      };
      const resetPaymentConfigState = () => {
        deepResetState(store, ["subscriptions", "config"], initialState35);
      };
      const setPaymentConfigError = (error) => {
        Object.assign(store.subscriptions.config, {
          error,
          loading: false,
          fetching: false
        });
      };
      const loadStripePaymentConfiguration = async () => {
        setPaymentConfigState({
          loading: true
        });
        try {
          const response = await api2.subscriptions.getStripePaymentProviderConfiguration();
          const config = {
            paymentProvider: PaymentProvider.STRIPE,
            apiKey: response.publishableKey
          };
          setPaymentConfigState({
            config
          });
          setPaymentConfigState({
            loading: false,
            fetching: false
          });
        } catch (e) {
          setPaymentConfigError(errorHandler(e));
        }
      };
      const loadPaymentConfiguration = async () => {
        setPaymentConfigState({
          loading: true
        });
        try {
          var _await$api$subscripti;
          const response = (_await$api$subscripti = await api2.subscriptions.getPaymentProviders()) != null ? _await$api$subscripti : [];
          const stripePaymentProvider = response.find((paymentProvider) => paymentProvider.status === "1" && paymentProvider.providerType === ProviderType.Stripe);
          if (stripePaymentProvider) {
            await loadStripePaymentConfiguration();
          } else {
            setPaymentConfigError(errorHandler("Payment provider not configured"));
          }
        } catch (e) {
          setPaymentConfigError(errorHandler(e));
        }
      };
      return {
        setPaymentConfigState,
        resetPaymentConfigState,
        loadPaymentConfiguration
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Config/index.js
var init_Config = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Config/index.js"() {
    init_state35();
    init_actions36();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Information/state.js
var initialState36, state_default36;
var init_state36 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Information/state.js"() {
    init_proxy();
    initialState36 = {
      loading: false,
      error: null,
      fetching: true
    };
    state_default36 = (overrideState) => createProxy2(initialState36, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/helpers.js
function toSubscriptionCancellation({
  policy
}) {
  return {
    policy: toSubscriptionCancellationPolicy(policy)
  };
}
function toSubscriptionCancellationPolicy(policy) {
  return SubscriptionCancellationPolicy.AT_PERIOD_END;
}
function toSubscriptionStatus(status) {
  switch (status) {
    case ISubscriptionStatus.ACTIVE:
      return SubscriptionStatus.ACTIVE;
    case ISubscriptionStatus.INCOMPLETE:
      return SubscriptionStatus.INCOMPLETE;
    case ISubscriptionStatus.CANCELED:
      return SubscriptionStatus.CANCELED;
    case ISubscriptionStatus.EXPIRED:
      return SubscriptionStatus.EXPIRED;
    case ISubscriptionStatus.TRIALING:
      return SubscriptionStatus.TRIALING;
    default:
      return SubscriptionStatus.EXPIRED;
  }
}
var init_helpers9 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/helpers.js"() {
    init_rest_api();
    init_interfaces71();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Information/actions.js
var actions_default37;
var init_actions37 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Information/actions.js"() {
    init_extends();
    init_state36();
    init_helpers();
    init_rest_api();
    init_interfaces71();
    init_helpers9();
    actions_default37 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setBillingInformationState = (state) => {
        Object.assign(store.subscriptions.billing.information, state);
      };
      const resetBillingInformationState = () => {
        deepResetState(store, ["subscriptions", "billing", "information"], initialState36);
      };
      const setInformationError = (error) => {
        setBillingInformationState({
          error,
          loading: false,
          fetching: false
        });
      };
      const loadSummaries = async (tenantId, forceActive) => {
        setBillingInformationState({
          loading: true
        });
        try {
          var _planResponse$price, _planResponse$price2;
          const summary = await api2.subscriptions.getSubscriptionSummaries(tenantId);
          const {
            currentPlanId,
            externallyManaged
          } = summary;
          let subscriptionResponse = null;
          let planResponse;
          if (!externallyManaged) {
            [, planResponse] = await Promise.all([actions.loadSubscription(), api2.subscriptions.getSubscriptionPlan(currentPlanId)]);
            subscriptionResponse = store.subscriptions.billing.subscription.subscription || null;
          } else {
            planResponse = await api2.subscriptions.getSubscriptionPlan(currentPlanId);
          }
          setBillingInformationState(_extends({
            loading: false,
            fetching: false,
            summary
          }, subscriptionResponse ? {
            subscription: {
              id: subscriptionResponse.id,
              externalId: subscriptionResponse.externalId,
              startDate: subscriptionResponse.startDate,
              currentPeriodStart: subscriptionResponse.currentPeriodStart,
              currentPeriodEnd: subscriptionResponse.currentPeriodEnd,
              status: forceActive ? SubscriptionStatus.ACTIVE : toSubscriptionStatus(subscriptionResponse.status),
              cancellation: subscriptionResponse.cancellation && toSubscriptionCancellation(subscriptionResponse.cancellation),
              trialEnd: subscriptionResponse.trialEnd ? subscriptionResponse.trialEnd : null
            }
          } : {}, planResponse ? {
            plan: {
              id: planResponse.id,
              name: planResponse.name,
              description: planResponse.description,
              price: ((_planResponse$price = planResponse.price) == null ? void 0 : _planResponse$price.amount) || 0,
              currency: ((_planResponse$price2 = planResponse.price) == null ? void 0 : _planResponse$price2.currency) || "usd",
              recurringInterval: "month",
              slug: planResponse.slug
            }
          } : {}));
        } catch (e) {
          setInformationError(errorHandler(e));
        }
      };
      const loadBillingInformation = async (forceActive) => {
        var _store$subscriptions$, _store$auth$user;
        const paymentProvider = (_store$subscriptions$ = store.subscriptions.config.config) == null ? void 0 : _store$subscriptions$.paymentProvider;
        const tenantId = (_store$auth$user = store.auth.user) == null ? void 0 : _store$auth$user.tenantId;
        if (!paymentProvider || !tenantId) {
          setInformationError(new FronteggApiError(!paymentProvider ? "Internal feature failure" : "Not authorized", 500, null));
          return;
        }
        await loadSummaries(tenantId, forceActive);
      };
      return {
        setBillingInformationState,
        resetBillingInformationState,
        loadSummaries,
        loadBillingInformation
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Information/index.js
var init_Information = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Information/index.js"() {
    init_state36();
    init_actions37();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Invoices/state.js
var initialState37, state_default37;
var init_state37 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Invoices/state.js"() {
    init_proxy();
    initialState37 = {
      loading: false,
      error: null,
      fetching: true,
      invoices: [],
      invoiceDownload: {
        loading: false,
        error: null
      }
    };
    state_default37 = (overrideState) => createProxy2(initialState37, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Invoices/actions.js
var actions_default38;
var init_actions38 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Invoices/actions.js"() {
    init_state37();
    init_helpers();
    actions_default38 = (store, api2, sharedActions) => {
      const setBillingInvoiceState = (state) => {
        Object.assign(store.subscriptions.billing.invoices, state);
      };
      const resetBillingInvoiceState = () => {
        deepResetState(store, ["subscriptions", "billing", "invoices"], initialState37);
      };
      const setBillingInvoiceError = (error) => {
        setBillingInvoiceState({
          error,
          loading: false,
          fetching: false
        });
      };
      const setBillingInvoiceDownloadState = (state) => {
        Object.assign(store.subscriptions.billing.invoices.invoiceDownload, state);
      };
      const loadInvoices = async () => {
        setBillingInvoiceState({
          loading: true
        });
        try {
          const responseInvoices = await api2.subscriptions.getSubscriptionInvoices();
          const invoices = responseInvoices.map((invoice) => ({
            id: invoice.id,
            externalId: invoice.externalId,
            subscriptionId: invoice.subscriptionId,
            paymentDate: new Date(Date.parse(invoice.paymentDate)),
            totalAmount: +((invoice.totalAmount || 0) / 100).toFixed(2),
            currency: invoice.currency || "usd",
            paid: invoice.paid || false,
            receiptNumber: invoice.receiptNumber
          }));
          setBillingInvoiceState({
            loading: false,
            fetching: false,
            invoices
          });
        } catch (e) {
          setBillingInvoiceError(errorHandler(e));
        }
      };
      const downloadInvoice = async (payload) => {
        setBillingInvoiceDownloadState({
          loading: true,
          error: null
        });
        try {
          await api2.subscriptions.getSubscriptionInvoicePdf(payload.invoiceId, payload.filename);
          setBillingInvoiceDownloadState({
            loading: false,
            error: null
          });
        } catch (e) {
          setBillingInvoiceDownloadState({
            loading: false,
            error: errorHandler(e, null)
          });
        }
      };
      return {
        setBillingInvoiceState,
        resetBillingInvoiceState,
        // @deprecated use loadBillingInvoices instead
        loadInvoices,
        loadBillingInvoices: loadInvoices,
        // @deprecated use downloadBillingInvoice instead
        downloadInvoice,
        downloadBillingInvoice: downloadInvoice
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Invoices/index.js
var init_Invoices = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Invoices/index.js"() {
    init_state37();
    init_actions38();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/PaymentMethod/state.js
var initialState38, state_default38;
var init_state38 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/PaymentMethod/state.js"() {
    init_proxy();
    initialState38 = {
      loading: false,
      error: null,
      fetching: true
    };
    state_default38 = (overrideState) => createProxy2(initialState38, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/PaymentMethod/actions.js
var actions_default39;
var init_actions39 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/PaymentMethod/actions.js"() {
    init_extends();
    init_helpers();
    init_state38();
    actions_default39 = (store, api2, sharedActions) => {
      const setBillingPaymentMethodState = (state) => {
        Object.assign(store.subscriptions.billing.paymentMethod, state);
      };
      const resetBillingPaymentMethodState = () => {
        deepResetState(store, ["subscriptions", "billing", "paymentMethod"], initialState38);
      };
      const __setLoading = (loading) => {
        setBillingPaymentMethodState({
          loading
        });
      };
      const __setError = (error) => {
        setBillingPaymentMethodState({
          error,
          loading: false,
          fetching: false
        });
      };
      const loadPaymentMethod = async () => {
        __setLoading(true);
        try {
          const paymentMethods = await api2.subscriptions.getPaymentMethods();
          const paymentMethod = paymentMethods[0];
          setBillingPaymentMethodState({
            paymentMethod,
            loading: false,
            fetching: false
          });
        } catch (e) {
          __setError(errorHandler(e));
        }
      };
      const updatePaymentMethodBillingDetails = async (payload) => {
        __setLoading(true);
        const {
          id,
          email,
          address,
          callback
        } = payload;
        try {
          await api2.subscriptions.updatePaymentMethodBillingDetails(id, _extends({
            email
          }, address));
          await loadPaymentMethod();
          callback == null ? void 0 : callback(true);
        } catch (e) {
          __setError(errorHandler(e));
          callback == null ? void 0 : callback(false, e);
        } finally {
          __setLoading(false);
        }
      };
      const submitPaymentMethod = async () => {
        __setLoading(true);
      };
      const submitPaymentMethodError = async (error) => {
        __setError(error);
      };
      const submitPaymentMethodSuccess = async () => {
        return await loadPaymentMethod();
      };
      return {
        setBillingPaymentMethodState,
        resetBillingPaymentMethodState,
        loadPaymentMethod,
        submitPaymentMethod,
        submitPaymentMethodError,
        submitPaymentMethodSuccess,
        updatePaymentMethodBillingDetails
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/PaymentMethod/index.js
var init_PaymentMethod = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/PaymentMethod/index.js"() {
    init_state38();
    init_actions39();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Subscription/state.js
var initialState39, state_default39;
var init_state39 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Subscription/state.js"() {
    init_proxy();
    initialState39 = {
      loading: false,
      error: null,
      fetching: true,
      cancellation: {
        loading: false,
        error: null
      },
      renewal: {
        loading: false,
        error: null
      }
    };
    state_default39 = (overrideState) => createProxy2(initialState39, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Subscription/actions.js
var actions_default40;
var init_actions40 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Subscription/actions.js"() {
    init_state39();
    init_helpers();
    init_rest_api();
    actions_default40 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setBillingSubscriptionState = (state) => {
        Object.assign(store.subscriptions.billing.subscription, state);
      };
      const resetBillingSubscriptionState = () => {
        deepResetState(store, ["subscriptions", "billing", "subscription"], initialState39);
      };
      const __setError = (error) => {
        setBillingSubscriptionState({
          error,
          loading: false,
          fetching: false
        });
      };
      const __setLoading = (loading) => {
        setBillingSubscriptionState({
          loading
        });
      };
      const setCancellationLoading = (loading) => {
        Object.assign(store.subscriptions.billing.subscription.cancellation, {
          loading
        });
      };
      const setCancellationError = (error) => {
        Object.assign(store.subscriptions.billing.subscription.cancellation, {
          error
        });
      };
      const setRenewalLoading = (loading) => {
        Object.assign(store.subscriptions.billing.subscription.renewal, {
          loading
        });
      };
      const setRenewalError = (error) => {
        Object.assign(store.subscriptions.billing.subscription.renewal, {
          error
        });
      };
      const loadSubscription = async () => {
        __setLoading(true);
        try {
          const [subscription] = await api2.subscriptions.getManagedSubscriptions();
          setBillingSubscriptionState({
            subscription,
            fetching: false,
            loading: false,
            error: null
          });
        } catch (e) {
          __setError(errorHandler(e));
        }
      };
      const loadSubscriptionTenant = async () => {
        var _store$auth$user;
        const tenantId = (_store$auth$user = store.auth.user) == null ? void 0 : _store$auth$user.tenantId;
        if (!tenantId) {
          __setError(new FronteggApiError("TenantId is not defined", 500, null));
          return;
        }
        await actions.loadSummaries(tenantId);
      };
      const cancelSubscription = async () => {
        const {
          subscription
        } = store.subscriptions.billing.subscription;
        if (!subscription) {
          setCancellationError(new FronteggApiError("Subscription not found", 500, null));
          return;
        }
        if (subscription != null && subscription.externallyManaged) {
          setCancellationError(new FronteggApiError("Billing is externally managed", 500, null));
          return;
        }
        const {
          id: subscriptionId,
          cancellation,
          status
        } = subscription || {};
        const isCancellable = !cancellation && status === ISubscriptionStatus.ACTIVE;
        if (isCancellable) {
          try {
            setCancellationLoading(true);
            await api2.subscriptions.cancelManagedSubscription(subscriptionId);
            await loadSubscription();
            setCancellationLoading(false);
          } catch (e) {
            setCancellationError(errorHandler(e));
          }
        }
      };
      const renewSubscription = async () => {
        const {
          subscription
        } = store.subscriptions.billing.subscription;
        if (!subscription) {
          setRenewalError(new FronteggApiError("Subscription not found", 500, null));
          return;
        }
        if (subscription != null && subscription.externallyManaged) {
          setRenewalError(new FronteggApiError("Billing is externally managed", 500, null));
          return;
        }
        const {
          id: subscriptionId,
          cancellation
        } = subscription || {};
        const renewable = (cancellation == null ? void 0 : cancellation.policy) === ISubscriptionCancellationPolicy.AT_PERIOD_END;
        if (renewable) {
          try {
            setRenewalLoading(true);
            await api2.subscriptions.renewManagedSubscription(subscriptionId);
            await loadSubscription();
            setRenewalLoading(false);
          } catch (e) {
            setRenewalError(errorHandler(e));
          }
        }
      };
      return {
        // reducers
        setBillingSubscriptionState,
        resetBillingSubscriptionState,
        setCancellationLoading,
        setCancellationError,
        setRenewalLoading,
        setRenewalError,
        // actions
        loadSubscription,
        loadSubscriptionTenant,
        cancelSubscription,
        renewSubscription
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/Subscription/index.js
var init_Subscription = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/Subscription/index.js"() {
    init_state39();
    init_actions40();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Billing/index.js
var createBillingState, buildBillingActions;
var init_Billing = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Billing/index.js"() {
    init_extends();
    init_Information();
    init_Invoices();
    init_PaymentMethod();
    init_Subscription();
    init_proxy();
    createBillingState = (overrideState) => {
      return createProxy2({
        information: state_default36(overrideState == null ? void 0 : overrideState.information),
        invoices: state_default37(overrideState == null ? void 0 : overrideState.invoices),
        paymentMethod: state_default38(overrideState == null ? void 0 : overrideState.paymentMethod),
        subscription: state_default39(overrideState == null ? void 0 : overrideState.subscription)
      });
    };
    buildBillingActions = (store, api2, actions) => {
      const informationActions = actions_default37(store, api2, actions);
      const paymentMethodActions = actions_default39(store, api2, actions);
      const invoicesActions = actions_default38(store, api2, actions);
      const subscriptionActions = actions_default40(store, api2, actions);
      return [_extends({}, informationActions, paymentMethodActions, invoicesActions, subscriptionActions), {
        information: informationActions,
        invoices: invoicesActions,
        paymentMethod: paymentMethodActions,
        subscription: subscriptionActions
      }];
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Plans/state.js
var initialState40, state_default40;
var init_state40 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Plans/state.js"() {
    init_proxy();
    initialState40 = {
      loading: false,
      error: null,
      fetching: true,
      plans: []
    };
    state_default40 = (overrideState) => createProxy2(initialState40, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Plans/actions.js
var actions_default41;
var init_actions41 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Plans/actions.js"() {
    init_helpers();
    init_state40();
    actions_default41 = (store, api2, sharedActions) => {
      const setPlansState = (state) => {
        Object.assign(store.subscriptions.plans, state);
      };
      const resetPlansState = () => {
        deepResetState(store, ["subscriptions", "plans"], initialState40);
      };
      const setPlansError = (error) => {
        setPlansState({
          loading: false,
          fetching: false,
          error
        });
      };
      const loadPlans = async () => {
        setPlansState({
          loading: true
        });
        try {
          const products = await api2.subscriptions.getSubscriptionPlans();
          const plans = products.map((item) => {
            var _item$price, _item$price2;
            return {
              id: item.id,
              name: item.name,
              description: item.description,
              price: ((_item$price = item.price) == null ? void 0 : _item$price.amount) || 0,
              currency: ((_item$price2 = item.price) == null ? void 0 : _item$price2.currency) || "usd",
              recurringInterval: "month",
              slug: item.slug
            };
          });
          setPlansState({
            fetching: false,
            loading: false,
            plans
          });
        } catch (e) {
          setPlansError(errorHandler(e));
        }
      };
      return {
        setPlansState,
        resetPlansState,
        loadPlans
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Plans/index.js
var init_Plans = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Plans/index.js"() {
    init_state40();
    init_actions41();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Checkout/state.js
var initialState41, state_default41;
var init_state41 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Checkout/state.js"() {
    init_proxy();
    initialState41 = {
      fetching: true,
      loading: false,
      error: null,
      confirmed: false
    };
    state_default41 = (overrideState) => createProxy2(initialState41, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Checkout/actions.js
var actions_default42;
var init_actions42 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Checkout/actions.js"() {
    init_extends();
    init_helpers();
    init_state41();
    init_rest_api();
    actions_default42 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setCheckoutState = (state) => {
        Object.assign(store.subscriptions.checkout, state);
      };
      const resetCheckoutState = () => {
        deepResetState(store, ["subscriptions", "checkout"], initialState41);
      };
      const loadCheckout = () => {
        setCheckoutState({
          fetching: false,
          loading: false,
          error: null,
          confirmed: false
        });
      };
      const resetCheckout = () => {
        setCheckoutState({
          loading: false,
          error: null,
          confirmed: false
        });
      };
      const submitCheckout = () => {
        setCheckoutState({
          loading: true,
          error: null
        });
      };
      const confirmCheckout = async (payload) => {
        const {
          paymentMethodId,
          planId
        } = payload;
        const subscription = store.subscriptions.billing.subscription.subscription;
        const summary = store.subscriptions.billing.information.summary;
        const isTrialing = (subscription == null ? void 0 : subscription.status) === ISubscriptionStatus.TRIALING;
        const hasPaymentMethod = !!(summary != null && summary.paymentMethodId);
        if (!subscription) {
          setCheckoutState({
            loading: false,
            error: new FronteggApiError("Subscription not found", 500, null)
          });
          return;
        }
        setCheckoutState({
          loading: true,
          error: null
        });
        if (isTrialing && hasPaymentMethod) {
          setCheckoutState({
            loading: false,
            error: null,
            confirmed: true
          });
          actions.setBillingSubscriptionState({
            subscription: _extends({}, subscription, {
              status: ISubscriptionStatus.ACTIVE
            })
          });
          return;
        }
        try {
          await api2.subscriptions.updateManagedSubscription(subscription.id, {
            paymentMethodId,
            planId
          });
          await Promise.all([actions.loadBillingInformation(), actions.loadPaymentMethod(), actions.loadInvoices()]);
          setCheckoutState({
            loading: false,
            error: null,
            confirmed: true
          });
        } catch (e) {
          setCheckoutState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      const errorCheckout = (payload) => {
        setCheckoutState({
          loading: false,
          error: payload
        });
      };
      return {
        setCheckoutState,
        resetCheckoutState,
        loadCheckout,
        resetCheckout,
        submitCheckout,
        confirmCheckout,
        errorCheckout
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Checkout/index.js
var init_Checkout = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Checkout/index.js"() {
    init_state41();
    init_actions42();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Stripe/state.js
var initialState42, state_default42;
var init_state42 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Stripe/state.js"() {
    init_proxy();
    initialState42 = {
      loading: false,
      error: null,
      cardSetupIntentSecret: null
    };
    state_default42 = (overrideState) => createProxy2(initialState42, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Stripe/actions.js
var actions_default43;
var init_actions43 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Stripe/actions.js"() {
    init_state42();
    init_helpers();
    actions_default43 = (store, api2, sharedActions) => {
      const setStripeState = (state) => {
        Object.assign(store.subscriptions.stripe, state);
      };
      const resetStripeState = () => {
        deepResetState(store, ["subscriptions", "stripe"], initialState42);
      };
      const setStripeError = (error) => {
        Object.assign(store.subscriptions.stripe, {
          error,
          loading: false,
          fetching: false
        });
      };
      const createCardSetupIntentSecret = async (payload) => {
        setStripeState({
          loading: true,
          error: null,
          cardSetupIntentSecret: null
        });
        try {
          const request = {};
          if (payload) {
            request.paymentMethodId = payload;
          }
          const {
            setupIntentSecret
          } = await api2.subscriptions.createStripePaymentMethodSetupIntentSecret(request);
          setStripeState({
            cardSetupIntentSecret: setupIntentSecret,
            loading: false
          });
        } catch (e) {
          setStripeError(errorHandler(e));
        }
      };
      return {
        // loadCustomer, // not implemented
        createCardSetupIntentSecret,
        setStripeState,
        resetStripeState
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/Stripe/index.js
var init_Stripe = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/Stripe/index.js"() {
    init_state42();
    init_actions43();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/VendorPublicConfig/state.js
var initialState43, state_default43;
var init_state43 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/VendorPublicConfig/state.js"() {
    init_proxy();
    initialState43 = {
      loading: false,
      fetching: true,
      vendorPublicConfig: null
    };
    state_default43 = (overrideState) => createProxy2(initialState43, overrideState);
  }
});

// node_modules/@frontegg/redux-store/subscriptions/VendorPublicConfig/actions.js
var actions_default44;
var init_actions44 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/VendorPublicConfig/actions.js"() {
    init_state43();
    init_helpers();
    actions_default44 = (store, api2, sharedActions) => {
      const setVendorPublicConfigState = (state) => {
        Object.assign(store.subscriptions.vendorPublicConfig, state);
      };
      const resetVendorPublicConfigState = () => {
        deepResetState(store, ["subscriptions", "vendorPublicConfig"], initialState43);
      };
      const setVendorPublicConfigError = (error) => {
        Object.assign(store.subscriptions.vendorPublicConfig, {
          error,
          loading: false,
          fetching: false
        });
      };
      const setVendorPublicConfigLoading = (loading) => {
        Object.assign(store.subscriptions.vendorPublicConfig, {
          error: null,
          loading
        });
      };
      const loadVendorPublicConfiguration = async () => {
        setVendorPublicConfigLoading(true);
        try {
          const vendorPublicConfig = await api2.subscriptions.getVendorPublicConfigurations();
          setVendorPublicConfigState({
            fetching: false,
            loading: false,
            vendorPublicConfig
          });
        } catch (e) {
          setVendorPublicConfigError(errorHandler(e));
        }
      };
      return {
        setVendorPublicConfigState,
        resetVendorPublicConfigState,
        setVendorPublicConfigError,
        setVendorPublicConfigLoading,
        loadVendorPublicConfiguration
      };
    };
  }
});

// node_modules/@frontegg/redux-store/subscriptions/VendorPublicConfig/index.js
var init_VendorPublicConfig = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/VendorPublicConfig/index.js"() {
    init_state43();
    init_actions44();
  }
});

// node_modules/@frontegg/redux-store/subscriptions/index.js
var createSubscriptionsState, buildSubscriptionsActions;
var init_subscriptions3 = __esm({
  "node_modules/@frontegg/redux-store/subscriptions/index.js"() {
    init_extends();
    init_interfaces61();
    init_interfaces66();
    init_interfaces67();
    init_interfaces68();
    init_interfaces69();
    init_interfaces70();
    init_Config();
    init_Billing();
    init_Plans();
    init_Checkout();
    init_Stripe();
    init_VendorPublicConfig();
    init_proxy();
    createSubscriptionsState = (overrideState) => {
      return createProxy2({
        config: state_default35(overrideState == null ? void 0 : overrideState.config),
        billing: createBillingState(overrideState == null ? void 0 : overrideState.billing),
        plans: state_default40(overrideState == null ? void 0 : overrideState.plans),
        checkout: state_default41(overrideState == null ? void 0 : overrideState.checkout),
        stripe: state_default42(overrideState == null ? void 0 : overrideState.stripe),
        vendorPublicConfig: state_default43(overrideState == null ? void 0 : overrideState.vendorPublicConfig)
      });
    };
    buildSubscriptionsActions = (store, api2, actions) => {
      const configActions = actions_default36(store, api2, actions);
      const [billingActions, billingStateActions] = buildBillingActions(store, api2, actions);
      const plansActions = actions_default41(store, api2, actions);
      const checkoutActions = actions_default42(store, api2, actions);
      const stripeActions = actions_default43(store, api2, actions);
      const vendorPublicConfigActions = actions_default44(store, api2, actions);
      return [_extends({}, configActions, billingActions, plansActions, checkoutActions, stripeActions, vendorPublicConfigActions), {
        config: configActions,
        billing: billingStateActions,
        plans: plansActions,
        checkout: checkoutActions,
        stripe: stripeActions,
        vendorPublicConfig: vendorPublicConfigActions
      }];
    };
  }
});

// node_modules/@frontegg/redux-store/vendor/state.js
var initialState44, state_default44;
var init_state44 = __esm({
  "node_modules/@frontegg/redux-store/vendor/state.js"() {
    init_proxy();
    initialState44 = {
      loading: false
    };
    state_default44 = (overrideState) => createProxy2(initialState44, overrideState);
  }
});

// node_modules/@frontegg/redux-store/vendor/actions.js
var actions_default45;
var init_actions45 = __esm({
  "node_modules/@frontegg/redux-store/vendor/actions.js"() {
    init_extends();
    init_state44();
    init_helpers();
    actions_default45 = (store, api2, sharedActions) => {
      const setVendorState = (state) => {
        Object.assign(store.vendor, state);
      };
      const resetVendorState = () => {
        deepResetState(store, ["vendor"], initialState44);
      };
      const loadVendorPublicInfo = async (payload) => {
        setVendorState({
          loading: true
        });
        try {
          var _vendorInfo$whiteLabe;
          const vendorInfo = await retryIfNeeded2(() => api2.vendor.getVendorPublicInfo(), payload == null ? void 0 : payload.retryConfig);
          vendorInfo.whiteLabelMode = (_vendorInfo$whiteLabe = vendorInfo.whiteLabelMode) != null ? _vendorInfo$whiteLabe : false;
          setVendorState(_extends({}, vendorInfo, {
            loading: false
          }));
        } catch (e) {
          setVendorState({
            loading: false
          });
          console.error("failed to getVendorPublicInfo - ", e);
        }
      };
      return {
        setVendorState,
        resetVendorState,
        loadVendorPublicInfo,
        /**
         * @deprecated use loadVendorPublicInfo instead
         */
        loadVendorPublicConfiguration: loadVendorPublicInfo
      };
    };
  }
});

// node_modules/@frontegg/redux-store/vendor/index.js
var init_vendor2 = __esm({
  "node_modules/@frontegg/redux-store/vendor/index.js"() {
    init_state44();
    init_actions45();
  }
});

// node_modules/@frontegg/redux-store/audits/AuditLogsState/state.js
var initialState45, state_default45;
var init_state45 = __esm({
  "node_modules/@frontegg/redux-store/audits/AuditLogsState/state.js"() {
    init_proxy();
    initialState45 = {
      loading: true,
      pageOffset: 0,
      pageSize: 20,
      logs: [],
      sort: [],
      filter: [],
      totalPages: 0,
      isDownloadingCsv: false
    };
    state_default45 = (overrideState) => createProxy2(initialState45, overrideState);
  }
});

// node_modules/@frontegg/redux-store/audits/AuditLogsState/actions.js
var actions_default46;
var init_actions46 = __esm({
  "node_modules/@frontegg/redux-store/audits/AuditLogsState/actions.js"() {
    init_extends();
    init_state45();
    init_helpers();
    actions_default46 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setAuditLogsState = (state) => {
        Object.assign(store.auditLogs.auditLogsState, state);
      };
      const resetAuditLogsState = () => {
        deepResetState(store, ["auditLogs", "auditLogsState"], initialState45);
      };
      const exportAuditsCsv = async () => {
        const state = store.auditLogs.auditLogsState;
        const {
          columns
        } = store.auditLogs.auditsMetadataState;
        try {
          const filter = state.filter;
          const sort = state.sort;
          const sortParams = sort.reduce((p, n) => _extends({}, p, {
            sortBy: n.id,
            sortDirection: n.desc ? "desc" : "asc"
          }), {});
          const filterParams = filter.reduce((p, n) => _extends({}, p, {
            [n.id]: n.value
          }), {});
          setAuditLogsState({
            isDownloadingCsv: true
          });
          const outputFileName = `audits.csv`;
          await api2.audits.exportAudits(_extends({
            endpoint: "csv/v2",
            headerProps: columns,
            offset: 0,
            outputFileName
          }, sortParams, filterParams));
        } catch (e) {
          console.error("failed to export audits - ", e);
        }
        setAuditLogsState({
          isDownloadingCsv: false
        });
      };
      const loadAuditLogs = async (payload) => {
        setAuditLogsState({
          loading: !(payload != null && payload.silentLoading),
          error: null
        });
        const state = store.auditLogs.auditLogsState;
        const retryConfig = payload == null ? void 0 : payload.retryConfig;
        const {
          columns
        } = store.auditLogs.auditsMetadataState;
        try {
          var _payload$pageSize, _payload$pageOffset, _payload$filter, _payload$sort, _payload$callback;
          const pageSize = (_payload$pageSize = payload.pageSize) != null ? _payload$pageSize : state.pageSize;
          const pageOffset = (_payload$pageOffset = payload.pageOffset) != null ? _payload$pageOffset : state.pageOffset;
          const filter = (_payload$filter = payload.filter) != null ? _payload$filter : state.filter;
          const sort = (_payload$sort = payload.sort) != null ? _payload$sort : state.sort;
          setAuditLogsState({
            pageSize,
            pageOffset,
            filter,
            sort
          });
          const sortParams = sort.reduce((p, n) => _extends({}, p, {
            sortBy: n.id,
            sortDirection: n.desc ? "desc" : "asc"
          }), {});
          const filterParams = filter.reduce((p, n) => _extends({}, p, {
            [n.id]: n.value
          }), {});
          if (!columns) {
            await actions.loadAuditsMetadata({
              retryConfig
            });
          }
          const {
            data,
            total
          } = await retryIfNeeded2(() => api2.audits.getAudits(_extends({
            offset: pageOffset,
            count: pageSize
          }, sortParams, filterParams)), retryConfig);
          setAuditLogsState({
            loading: false,
            logs: data != null ? data : [],
            totalPages: +Math.ceil(total / pageSize)
          });
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
        } catch (e) {
          var _payload$callback2;
          setAuditLogsState({
            loading: false,
            error: errorHandler(e)
          });
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
        }
      };
      return {
        setAuditLogsState,
        resetAuditLogsState,
        exportAuditsCsv,
        loadAuditLogs
      };
    };
  }
});

// node_modules/@frontegg/redux-store/audits/AuditLogsState/index.js
var init_AuditLogsState = __esm({
  "node_modules/@frontegg/redux-store/audits/AuditLogsState/index.js"() {
    init_state45();
    init_actions46();
  }
});

// node_modules/@frontegg/redux-store/audits/AuditsMetadataState/state.js
var initialState46, state_default46;
var init_state46 = __esm({
  "node_modules/@frontegg/redux-store/audits/AuditsMetadataState/state.js"() {
    init_proxy();
    initialState46 = {
      loading: true
    };
    state_default46 = (overrideState) => createProxy2(initialState46, overrideState);
  }
});

// node_modules/@frontegg/redux-store/audits/AuditsMetadataState/actions.js
var actions_default47;
var init_actions47 = __esm({
  "node_modules/@frontegg/redux-store/audits/AuditsMetadataState/actions.js"() {
    init_state46();
    init_helpers();
    actions_default47 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setAuditsMetadataState = (state) => {
        Object.assign(store.auditLogs.auditsMetadataState, state);
      };
      const resetAuditsMetadataState = () => {
        deepResetState(store, ["auditLogs", "auditsMetadataState"], initialState46);
      };
      const loadAuditsMetadata = async (payload) => {
        setAuditsMetadataState({
          loading: true,
          error: null
        });
        try {
          const {
            properties
          } = await retryIfNeeded2(() => api2.metadata.getAuditsMetadata(), payload == null ? void 0 : payload.retryConfig);
          setAuditsMetadataState({
            columns: properties,
            loading: false
          });
        } catch (e) {
          setAuditsMetadataState({
            error: e,
            loading: false
          });
        }
      };
      return {
        setAuditsMetadataState,
        resetAuditsMetadataState,
        loadAuditsMetadata
      };
    };
  }
});

// node_modules/@frontegg/redux-store/audits/AuditsMetadataState/index.js
var init_AuditsMetadataState = __esm({
  "node_modules/@frontegg/redux-store/audits/AuditsMetadataState/index.js"() {
    init_state46();
    init_actions47();
  }
});

// node_modules/@frontegg/redux-store/audits/index.js
var createAuditsState, buildAuditsActions;
var init_audits2 = __esm({
  "node_modules/@frontegg/redux-store/audits/index.js"() {
    init_extends();
    init_AuditLogsState();
    init_AuditsMetadataState();
    createAuditsState = (overrideState) => {
      return {
        auditLogsState: state_default45(overrideState == null ? void 0 : overrideState.auditLogsState),
        auditsMetadataState: state_default46(overrideState == null ? void 0 : overrideState.auditsMetadataState)
      };
    };
    buildAuditsActions = (store, api2, sharedActions) => {
      return _extends({}, actions_default46(store, api2, sharedActions), actions_default47(store, api2, sharedActions));
    };
  }
});

// node_modules/@frontegg/redux-store/audits-backward-compatibility/state.js
var initialState47, state_default47;
var init_state47 = __esm({
  "node_modules/@frontegg/redux-store/audits-backward-compatibility/state.js"() {
    init_proxy();
    initialState47 = {
      total: 0,
      offset: 0,
      filter: "",
      sortBy: "createdAt",
      context: null,
      filters: [],
      rowsData: [],
      lastUpdated: /* @__PURE__ */ new Date(),
      isLoading: true,
      isFetchMore: false,
      totalToday: 0,
      currentPage: 0,
      headerProps: [],
      sortDirection: "desc",
      severeThisWeek: 0,
      predefinedFilters: [],
      isDownloadingCsv: false,
      virtualScroll: false
    };
    state_default47 = (overrideState) => createProxy2(initialState47, overrideState);
  }
});

// node_modules/@frontegg/redux-store/audits-backward-compatibility/actions.js
var defaultItemsPerPage, actions_default48;
var init_actions48 = __esm({
  "node_modules/@frontegg/redux-store/audits-backward-compatibility/actions.js"() {
    init_extends();
    defaultItemsPerPage = 20;
    actions_default48 = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const setContext = (payload) => {
        store.audits.context = payload;
      };
      const startLoading = () => {
        store.audits.isLoading = true;
      };
      const setVirtualScroll = (payload) => {
        store.audits.virtualScroll = payload;
      };
      const startRefresh = () => {
        store.audits.isLoading = true;
      };
      const startFetching = () => {
        store.audits.isFetchMore = true;
      };
      const finishLoading = () => {
        store.audits.isLoading = false;
      };
      const startDownloadingCsv = () => {
        store.audits.isDownloadingCsv = true;
      };
      const stopDownloadingCsv = () => {
        store.audits.isDownloadingCsv = false;
      };
      const loadStatsSuccess = (payload) => {
        store.audits.error = void 0;
        store.audits.totalToday = payload.totalToday;
        store.audits.severeThisWeek = payload.severeThisWeek;
      };
      const loadItemFailedAction = (payload) => {
        var _store$audits$error;
        store.audits.error = (_store$audits$error = store.audits.error) != null ? _store$audits$error : {};
        Object.assign(store.audits.error, {
          [payload.name]: payload.error
        });
      };
      const loadMetadataSuccess = (payload) => {
        store.audits.error = {};
        store.audits.headerProps = payload.properties;
        store.audits.themeAudits = payload.theme ? payload.theme.styles : {};
      };
      const loadAuditsSuccess = (payload) => {
        store.audits.error = {};
        store.audits.rowsData = payload.rowsData;
        store.audits.lastUpdated = /* @__PURE__ */ new Date();
        store.audits.total = payload.total;
      };
      const fetchMoreSuccess = (payload) => {
        store.audits.error = {};
        store.audits.offset = payload.offset;
        store.audits.currentPage = payload.currentPage;
        store.audits.isFetchMore = false;
      };
      const setFilterData = (payload) => {
        store.audits.filters = payload;
        store.audits.currentPage = 0;
        store.audits.offset = 0;
        store.audits.isLoading = true;
      };
      const textSearch = (payload) => {
        store.audits.filter = payload;
        store.audits.currentPage = 0;
        store.audits.offset = 0;
        store.audits.isLoading = true;
      };
      const onPageChange = (payload) => {
        store.audits.currentPage = payload - 1;
        store.audits.offset = store.audits.currentPage * defaultItemsPerPage;
        store.audits.isLoading = true;
      };
      const setDataSorting = (payload) => {
        store.audits.sortBy = payload.sortBy;
        store.audits.currentPage = 0;
        store.audits.sortDirection = payload.sortDirection === "asc" ? "desc" : "asc";
        store.audits.offset = 0;
        store.audits.isLoading = true;
      };
      const setPredefinedFilters = (payload) => {
        store.audits.predefinedFilters = payload;
        const filters = Object.keys(payload).map((key) => ({
          key,
          value: payload[key]
        }));
        store.audits.filters = filters;
      };
      const __loadStats = async () => {
        const {
          sortBy,
          sortDirection
        } = store.audits;
        try {
          const stats = await api2.audits.getAuditsStats({
            sortBy,
            sortDirection,
            count: defaultItemsPerPage
          });
          loadStatsSuccess(stats);
        } catch (e) {
          const errorMessage = {
            name: "stats",
            error: e
          };
          console.error("failed to load stats - ", e);
          loadItemFailedAction(errorMessage);
        }
      };
      const __loadMetadata = async () => {
        try {
          const result = await api2.metadata.getAuditsMetadata();
          loadMetadataSuccess(result);
        } catch (e) {
          const errorMessage = {
            name: "metadata",
            error: e
          };
          console.error("failed to load metadata - ", e);
          loadItemFailedAction(errorMessage);
        }
      };
      const __filterToObject = (arr) => arr.reduce((res, curr) => {
        res[curr.key] = curr.value;
        return res;
      }, {});
      const loadAudits = async (payload) => {
        const {
          filters,
          sortBy,
          sortDirection,
          filter,
          offset,
          virtualScroll
        } = store.audits;
        const {
          appendMode = virtualScroll,
          onlyOneLoad = true,
          offset: incomeOffset = 0
        } = payload || {};
        const {
          rowsData
        } = appendMode ? store.audits : {
          rowsData: []
        };
        try {
          const f2o = __filterToObject(filters);
          const {
            data,
            total
          } = await api2.audits.getAudits(_extends({}, virtualScroll && {
            paginationMode: "virtual"
          }, {
            sortDirection,
            sortBy,
            filter
          }, f2o, {
            // TODO: refactor once api become V2 with query field for virtual scroll
            offset: virtualScroll ? rowsData.length + incomeOffset || rowsData.length + offset : incomeOffset || offset,
            count: defaultItemsPerPage
          }));
          loadAuditsSuccess({
            rowsData: [...rowsData, ...data],
            total
          });
          if (onlyOneLoad) {
            finishLoading();
          }
        } catch (e) {
          const errorMessage = {
            name: "audits",
            error: e
          };
          console.error("failed to load audits - ", e);
          loadItemFailedAction(errorMessage);
        }
      };
      const initData = async () => {
        startLoading();
        await Promise.all([__loadStats(), __loadMetadata(), loadAudits({
          onlyOneLoad: false
        })]);
        finishLoading();
      };
      const removeFilter = async (payload) => {
        const {
          filters: allFilters
        } = store.audits;
        const removedFilterIndex = allFilters.findIndex((item) => item.key === payload.key);
        if (removedFilterIndex < 0) {
          return;
        }
        const newFilters = [...allFilters.slice(0, removedFilterIndex), ...allFilters.slice(removedFilterIndex + 1)];
        setFilterData(newFilters);
      };
      const filterData = async (payload) => {
        const {
          filters: allFilters
        } = store.audits;
        let filterIndex = allFilters.findIndex((item) => item.key === payload.key);
        if (filterIndex < 0) {
          filterIndex = allFilters.length;
        }
        const newFilters = [...allFilters.slice(0, filterIndex), payload, ...allFilters.slice(filterIndex + 1)];
        setFilterData(newFilters);
      };
      const exportCSV = async () => {
        const {
          filters,
          sortBy,
          sortDirection,
          filter,
          headerProps = []
        } = store.audits;
        const f2o = __filterToObject(filters);
        startDownloadingCsv();
        const outputFileName = `audits.csv`;
        try {
          await api2.audits.exportAudits(_extends({
            endpoint: "csv/v2",
            headerProps,
            sortDirection,
            sortBy,
            filter
          }, f2o, {
            offset: 0,
            outputFileName
          }));
        } catch (e) {
          console.error("failed to export audits - ", e);
        } finally {
          stopDownloadingCsv();
        }
      };
      return {
        initData,
        loadAudits,
        removeFilter,
        filterData,
        exportCSV
        // deleteAudits, // not implemented
      };
    };
  }
});

// node_modules/@frontegg/redux-store/audits-backward-compatibility/index.js
var init_audits_backward_compatibility = __esm({
  "node_modules/@frontegg/redux-store/audits-backward-compatibility/index.js"() {
    init_state47();
    init_actions48();
  }
});

// node_modules/@frontegg/redux-store/mocks/helpers.js
var mockActionsExpect;
var init_helpers10 = __esm({
  "node_modules/@frontegg/redux-store/mocks/helpers.js"() {
    init_extends();
    mockActionsExpect = (actions, exclude) => {
      return Object.keys(actions).reduce((acc, key) => {
        const actionKey = key;
        if (exclude.includes(key)) {
          return _extends({}, acc, {
            [key]: actions[actionKey]
          });
        }
        return _extends({}, acc, {
          [key]: () => {
            console.debug(`Action ${String(key)} was called`);
          }
        });
      }, {});
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/acceptInvitationActions.mocks.js
var acceptInvitationActions_mocks_default;
var init_acceptInvitationActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/acceptInvitationActions.mocks.js"() {
    init_helpers10();
    init_AcceptInvitationState();
    acceptInvitationActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default(store, api2, actions);
      return mockActionsExpect(originalActions, ["setAcceptInvitationState", "resetAcceptInvitationState"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/accountSettingsActions.mocks.js
var accountSettingsActions_mocks_default;
var init_accountSettingsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/accountSettingsActions.mocks.js"() {
    init_extends();
    init_AccountSettingsState();
    init_helpers();
    init_helpers10();
    accountSettingsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default2(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setAccountSettingsState", "resetAccountSettingsState"]);
      mockedActions.saveAccountSettings = async (payload) => {
        var _payload$callback;
        mockedActions.setAccountSettingsState({
          loading: true
        });
        await delay();
        const accountSettingsState = store.auth.accountSettingsState;
        const {
          address,
          timezone,
          dateFormat,
          timeFormat,
          currency,
          logo
        } = accountSettingsState;
        const body = _extends({
          address,
          timezone,
          dateFormat,
          timeFormat,
          currency,
          logo
        }, payload);
        mockedActions.setAccountSettingsState(_extends({}, body, {
          loading: false
        }));
        (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, body);
      };
      mockedActions.loadAccountSettings = async (payload) => {
        mockedActions.setAccountSettingsState({
          loading: !(payload != null && payload.silentLoading),
          error: null
        });
        await delay();
        mockedActions.setAccountSettingsState(_extends({
          address: "Tel-aviv",
          timezone: "Asia/Jerusalem",
          dateFormat: "DD/MM/YYYY",
          timeFormat: "HH:mm",
          currency: "USD",
          loading: false
        }, payload));
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/activateAccountActions.mocks.js
var activateAccountActions_mocks_default;
var init_activateAccountActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/activateAccountActions.mocks.js"() {
    init_ActivateAccountState();
    init_helpers10();
    activateAccountActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default3(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setActivateState", "resetActivateState", "setActivateStrategyState"]);
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/allAccountsActions.mocks.js
var allAccountsActions_mocks_default;
var init_allAccountsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/allAccountsActions.mocks.js"() {
    init_helpers10();
    init_MSP();
    allAccountsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default15(store, api2, actions);
      return mockActionsExpect(originalActions, ["setAllAccountsLoader", "setAllAccountsError", "setAllAccountsState", "setSelectedAccountState", "resetAllAccountsState", "clearSelectedAccount"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/dummy.js
var apiTokensDataDemo, apiTokensDataTenantDemo, rolesAdminViewerDemo, roleDemo, rolePermissionDemo, userProfileDemo, userDemo, profileStateDemo, policyDemo, publicSecurityPolicy, policyMfaDemo, policyLockoutDemo, policyPasswordHistoryDemo, samlConfigurationDemo, samlMetadataDemo, rolesDemo, ssoStateDemo, permissionsDemo, userTeamDemo2, userTeamDemo2V3, userTeamDemo, userTeamDemoV3, userSubTenantDemo, usersDemo, usersDemoV3, allUsersDemo, tenantsDemo, sessionsMock, dummyIpConfig, dummyIps, generateGroupUsers, generateRoleByName, allGroupsDummy, securityCenterRecommendationsMock, securityCenterInsightsMock, securityCenterBreachedPasswordUsersMock, securityCenterInactivityPasswordUsersMock, securityCenterUnenrolledMfaUsersMock, permissionsMock;
var init_dummy = __esm({
  "node_modules/@frontegg/redux-store/mocks/dummy.js"() {
    init_extends();
    init_rest_api();
    apiTokensDataDemo = {
      clientId: "CLIENT_ID_16806d3d-8fc3-4450-be97-abdaf66b723e",
      secret: "SECRET_16806d3d-8fc3-4450-be97-abdaf66b723e",
      createdAt: "createdAt",
      description: "Demo API Token (preview only)"
    };
    apiTokensDataTenantDemo = _extends({}, apiTokensDataDemo, {
      roleIds: [],
      tenantId: "my-tenant-id",
      createdByUserId: "createdByUserId"
    });
    rolesAdminViewerDemo = [{
      id: "a040dcf6-b907-4e83-9970-6bd23c88fd40",
      key: "ReadOnly",
      name: "Read Only",
      description: null,
      isDefault: false,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      permissions: ["8d71b676-754c-4600-afe7-ca5add1e6809", "04dbcc11-61db-40a9-9577-9b73e50d1d03"],
      vendorId: "vendorId"
    }, {
      id: "b43b2c4b-e056-4eec-8c55-d200a475bbc0",
      key: "Admin",
      name: "Admin",
      description: null,
      isDefault: true,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      permissions: ["8d71b676-754c-4600-afe7-ca5add1e6809", "04dbcc11-61db-40a9-9577-9b73e50d1d03", "16647407-ed6f-4ca6-83a0-86225d921959", "f403c6b9-1abe-4ec7-9971-aa032255fc25", "a43e059d-d731-44b1-94bb-fb6b16c62210"],
      vendorId: "vendorId"
    }, {
      id: "1234",
      key: "Support",
      name: "Support",
      description: null,
      isDefault: true,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      permissions: ["8d71b676-754c-4600-afe7-ca5add1e6809", "04dbcc11-61db-40a9-9577-9b73e50d1d03", "f26b00f8-ffe0-4739-b15c-7db15c27ea26", "a9c803b0-ebfa-49b9-9607-f0d3a390ee61"],
      tenantId: "tenantId",
      vendorId: "vendorId"
    }];
    roleDemo = [{
      id: "roleId",
      key: "admin",
      isDefault: false,
      name: "Admin",
      description: null,
      permissions: ["8d71b676-754c-4600-afe7-ca5add1e6809", "04dbcc11-61db-40a9-9577-9b73e50d1d03"],
      tenantId: "tenantId",
      vendorId: "vendorId",
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }];
    rolePermissionDemo = [{
      id: "8d71b676-754c-4600-afe7-ca5add1e6809",
      key: "fe.*",
      name: "General Admin",
      description: "description",
      categoryId: "category",
      fePermission: true,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      roleIds: []
    }];
    userProfileDemo = {
      sub: "",
      tenants: [],
      id: "testId",
      name: "Demo User Name",
      email: "demo-user@frontegg.com",
      mfaEnrolled: true,
      profilePictureUrl: "https://www.gravatar.com/avatar/42b2ad2bad6fc9b9db5086dfcf8072ac?d=https://ui-avatars.com/api/fe/128/random?t=1617261890875?t=1617261917434",
      roles: roleDemo,
      permissions: rolePermissionDemo,
      tenantId: "my-tenant-id",
      tenantIds: ["my-tenant-id"],
      activatedForTenant: true,
      metadata: JSON.stringify({
        phoneNumber: "+972-54123456",
        jobTitle: "Developer",
        address: {
          city: "Tel Aviv",
          country: "Israel"
        }
      }),
      verified: false
    };
    userDemo = _extends({}, userProfileDemo, {
      accessToken: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1MTY5YmY0Zi02YmI5LTQ5NGMtOGNkZS05MDc4NDQ0NWY4MDciLCJuYW1lIjoiRHVtbXkgVXNlciIsImVtYWlsIjoiZHVtbXlAZnJvbnRlZ2cuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsIm1ldGFkYXRhIjp7fSwicm9sZXMiOlsiYWRtaW4iXSwicGVybWlzc2lvbnMiOlsiZmUuKiJdLCJ0ZW5hbnRJZCI6Im15LXRlbmFudC1pZCIsInRlbmFudElkcyI6WyJteS10ZW5hbnQtaWQiXSwicHJvZmlsZVBpY3R1cmVVcmwiOiJodHRwczovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyLzQyYjJhZDJiYWQ2ZmM5YjlkYjUwODZkZmNmODA3MmFjP2Q9aHR0cHM6Ly91aS1hdmF0YXJzLmNvbS9hcGkvZmUvMTI4L3JhbmRvbT90PTE2MTcyNjE4OTA4NzU_dD0xNjE3MjYxOTE3NDM0IiwidHlwZSI6InVzZXJUb2tlbiIsImlhdCI6MTYxNzkwNjMyNCwiZXhwIjoxNjE3OTkyNzI0LCJpc3MiOiJmcm9udGVnZyJ9.paaXLkpWEWbQmUtoK2P8IwXCxK4WJp7XhXonvzF8g1I",
      expiresIn: 86400,
      mfaRequired: false,
      refreshToken: "refresh-token-dummy-de39dc9c-9d22-4852-b7f5-c3c0aa613b58",
      type: "userToken",
      iat: 1617906324,
      exp: 1617992724,
      iss: "frontegg",
      email_verified: true
    });
    profileStateDemo = {
      loading: false,
      error: void 0,
      saving: true,
      profile: userProfileDemo
    };
    policyDemo = {
      id: "id",
      enforceMFAType: "DontForce",
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      allowOverrideEnforcePasswordHistory: true,
      allowOverridePasswordComplexity: false,
      allowOverridePasswordExpiration: false,
      allowSignups: true,
      apiTokensEnabled: true,
      cookieSameSite: "cookieSameSite",
      defaultRefreshTokenExpiration: 0,
      defaultTokenExpiration: 1,
      publicKey: "publicKey"
    };
    publicSecurityPolicy = {
      allowSignups: true,
      allowNotVerifiedUsersLogin: false,
      apiTokensEnabled: true,
      forcePermissions: false,
      authStrategy: AuthStrategyEnum.EmailAndPassword,
      machineToMachineAuthStrategy: MachineToMachineAuthStrategy.ClientCredentials
    };
    policyMfaDemo = {
      id: "id",
      enforceMFAType: "DontForce",
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    policyLockoutDemo = {
      id: "id",
      enabled: true,
      maxAttempts: 1,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    policyPasswordHistoryDemo = {
      id: "id",
      enabled: true,
      historySize: 1,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    samlConfigurationDemo = {
      enabled: true,
      domain: "domain",
      validated: true,
      generatedVerification: "generatedVerification",
      ssoEndpoint: "ssoEndpoint",
      publicCertificate: "publicCertificate",
      signRequest: true,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      acsUrl: void 0,
      spEntityId: void 0,
      oidcClientId: void 0,
      oidcSecret: void 0,
      type: void 0
    };
    samlMetadataDemo = {
      id: "id",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      properties: [],
      vendorId: "vendorId",
      entityName: "saml",
      isActive: true,
      configuration: {
        acsUrl: "acsUrl",
        spEntityId: "spEntityId"
      }
    };
    rolesDemo = [{
      id: "id",
      description: "description",
      key: "key",
      name: "name",
      permissions: [],
      permissionLevel: 1
    }];
    ssoStateDemo = {
      firstLoad: false,
      loading: false,
      error: void 0,
      saving: false,
      samlConfiguration: samlConfigurationDemo,
      roles: rolesDemo,
      authorizationRoles: [],
      errors: {},
      loaders: {},
      ssoConfigurations: []
    };
    permissionsDemo = [{
      description: "string",
      fePermission: true,
      id: "id",
      key: "key",
      name: "name",
      roleIds: [],
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "categoryId"
    }];
    userTeamDemo2 = {
      id: "id2",
      email: "demo-user2@frontegg.com",
      name: "Demo User Name2",
      phone: void 0,
      profileImage: void 0,
      profileImageUrl: void 0,
      tenantId: "tenantId",
      vendorId: "vendorId",
      roleIds: [],
      activatedForTenant: true,
      verified: false,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      customData: void 0,
      lastLogin: void 0,
      mfaEnabled: void 0,
      roles: [rolesAdminViewerDemo[0]],
      groups: [{
        id: "id2",
        name: "Developers",
        color: "#03A9F4",
        roles: [rolesAdminViewerDemo[0]],
        managedBy: GroupManagedByEnum.FRONTEGG
      }]
    };
    userTeamDemo2V3 = {
      id: userTeamDemo2.id,
      email: userTeamDemo2.email,
      name: userTeamDemo2.name,
      phoneNumber: void 0,
      profileImage: void 0,
      tenantId: "tenantId",
      activatedForTenant: true,
      createdAt: new Date(2022, 4, 1),
      verified: true,
      lastLogin: new Date(2022, 5, 25),
      mfaEnrolled: false,
      roles: [rolesAdminViewerDemo[1]],
      tenantIds: [],
      metadata: "",
      sub: "",
      tenants: []
    };
    userTeamDemo = {
      id: "id",
      email: "demo-user@frontegg.com",
      name: "Demo User Name",
      phone: void 0,
      profileImage: void 0,
      profileImageUrl: void 0,
      tenantId: "tenantId",
      vendorId: "vendorId",
      roleIds: [],
      activatedForTenant: true,
      createdAt: new Date(2022, 4, 1).toISOString(),
      verified: true,
      customData: void 0,
      lastLogin: new Date(2022, 5, 25).toISOString(),
      mfaEnabled: void 0,
      roles: [rolesAdminViewerDemo[1]],
      groups: [{
        id: "id1",
        name: "Designers",
        color: "#E1F5E2",
        roles: [rolesAdminViewerDemo[0]],
        managedBy: GroupManagedByEnum.FRONTEGG
      }]
    };
    userTeamDemoV3 = {
      id: userTeamDemo.id,
      email: userTeamDemo.email,
      name: userTeamDemo.name,
      phoneNumber: void 0,
      profileImage: void 0,
      tenantId: "tenantId",
      activatedForTenant: true,
      createdAt: new Date(2022, 4, 1),
      verified: true,
      lastLogin: new Date(2022, 5, 25),
      mfaEnrolled: false,
      roles: [rolesAdminViewerDemo[1]],
      tenantIds: [],
      metadata: "",
      sub: "",
      tenants: []
    };
    userSubTenantDemo = {
      metadata: "",
      mfaEnrolled: false,
      provider: "",
      sub: "",
      tenantIds: [],
      tenants: [],
      verified: false,
      id: "id",
      email: "email",
      name: "name",
      tenantId: "tenantId",
      createdAt: /* @__PURE__ */ new Date()
    };
    usersDemo = [userTeamDemo, userTeamDemo2];
    usersDemoV3 = [userTeamDemoV3, userTeamDemo2V3];
    allUsersDemo = [userSubTenantDemo];
    tenantsDemo = [{
      id: "my-tenant-id",
      isReseller: false,
      name: "Frontegg demo",
      deletedAt: null,
      metadata: void 0,
      tenantId: "my-tenant-id",
      vendorId: "vendorId",
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      address: void 0,
      timezone: void 0,
      dateFormat: void 0,
      timeFormat: void 0,
      currency: void 0,
      logo: void 0
    }];
    sessionsMock = [{
      id: `laptop`,
      userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
      createdAt: /* @__PURE__ */ new Date(),
      ipAddress: "190.194.88.251",
      current: true
    }, {
      id: `iphone`,
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_2_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.2 Mobile/15E148 Safari/604.1",
      createdAt: new Date(Date.now() - 1e4),
      ipAddress: "191.49.203.21"
    }, {
      id: `tablet`,
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; SGP771 Build/32.2.A.0.253; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/52.0.2743.98 Safari/537.36",
      createdAt: new Date(Date.now() - 3e4),
      ipAddress: "130.19.196.136"
    }, {
      id: `anotherlaptop`,
      userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
      createdAt: new Date(Date.now() - 1002232300),
      ipAddress: "2.228.163.92"
    }];
    dummyIpConfig = {
      isActive: true,
      strategy: RestrictionType.ALLOW
    };
    dummyIps = [{
      updatedAt: /* @__PURE__ */ new Date(),
      createdAt: /* @__PURE__ */ new Date(),
      id: "1",
      ip: "255.255.255.255",
      isActive: true,
      strategy: RestrictionType.ALLOW,
      description: "My IP"
    }, {
      updatedAt: /* @__PURE__ */ new Date(),
      createdAt: /* @__PURE__ */ new Date(),
      id: "2",
      ip: "255.255.255.254",
      isActive: true,
      strategy: RestrictionType.ALLOW,
      description: "IP 2"
    }, {
      updatedAt: /* @__PURE__ */ new Date(),
      createdAt: /* @__PURE__ */ new Date(),
      id: "3",
      ip: "255.255.255.253",
      isActive: true,
      strategy: RestrictionType.BLOCK,
      description: "IP 3"
    }, {
      updatedAt: /* @__PURE__ */ new Date(),
      createdAt: /* @__PURE__ */ new Date(),
      id: "4",
      ip: "255.255.255.253",
      isActive: true,
      strategy: RestrictionType.BLOCK,
      description: "IP 4"
    }];
    generateGroupUsers = (count) => {
      const users = [];
      Array.from({
        length: count
      }).forEach((_, i) => {
        users.push(_extends({}, userTeamDemo, {
          name: "Demo User",
          id: `id${i}`,
          profilePictureUrl: null,
          createdAt: /* @__PURE__ */ new Date()
        }));
      });
      return users;
    };
    generateRoleByName = (roleName) => {
      return {
        id: "b43b2c4b-e056-4eec-8c55-d200a475bbc0" + roleName,
        key: roleName,
        name: roleName,
        description: null,
        isDefault: true,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        permissions: [],
        tenantId: "tenantId",
        vendorId: "vendorId"
      };
    };
    allGroupsDummy = [{
      id: "id1",
      name: "Designers",
      color: "#E1F5E2",
      description: "The whole design team",
      users: generateGroupUsers(6),
      roles: [generateRoleByName("Editor")],
      metadata: '{"lastTermsCheck":"2022-08-16T10:31:11.270Z"}',
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id2",
      name: "Developers",
      color: "#03A9F4",
      description: "All frontend and backend developers",
      users: generateGroupUsers(44),
      roles: [generateRoleByName("Editor")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id3",
      name: "Product",
      color: "#E1583E",
      description: "PMs and team leads",
      users: generateGroupUsers(8),
      roles: [generateRoleByName("Viewer")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id4",
      name: "Management",
      color: "#9AE0FF",
      description: "Executives",
      users: generateGroupUsers(5),
      roles: [generateRoleByName("Admin")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id5",
      name: "Sales",
      color: "#ED8E7C",
      users: generateGroupUsers(21),
      description: "BDR, AE, and inside sales",
      roles: [generateRoleByName("Viewer")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id6",
      name: "Support",
      color: "#A79D7B",
      users: generateGroupUsers(23),
      description: "Dev success and customer success",
      roles: [generateRoleByName("Admin")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id7",
      name: "Marketing",
      color: "#2CA744",
      users: generateGroupUsers(10),
      description: "The marketing department",
      roles: [generateRoleByName("Viewer")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id8",
      name: "HR",
      color: "#EAE1C2",
      users: generateGroupUsers(4),
      description: "Human resources",
      roles: [generateRoleByName("Viewer")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id9",
      name: "Finance",
      color: "#5587C0",
      users: generateGroupUsers(3),
      roles: [generateRoleByName("Viewer")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id10",
      name: "Operations",
      color: "#B1CAE7",
      users: generateGroupUsers(8),
      roles: [generateRoleByName("Editor")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }, {
      id: "id11",
      name: "Legal",
      color: "#2CA744",
      users: generateGroupUsers(4),
      roles: [generateRoleByName("Viewer")],
      managedBy: GroupManagedByEnum.FRONTEGG
    }];
    securityCenterRecommendationsMock = {
      scoring: {
        score: 79
      },
      recommendations: {
        items: [{
          code: RecommendationCode.FORCE_MFA,
          severity: RecommendationSeverity.WARNING,
          category: SecurityCategory.MFA
        }, {
          code: RecommendationCode.ENABLE_FORCE_RELOGIN,
          severity: RecommendationSeverity.WARNING,
          category: SecurityCategory.SESSIONS
        }]
      }
    };
    securityCenterInsightsMock = {
      insights: {
        items: [{
          category: SecurityCategory.MFA,
          code: InsightCode.PARTIALLY_FORCED_MFA,
          metadata: {
            totalUsers: 2,
            mfa: {
              enrolledUsersCount: 1
            }
          }
        }, {
          category: SecurityCategory.SESSIONS,
          code: InsightCode.PARTIAL_SESSION_SETTINGS,
          metadata: {
            totalUsers: 2,
            sessions: {
              idleTimeoutRecommendation: 1800
            }
          }
        }, {
          category: SecurityCategory.PASSWORD,
          code: InsightCode.IMPROVE_PASSWORD_HISTORY_POLICY,
          metadata: {
            password: {
              userLockoutRecommendation: 5,
              historyRecommendations: 5
            }
          }
        }, {
          category: SecurityCategory.DOMAIN,
          code: InsightCode.NO_IP_RESTRICTIONS,
          metadata: {
            restrictions: {
              ipsCount: 1,
              domainsCount: 1
            }
          }
        }]
      }
    };
    securityCenterBreachedPasswordUsersMock = {
      users: usersDemoV3,
      totalUsersItems: 2,
      totalUsersPages: 1,
      usersPageOffset: 0
    };
    securityCenterInactivityPasswordUsersMock = {
      users: [usersDemoV3[0]],
      totalUsersItems: 1,
      totalUsersPages: 1,
      usersPageOffset: 0,
      queryParams: {
        _maxInactiveSeconds: 7776e3
      }
    };
    securityCenterUnenrolledMfaUsersMock = {
      users: [usersDemoV3[1]],
      totalUsersItems: 1,
      totalUsersPages: 1,
      usersPageOffset: 0
    };
    permissionsMock = [{
      id: "8d71b676-754c-4600-afe7-ca5add1e6809",
      key: "fe.secure.*",
      name: "Secure write",
      description: "all secure access permissions",
      categoryId: "77154759-0a04-4669-b6b4-0858d3c1190e",
      fePermission: true,
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }, {
      id: "85e1fd7b-2bb7-498f-8521-5f8e5774c01e",
      key: "fe.account-hierarchy.write.subAccountAccess",
      name: "Give access to sub accounts",
      description: "Give a user access to sub account",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "d24db1e3-002b-421d-951d-09a967dd7cd5",
      fePermission: true
    }, {
      id: "a1807695-54a2-4f95-95de-a9b246488aae",
      key: "fe.account-hierarchy.read.subAccount",
      name: "Read sub accounts",
      description: "Read sub accounts",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "d24db1e3-002b-421d-951d-09a967dd7cd5",
      fePermission: true
    }, {
      id: "04dbcc11-61db-40a9-9577-9b73e50d1d03",
      key: "fe.secure.read.*",
      name: "Secure read",
      description: "all secure access read permissions",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "77154759-0a04-4669-b6b4-0858d3c1190e",
      fePermission: true
    }, {
      id: "a1807695-54a2-4f95-95de-a9b246488aae",
      key: "fe.account-hierarchy.read.subAccount",
      name: "Read sub accounts",
      description: "Read sub accounts",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "d24db1e3-002b-421d-951d-09a967dd7cd5",
      fePermission: true
    }, {
      id: "85e1fd7b-2bb7-498f-8521-5f8e5774c01e",
      key: "fe.account-hierarchy.write.subAccountAccess",
      name: "Give access to sub accounts",
      description: "Give a user access to sub account",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "d24db1e3-002b-421d-951d-09a967dd7cd5",
      fePermission: true
    }, {
      id: "a9c803b0-ebfa-49b9-9607-f0d3a390ee61",
      key: "fe.account-settings.delete.account",
      name: "Delete Account",
      description: "Delete my account",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "42aaebe1-893d-4da5-99d7-375a4537b7a4",
      fePermission: true
    }, {
      id: "f26b00f8-ffe0-4739-b15c-7db15c27ea26",
      key: "fe.account-settings.write.custom-login-box",
      name: "Edit custom login settings",
      description: "Write account's custom login box styling",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "42aaebe1-893d-4da5-99d7-375a4537b7a4",
      fePermission: true
    }, {
      id: "a43e059d-d731-44b1-94bb-fb6b16c62210",
      key: "fe.connectivity.delete.*",
      name: "Connectivity delete",
      description: "all connectivity delete permissions",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "d18fccaa-e09a-4e6e-b902-cc9c615ff12d",
      fePermission: true
    }, {
      id: "f403c6b9-1abe-4ec7-9971-aa032255fc25",
      key: "fe.connectivity.delete.slackAppRegistration",
      name: "Delete slack application registration",
      description: "allow user to delete slack app registration",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "62fc3fe0-f06b-4a0f-854c-cdf51353b616",
      fePermission: true
    }, {
      id: "e8c0e727-f562-449a-82c5-f7691defde02",
      key: "fe.connectivity.read.*",
      name: "Connectivity read",
      description: "all connectivity read permissions",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "d18fccaa-e09a-4e6e-b902-cc9c615ff12d",
      fePermission: true
    }, {
      id: "2a5dcd6d-57a3-45c4-815f-c265609cc1f7",
      key: "fe.connectivity.read.emailConfig",
      name: "Read email configuration",
      description: "read email integration configuration",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "2d7b4be7-8269-4ff4-81d6-0c92e95790d5",
      fePermission: true
    }, {
      id: "4fee0eb0-5b17-450b-bea4-b9b908230bda",
      key: "fe.connectivity.read.eventCategories",
      name: "Read events categories",
      description: "view connectivity events categories",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "31c7a260-55d6-43d5-a872-4f9e22982ff5",
      fePermission: true
    }, {
      id: "750a96a5-8abf-4340-b91a-723c7bb8bcfd",
      key: "fe.connectivity.read.events",
      name: "Read events",
      description: "view connectivity events",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "31c7a260-55d6-43d5-a872-4f9e22982ff5",
      fePermission: true
    }, {
      id: "ef2a5f1a-74c5-431f-b1a6-d4fb5026e374",
      key: "fe.connectivity.read.slackApp",
      name: "Read slack application",
      description: "get slack application configuration in order to register",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "62fc3fe0-f06b-4a0f-854c-cdf51353b616",
      fePermission: true
    }, {
      id: "9fc1fa37-a8b9-4931-b2b5-5de55df25289",
      key: "fe.connectivity.read.slackChannels",
      name: "Read slack channels",
      description: "view registered slack workspace channels",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "62fc3fe0-f06b-4a0f-854c-cdf51353b616",
      fePermission: true
    }, {
      id: "87c3df9d-0ab2-4e97-bfc8-777a68ba2543",
      key: "fe.connectivity.read.slackSubscriptions",
      name: "Read slack subscriptions",
      description: "view slack events subscriptions",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "62fc3fe0-f06b-4a0f-854c-cdf51353b616",
      fePermission: true
    }, {
      id: "7826470b-151f-4bab-b2c0-785e09878616",
      key: "fe.connectivity.read.slackUsers",
      name: "Read slack users",
      description: "view registered slack workspace users",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "62fc3fe0-f06b-4a0f-854c-cdf51353b616",
      fePermission: true
    }, {
      id: "ee779734-a7e3-47b3-ace9-944f9bee8ad8",
      key: "fe.connectivity.read.smsConfig",
      name: "Read SMS configuration",
      description: "read SMS integration configuration",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "5743fccc-b4ea-4907-bdca-7446ea088974",
      fePermission: true
    }, {
      id: "54583a96-c731-4a84-9abc-1b8b827f06ae",
      key: "fe.connectivity.read.userBellNotifications",
      name: "Read bell notifications",
      description: "view user bell notifications",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "18d2584b-7f03-4038-ab93-bc2b0f4511be",
      fePermission: true
    }, {
      id: "2dfde8ef-7df2-4426-bb8d-33615e399a4d",
      key: "fe.connectivity.read.webhookLogs",
      name: "Read webhooks logs",
      description: "view webhooks logs",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "e74e5390-396b-429c-9544-62417912d018",
      fePermission: true
    }, {
      id: "16647407-ed6f-4ca6-83a0-86225d921959",
      key: "fe.connectivity.read.webhooks",
      name: "Read webhooks",
      description: "view webhooks configuration",
      assignmentType: PermissionAssignmentTypeEnum.ASSIGNABLE,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      categoryId: "e74e5390-396b-429c-9544-62417912d018",
      fePermission: true
    }];
  }
});

// node_modules/uuid/dist/esm-browser/max.js
var init_max = __esm({
  "node_modules/uuid/dist/esm-browser/max.js"() {
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var byteToHex, i;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
  }
});

// node_modules/uuid/dist/esm-browser/v1ToV6.js
var init_v1ToV6 = __esm({
  "node_modules/uuid/dist/esm-browser/v1ToV6.js"() {
    init_parse();
    init_stringify();
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35("v3", 48, md5_default);
  }
});

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID, native_default;
var init_native = __esm({
  "node_modules/uuid/dist/esm-browser/native.js"() {
    randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    native_default = {
      randomUUID
    };
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K2[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35("v5", 80, sha1_default);
  }
});

// node_modules/uuid/dist/esm-browser/v6.js
var init_v6 = __esm({
  "node_modules/uuid/dist/esm-browser/v6.js"() {
    init_stringify();
    init_v1();
    init_v1ToV6();
  }
});

// node_modules/uuid/dist/esm-browser/v6ToV1.js
var init_v6ToV1 = __esm({
  "node_modules/uuid/dist/esm-browser/v6ToV1.js"() {
    init_parse();
    init_stringify();
  }
});

// node_modules/uuid/dist/esm-browser/v7.js
var init_v7 = __esm({
  "node_modules/uuid/dist/esm-browser/v7.js"() {
    init_rng();
    init_stringify();
  }
});

// node_modules/uuid/dist/esm-browser/version.js
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_max();
    init_nil();
    init_parse();
    init_stringify();
    init_v1();
    init_v1ToV6();
    init_v3();
    init_v4();
    init_v5();
    init_v6();
    init_v6ToV1();
    init_v7();
    init_validate();
    init_version();
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/apiTokensActions.mocks.js
var apiTokensActions_mocks_default;
var init_apiTokensActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/apiTokensActions.mocks.js"() {
    init_extends();
    init_ApiTokensState();
    init_dummy();
    init_esm_browser();
    init_helpers();
    init_auth2();
    init_helpers10();
    apiTokensActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default5(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setApiTokensState", "resetApiTokensState", "setApiTokensLoader", "setApiTokensError"]);
      mockedActions.addTenantApiToken = async (payload) => {
        const {
          description,
          roleIds,
          callback
        } = payload;
        mockedActions.setApiTokensLoader({
          key: ApiStateKeys.ADD_API_TOKEN,
          value: true
        });
        const {
          apiTokensDataTenant
        } = store.auth.apiTokensState;
        const newToken = _extends({}, apiTokensDataTenantDemo, {
          description,
          roleIds,
          clientId: `CLIENT_ID_${v4_default()}`
        });
        mockedActions.setApiTokensState({
          showAddTokenDialog: false
        });
        await delay(200);
        mockedActions.setApiTokensState({
          apiTokensDataTenant: [...apiTokensDataTenant, newToken],
          successDialog: {
            open: true,
            secret: newToken.secret,
            clientId: newToken.clientId
          }
        });
        await delay(200);
        mockedActions.setApiTokensLoader({
          key: ApiStateKeys.ADD_API_TOKEN,
          value: false
        });
        callback == null ? void 0 : callback(null);
      };
      mockedActions.deleteTenantApiToken = async (payload) => {
        mockedActions.setApiTokensLoader({
          key: ApiStateKeys.DELETE_API_TOKEN,
          value: true
        });
        await delay(200);
        const apiTokensDataTenant = [apiTokensDataTenantDemo];
        mockedActions.setApiTokensState({
          apiTokensDataTenant: apiTokensDataTenant.filter((i) => i.clientId !== payload),
          deleteTokenDialog: {
            open: false,
            clientId: payload
          }
        });
        mockedActions.setApiTokensLoader({
          key: ApiStateKeys.DELETE_API_TOKEN,
          value: false
        });
      };
      mockedActions.loadApiTokens = async (payload) => {
        var _payload$callback;
        if (!(payload != null && payload.silentLoading)) {
          mockedActions.setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: true
          });
        }
        const apiTokensDataUser = [apiTokensDataDemo];
        const apiTokensDataTenant = [apiTokensDataTenantDemo];
        mockedActions.setApiTokensState({
          apiTokensDataUser,
          apiTokensDataTenant
        });
        await delay(200);
        mockedActions.setApiTokensLoader({
          key: ApiStateKeys.LOAD_API_TOKENS,
          value: false
        });
        payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
      };
      mockedActions.loadUserApiTokens = async (payload) => {
        var _payload$callback2;
        if (!(payload != null && payload.silentLoading)) {
          mockedActions.setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: true
          });
        }
        const apiTokensDataUser = [apiTokensDataDemo];
        mockedActions.setApiTokensState({
          apiTokensDataUser
        });
        await delay(200);
        mockedActions.setApiTokensLoader({
          key: ApiStateKeys.LOAD_API_TOKENS,
          value: false
        });
        payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, true);
      };
      mockedActions.loadTenantApiTokens = async (payload) => {
        var _payload$callback3;
        if (!(payload != null && payload.silentLoading)) {
          mockedActions.setApiTokensLoader({
            key: ApiStateKeys.LOAD_API_TOKENS,
            value: true
          });
        }
        const apiTokensDataTenant = [apiTokensDataTenantDemo];
        mockedActions.setApiTokensState({
          apiTokensDataTenant
        });
        await delay(200);
        mockedActions.setApiTokensLoader({
          key: ApiStateKeys.LOAD_API_TOKENS,
          value: false
        });
        payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/applicationsActions.mocks.js
var applicationsActions_mocks_default;
var init_applicationsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/applicationsActions.mocks.js"() {
    init_helpers10();
    init_ApplicationsState();
    applicationsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default6(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setApplicationsState", "resetApplicationsState"]);
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/customLoginActions.mocks.js
var customLoginActions_mocks_default;
var init_customLoginActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/customLoginActions.mocks.js"() {
    init_CustomLoginState();
    init_helpers();
    init_helpers10();
    customLoginActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default7(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setCustomLoginState", "resetCustomLoginState"]);
      mockedActions.loadTenantMetadata = async () => {
        mockedActions.setCustomLoginState({
          loading: true
        });
        await delay();
        mockedActions.setCustomLoginState({
          loading: false
        });
      };
      mockedActions.updateTenantMetadata = async (payload) => {
        const {
          callback
        } = payload;
        mockedActions.setCustomLoginState({
          loading: true,
          error: null
        });
        await delay();
        mockedActions.setCustomLoginState({
          loading: false,
          error: null
        });
        callback == null ? void 0 : callback(true);
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/entitlementsActions.mocks.js
var entitlementsActions_mocks_default;
var init_entitlementsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/entitlementsActions.mocks.js"() {
    init_helpers10();
    init_Entitlements();
    entitlementsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default34(store, api2, actions);
      return mockActionsExpect(originalActions, ["setEntitlements", "handleFetchedEntitlements"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/forgotPasswordActions.mocks.js
var forgotPasswordActions_mocks_default;
var init_forgotPasswordActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/forgotPasswordActions.mocks.js"() {
    init_helpers();
    init_ForgotPasswordState();
    init_helpers10();
    forgotPasswordActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default8(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setForgotPasswordState", "resetForgotPasswordState"]);
      mockedActions.loadPasswordConfig = async (payload) => {
        mockedActions.setForgotPasswordState({
          loading: true
        });
        try {
          mockedActions.setForgotPasswordState({
            loading: false,
            passwordConfig: {
              allowPassphrases: true,
              maxLength: 128,
              minLength: 6,
              minPhraseLength: 6,
              minOptionalTestsToPass: 1
            }
          });
        } catch (e) {
          mockedActions.setForgotPasswordState({
            loading: false,
            error: errorHandler(e)
          });
        }
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/passwordRotationActions.mocks.js
var passwordRotationActions_mocks_default;
var init_passwordRotationActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/passwordRotationActions.mocks.js"() {
    init_PasswordRotationState();
    init_toolkit();
    init_helpers10();
    passwordRotationActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default9(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setStep"]);
      mockedActions.setStep(PasswordRotationStep.success);
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/groupsActions.mocks.js
var groupsActions_mocks_default;
var init_groupsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/groupsActions.mocks.js"() {
    init_extends();
    init_auth2();
    init_helpers();
    init_GroupsState();
    init_dummy();
    init_rest_api();
    init_helpers10();
    groupsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default10(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setGroupsState", "resetUsersGroupsState", "setUsersGroupsLoader", "setUsersGroupsError"]);
      mockedActions.loadGroups = async () => {
        const key = GroupsStateKeys.GET_GROUPS;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        const groups = allGroupsDummy;
        mockedActions.setGroupsState({
          groups
        });
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.createGroup = async (payload) => {
        var _payload$callback;
        const key = GroupsStateKeys.CREATE_GROUP;
        const {
          groups
        } = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        await delay(500);
        mockedActions.setGroupsState({
          groups: [_extends({}, payload, {
            id: `${payload.name}ID`,
            managedBy: GroupManagedByEnum.FRONTEGG
          }), ...groups != null ? groups : []]
        });
        payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.updateGroup = async (payload) => {
        var _state$groups, _payload$name2, _payload$color, _payload$description, _payload$callback2;
        const key = GroupsStateKeys.UPDATE_GROUP;
        const state = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        await delay(500);
        mockedActions.setGroupsState({
          groups: state == null ? void 0 : (_state$groups = state.groups) == null ? void 0 : _state$groups.map((group) => {
            var _payload$name;
            return group.id === payload.groupId ? _extends({}, payload, {
              id: payload.groupId,
              name: (_payload$name = payload == null ? void 0 : payload.name) != null ? _payload$name : "",
              managedBy: GroupManagedByEnum.FRONTEGG
            }) : group;
          }),
          selectedGroup: _extends({}, state == null ? void 0 : state.selectedGroup, {
            name: (_payload$name2 = payload == null ? void 0 : payload.name) != null ? _payload$name2 : "",
            color: (_payload$color = payload == null ? void 0 : payload.color) != null ? _payload$color : "",
            description: (_payload$description = payload == null ? void 0 : payload.description) != null ? _payload$description : ""
          })
        });
        payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, true);
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.deleteGroup = async (payload) => {
        var _state$groups2, _payload$callback3;
        const key = GroupsStateKeys.DELETE_GROUP;
        const state = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        await delay(500);
        mockedActions.setGroupsState({
          groups: state == null ? void 0 : (_state$groups2 = state.groups) == null ? void 0 : _state$groups2.filter((group) => group.id !== payload.groupId)
        });
        payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.addRolesToGroup = async (payload) => {
        var _state$groups3, _payload$callback4;
        const key = GroupsStateKeys.ADD_ROLES_TO_GROUP;
        const state = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        await delay(500);
        mockedActions.setGroupsState({
          groups: state == null ? void 0 : (_state$groups3 = state.groups) == null ? void 0 : _state$groups3.map((group) => {
            var _group$roles;
            return group.id === payload.groupId ? _extends({}, group, {
              roles: [...(_group$roles = group == null ? void 0 : group.roles) != null ? _group$roles : [], ...payload.roleIds.map((role) => ({
                id: role,
                name: role
              }))]
            }) : group;
          })
        });
        payload == null ? void 0 : (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, true);
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.deleteRolesFromGroup = async (payload) => {
        var _state$groups4, _payload$callback5;
        const key = GroupsStateKeys.DELETE_ROLES_FROM_GROUP;
        const state = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        await delay(500);
        mockedActions.setGroupsState({
          groups: state == null ? void 0 : (_state$groups4 = state.groups) == null ? void 0 : _state$groups4.map((group) => {
            var _group$roles2;
            return group.id === payload.groupId ? _extends({}, group, {
              roles: group == null ? void 0 : (_group$roles2 = group.roles) == null ? void 0 : _group$roles2.filter((role) => !payload.roleIds.includes(role.id))
            }) : group;
          })
        });
        payload == null ? void 0 : (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, true);
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.addUsersToGroup = async (payload) => {
        var _state$groups5, _payload$callback6;
        const key = GroupsStateKeys.ADD_USERS_TO_GROUP;
        const state = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        await delay(500);
        mockedActions.setGroupsState({
          groups: state == null ? void 0 : (_state$groups5 = state.groups) == null ? void 0 : _state$groups5.map((group) => {
            var _group$users;
            return group.id === payload.groupId ? _extends({}, group, {
              users: [...(_group$users = group == null ? void 0 : group.users) != null ? _group$users : [], ...payload.userIds.map((user) => ({
                id: user,
                name: user
              }))]
            }) : group;
          })
        });
        payload == null ? void 0 : (_payload$callback6 = payload.callback) == null ? void 0 : _payload$callback6.call(payload, true);
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.deleteUsersFromGroup = async (payload) => {
        var _state$groups6, _payload$callback7;
        const key = GroupsStateKeys.DELETE_USERS_FROM_GROUP;
        const state = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        await delay(500);
        mockedActions.setGroupsState({
          groups: state == null ? void 0 : (_state$groups6 = state.groups) == null ? void 0 : _state$groups6.map((group) => {
            var _group$users2;
            return group.id === payload.groupId ? _extends({}, group, {
              users: group == null ? void 0 : (_group$users2 = group.users) == null ? void 0 : _group$users2.filter((user) => !payload.userIds.includes(user.id))
            }) : group;
          })
        });
        payload == null ? void 0 : (_payload$callback7 = payload.callback) == null ? void 0 : _payload$callback7.call(payload, true);
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.getGroupConfiguration = async () => {
        const key = GroupsStateKeys.GET_GROUP_CONFIGURATION;
        const {
          groupsConfiguration
        } = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        if (groupsConfiguration) {
          mockedActions.setGroupsState({
            groupsConfiguration: _extends({}, groupsConfiguration)
          });
        }
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      mockedActions.updateGroupConfiguration = async (payload) => {
        const key = GroupsStateKeys.UPDATE_GROUP_CONFIGURATION;
        const {
          groupsConfiguration
        } = store.auth.groupsState;
        mockedActions.setUsersGroupsLoader({
          key,
          value: true
        });
        if (groupsConfiguration) {
          mockedActions.setGroupsState({
            groupsConfiguration: _extends({}, groupsConfiguration, payload)
          });
        }
        mockedActions.setUsersGroupsLoader({
          key,
          value: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/impersonateActions.mocks.js
var impersonateActions_mocks_default;
var init_impersonateActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/impersonateActions.mocks.js"() {
    init_helpers10();
    init_ImpersonateState();
    impersonateActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default12(store, api2, actions);
      return mockActionsExpect(originalActions, ["setImpersonateState", "resetImpersonateState"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/loginActions.mocks.js
var loginActions_mocks_default;
var init_loginActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/loginActions.mocks.js"() {
    init_LoginState();
    init_dummy();
    init_helpers10();
    loginActions_mocks_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const originalActions = actions_default13(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setLoginState", "resetLoginState", "afterAuthNavigation"]);
      mockedActions.requestAuthorize = async (firstTime) => {
        if (firstTime) {
          actions.setAuthState({
            isLoading: true
          });
        }
        const user = userDemo;
        await actions.loadTenants();
        actions.setAuthState({
          user,
          isAuthenticated: true,
          isLoading: false
        });
      };
      mockedActions.getUserIP = async (payload) => {
        const {
          callback
        } = payload;
        try {
          const {
            ip
          } = dummyIps[0];
          await actions.setAuthState({
            userIpData: {
              ip
            },
            userIp: ip
          });
          callback == null ? void 0 : callback(true, ip);
        } catch (e) {
          callback == null ? void 0 : callback(false, e);
        }
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/mfaActions.mocks.js
var _excluded75, _excluded227, mfaActions_mocks_default;
var init_mfaActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/mfaActions.mocks.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_auth2();
    init_helpers();
    init_MfaState();
    init_dummy();
    init_helpers10();
    _excluded75 = ["callback"];
    _excluded227 = ["callback"];
    mfaActions_mocks_default = (store, api2, sharedActions) => {
      const actions = sharedActions;
      const originalActions = actions_default14(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setMfaState", "resetMfaState"]);
      mockedActions.enrollMfa = async () => {
        mockedActions.setMfaState({
          saving: true
        });
        const qrCode = "test";
        mockedActions.setMfaState({
          saving: false,
          error: void 0,
          qrCode
        });
      };
      mockedActions.verifyMfa = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded75);
        const {
          mfaDevices = {
            webauthn: [],
            phones: [],
            authenticators: [],
            emails: []
          }
        } = store.auth.mfaState;
        mockedActions.setMfaState({
          saving: true
        });
        await delay();
        const data = {
          token: "token",
          recoveryCode: "recoveryCode"
        };
        const mfaState = {
          step: MFAStep.recoveryCode,
          loading: false,
          error: void 0,
          saving: false,
          mfaDevices: _extends({}, mfaDevices, {
            authenticators: [{
              id: "authenticator-id"
            }]
          })
        };
        if (data != null && data.recoveryCode) {
          mfaState.recoveryCode = data.recoveryCode;
        }
        mockedActions.setMfaState(mfaState);
        actions.setUser(_extends({}, userDemo, {
          mfaEnrolled: true
        }));
        callback == null ? void 0 : callback(mfaState.recoveryCode);
      };
      mockedActions.disableMfa = async (payload) => {
        var _payload$callback;
        const {
          mfaDevices = {
            webauthn: [],
            phones: [],
            authenticators: [],
            emails: []
          }
        } = store.auth.mfaState;
        mockedActions.setMfaState({
          saving: true
        });
        await delay();
        mockedActions.setMfaState({
          saving: false,
          error: void 0,
          mfaDevices: _extends({}, mfaDevices, {
            authenticators: []
          })
        });
        actions.setUser(_extends({}, userDemo));
        (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
      };
      mockedActions.verifyMfaAfterForce = async (_payload) => {
        const {
          callback
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded227);
        mockedActions.setMfaState({
          loading: true
        });
        await delay();
        const data = _extends({}, payload, {
          recoveryCode: "recoveryCode"
        });
        const mfaState = {
          step: MFAStep.recoveryCode,
          loading: false,
          error: void 0,
          saving: false
        };
        if (data != null && data.recoveryCode) {
          mfaState.recoveryCode = data.recoveryCode;
        }
        mockedActions.setMfaState(mfaState);
        await delay();
        actions.setUser(_extends({}, userDemo, {
          mfaEnrolled: true
        }));
        callback == null ? void 0 : callback(mfaState.recoveryCode);
      };
      mockedActions.preDisableMfaSms = async (payload) => {
        mockedActions.setMfaState({
          saving: true
        });
        try {
          var _payload$callback2;
          mockedActions.setMfaState({
            saving: false,
            error: void 0,
            otcToken: "otc-token",
            phoneNumber: "+972504589346"
          });
          (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, true);
        } catch (e) {
          var _payload$callback3;
          mockedActions.setMfaState({
            saving: false,
            error: errorHandler(e)
          });
          (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, false, e);
        }
      };
      mockedActions.disableMfaSms = async (payload) => {
        var _payload$callback4;
        const {
          mfaDevices = {
            webauthn: [],
            phones: [],
            authenticators: [],
            emails: []
          }
        } = store.auth.mfaState;
        mockedActions.setMfaState({
          saving: true
        });
        await delay();
        mockedActions.setMfaState({
          loading: false,
          error: void 0,
          mfaDevices: _extends({}, mfaDevices, {
            phones: []
          })
        });
        actions.setUser(_extends({}, userDemo));
        (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, true);
      };
      mockedActions.preEnrollMfaSms = async (payload) => {
        var _payload$callback5;
        mockedActions.setMfaState({
          saving: true
        });
        await delay();
        mockedActions.setMfaState({
          saving: false,
          error: void 0,
          otcToken: "otc-token",
          phoneNumber: "+972504589346"
        });
        (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, true);
      };
      mockedActions.enrollMfaSms = async (_payload) => {
        const {
          callback
        } = _payload;
        const {
          mfaDevices = {
            webauthn: [],
            phones: [],
            authenticators: [],
            emails: []
          }
        } = store.auth.mfaState;
        mockedActions.setMfaState({
          saving: true
        });
        await delay();
        const data = {
          token: "token",
          recoveryCode: "recoveryCode"
        };
        const mfaState = {
          step: MFAStep.recoveryCode,
          loading: false,
          error: void 0,
          saving: false,
          mfaDevices: _extends({}, mfaDevices, {
            phones: [{
              id: "phone-id",
              phoneNumber: "+972504589346"
            }]
          })
        };
        if (data != null && data.recoveryCode) {
          mfaState.recoveryCode = data.recoveryCode;
        }
        mockedActions.setMfaState(mfaState);
        actions.setUser(_extends({}, userDemo, {
          mfaEnrolled: true
        }));
        callback == null ? void 0 : callback(mfaState.recoveryCode);
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/passkeysActions.mocks.js
var passkeysActions_mocks_default;
var init_passkeysActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/passkeysActions.mocks.js"() {
    init_helpers10();
    init_PasskeysState();
    passkeysActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default17(store, api2, actions);
      return mockActionsExpect(originalActions, ["setPasskeysState", "resetPasskeysState"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/profileActions.mocks.js
var _excluded76, profileActions_mocks_default;
var init_profileActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/profileActions.mocks.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_ProfileState();
    init_helpers();
    init_dummy();
    init_helpers10();
    _excluded76 = ["callback", "profilePictureUrl"];
    profileActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default18(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setProfileState", "resetProfileState"]);
      mockedActions.loadProfile = async () => {
        mockedActions.setProfileState({
          loading: true
        });
        await delay();
        actions.setUser(_extends({}, userDemo, userProfileDemo));
        mockedActions.setProfileState({
          loading: false,
          profile: userProfileDemo
        });
      };
      mockedActions.saveProfile = async (_payload) => {
        const {
          callback,
          profilePictureUrl
        } = _payload, payload = _objectWithoutPropertiesLoose(_payload, _excluded76);
        mockedActions.setProfileState({
          saving: true,
          error: null
        });
        const oldProfileData = profileStateDemo;
        let newProfilePictureUrl = oldProfileData.profile.profilePictureUrl;
        if (profilePictureUrl !== oldProfileData.profile.profilePictureUrl && profilePictureUrl) {
          const matchResult = (profilePictureUrl || "").match(/^data:image\/([A-Za-z-+\/]+);base64,(.+)$/);
          if (matchResult) {
            newProfilePictureUrl = profilePictureUrl;
          }
        }
        const newProfileData = _extends({}, oldProfileData.profile, payload, {
          profilePictureUrl: newProfilePictureUrl
        });
        const currentUser = userDemo;
        await delay();
        actions.setUser(_extends({}, currentUser, newProfileData));
        mockedActions.setProfileState({
          loading: false,
          error: null,
          saving: false,
          profile: newProfileData
        });
        callback == null ? void 0 : callback(newProfileData);
      };
      mockedActions.changePassword = async (payload) => {
        var _payload$callback;
        mockedActions.setProfileState({
          loading: true
        });
        await delay();
        mockedActions.setProfileState({
          loading: false,
          error: void 0
        });
        (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/provisioningActions.mocks.js
var provisioningActions_mocks_default;
var init_provisioningActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/provisioningActions.mocks.js"() {
    init_helpers10();
    init_ProvisioningState();
    provisioningActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default19(store, api2, actions);
      return mockActionsExpect(originalActions, ["setProvisioningState", "resetProvisioningState"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/resetPhoneNumberActions.mocks.js
var resetPhoneNumberActions_mocks_default;
var init_resetPhoneNumberActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/resetPhoneNumberActions.mocks.js"() {
    init_helpers10();
    init_ResetPhoneNumberState();
    resetPhoneNumberActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default20(store, api2, actions);
      return mockActionsExpect(originalActions, ["setResetPhoneNumberState", "resetResetPhoneNumberState"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/rolesActions.mocks.js
var rolesActions_mocks_default;
var init_rolesActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/rolesActions.mocks.js"() {
    init_auth2();
    init_helpers();
    init_RolesState();
    init_dummy();
    init_helpers10();
    rolesActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default21(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setRolesState", "setRolesStateError", "setRolesStateLoader", "resetRolesState"]);
      mockedActions.loadRolesAndPermissions = async (payload) => {
        var _payload$silentLoadin;
        const key = RolesStateKeys.LOAD_ROLES;
        mockedActions.setRolesStateLoader({
          key,
          value: !((_payload$silentLoadin = payload == null ? void 0 : payload.silentLoading) != null ? _payload$silentLoadin : false)
        });
        try {
          mockedActions.setRolesState({
            roles: rolesAdminViewerDemo
          });
        } catch (e) {
          mockedActions.setRolesStateError({
            key,
            value: errorHandler(e)
          });
        } finally {
          mockedActions.setRolesStateLoader({
            key,
            value: false
          });
        }
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/security/restrictionsActions.mocks.js
var _excluded77, _excluded228, _excluded318, _excluded414, restrictionsActions_mocks_default;
var init_restrictionsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/security/restrictionsActions.mocks.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_RestrictionsState();
    init_rest_api();
    init_helpers();
    init_dummy();
    init_esm_browser();
    init_helpers10();
    _excluded77 = ["callback"];
    _excluded228 = ["callback"];
    _excluded318 = ["callback"];
    _excluded414 = ["callback"];
    restrictionsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default22(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setRestrictionsState", "setIpRestrictionsState", "setEmailDomainRestrictionsState"]);
      mockedActions.loadIpRestrictions = async () => {
        mockedActions.setIpRestrictionsState({
          loading: true,
          error: null
        });
        mockedActions.setIpRestrictionsState({
          data: {
            restrictions: dummyIps.filter((ip) => ip.strategy === dummyIpConfig.strategy),
            config: dummyIpConfig
          },
          totalPages: 1,
          pagination: {
            _filter: RestrictionType.ALLOW,
            _limit: 50,
            _offset: 0
          },
          loading: false
        });
      };
      mockedActions.loadEmailDomainRestrictions = async () => {
        mockedActions.setEmailDomainRestrictionsState({
          loading: true,
          error: null
        });
        mockedActions.setEmailDomainRestrictionsState({
          loading: false,
          data: {
            restrictions: [{
              domain: "mock.com",
              id: "1",
              type: RestrictionType.ALLOW
            }],
            config: {
              active: true,
              listType: RestrictionType.ALLOW,
              blockPublicDomains: false
            }
          }
        });
      };
      mockedActions.saveIpRestriction = async (payload) => {
        var _ipRestrictionsState$, _ipRestrictionsState$2, _newRestriction$isAct;
        const {
          callback
        } = payload, newRestriction = _objectWithoutPropertiesLoose(payload, _excluded77);
        mockedActions.setIpRestrictionsState({
          saving: true,
          error: null
        });
        const ipRestrictionsState = store.auth.restrictionsState.ipRestrictions;
        const filteredRestrictions = ipRestrictionsState.data.restrictions.filter((r) => r.ip !== newRestriction.ip);
        mockedActions.setIpRestrictionsState({
          data: {
            config: (_ipRestrictionsState$ = (_ipRestrictionsState$2 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$2.config) != null ? _ipRestrictionsState$ : {
              isActive: false,
              strategy: RestrictionType.ALLOW
            },
            restrictions: [...filteredRestrictions, _extends({}, newRestriction, {
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date(),
              id: v4_default(),
              isActive: (_newRestriction$isAct = newRestriction.isActive) != null ? _newRestriction$isAct : true,
              strategy: ipRestrictionsState.data.config.strategy
            })]
          },
          totalPages: 1,
          pagination: {
            _filter: RestrictionType.ALLOW,
            _limit: 50,
            _offset: 0
          },
          saving: false
        });
        callback == null ? void 0 : callback(true);
      };
      mockedActions.saveIpRestrictionsConfig = async (payload) => {
        var _ipRestrictionsState$3, _ipRestrictionsState$4, _ipRestrictionsState$5;
        const {
          callback
        } = payload, config = _objectWithoutPropertiesLoose(payload, _excluded228);
        const ipRestrictionsState = store.auth.restrictionsState.ipRestrictions;
        mockedActions.setIpRestrictionsState({
          saving: true,
          error: null
        });
        mockedActions.setIpRestrictionsState({
          data: {
            config: _extends({}, (_ipRestrictionsState$3 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$3.config, config),
            restrictions: (_ipRestrictionsState$4 = (_ipRestrictionsState$5 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$5.restrictions) != null ? _ipRestrictionsState$4 : []
          },
          pagination: {
            _filter: RestrictionType.ALLOW,
            _limit: 50,
            _offset: 0
          },
          totalPages: 1,
          saving: false
        });
        mockedActions.setIpRestrictionsState({
          saving: false,
          error: null
        });
        callback == null ? void 0 : callback(true);
      };
      mockedActions.deleteIpRestriction = async (payload) => {
        var _ipRestrictionsState$6;
        const {
          callback,
          id
        } = payload;
        mockedActions.setIpRestrictionsState({
          saving: true,
          error: null
        });
        const ipRestrictionsState = store.auth.restrictionsState.ipRestrictions;
        mockedActions.setIpRestrictionsState({
          data: {
            config: ((_ipRestrictionsState$6 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$6.config) || {
              isActive: false,
              strategy: RestrictionType.ALLOW
            },
            restrictions: ipRestrictionsState.data.restrictions.filter((ip) => ip.id !== id)
          },
          pagination: {
            _filter: RestrictionType.ALLOW,
            _limit: 50,
            _offset: 0
          },
          totalPages: 1,
          saving: false,
          error: null
        });
        callback == null ? void 0 : callback(true);
      };
      mockedActions.checkIfUserIpValid = async () => {
        mockedActions.setIpRestrictionsState({
          loading: true,
          error: null
        });
        try {
          const ipRestrictionState = store.auth.restrictionsState.ipRestrictions;
          const userIp = dummyIps[0].ip;
          const userIpValid = !!ipRestrictionState.data.restrictions.find((restriction) => restriction.isActive && restriction.ip === userIp);
          mockedActions.setIpRestrictionsState({
            userIpValid,
            loading: false
          });
        } catch (e) {
          mockedActions.setIpRestrictionsState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      mockedActions.saveEmailDomainRestriction = async (payload) => {
        var _emailDomainRestricti, _emailDomainRestricti2;
        const {
          callback
        } = payload, restriction = _objectWithoutPropertiesLoose(payload, _excluded318);
        const emailDomainRestrictionsState = store.auth.restrictionsState.emailDomainRestrictions;
        mockedActions.setEmailDomainRestrictionsState({
          saving: true,
          error: null
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setEmailDomainRestrictionsState({
          data: {
            config: ((_emailDomainRestricti = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti.config) || {
              active: false,
              blockPublicDomains: false,
              listType: restriction.type
            },
            restrictions: [...((_emailDomainRestricti2 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti2.restrictions) || [], _extends({}, restriction, {
              id: Date.now().toString()
            })]
          },
          saving: false
        });
      };
      mockedActions.saveEmailDomainRestrictionsConfig = async (payload) => {
        var _emailDomainRestricti3;
        const {
          callback
        } = payload, config = _objectWithoutPropertiesLoose(payload, _excluded414);
        const emailDomainRestrictionsState = store.auth.restrictionsState.emailDomainRestrictions;
        mockedActions.setEmailDomainRestrictionsState({
          saving: true,
          error: null
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setEmailDomainRestrictionsState({
          data: {
            config: {
              active: config.active,
              blockPublicDomains: config.blockPublicDomains || false,
              listType: config.type || RestrictionType.ALLOW
            },
            restrictions: [...((_emailDomainRestricti3 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti3.restrictions) || []]
          },
          saving: false
        });
      };
      mockedActions.deleteEmailDomainRestriction = async (payload) => {
        var _emailDomainRestricti4, _emailDomainRestricti5;
        const {
          id
        } = payload;
        const emailDomainRestrictionsState = store.auth.restrictionsState.emailDomainRestrictions;
        mockedActions.setEmailDomainRestrictionsState({
          saving: true,
          error: null
        });
        await delay();
        mockedActions.setEmailDomainRestrictionsState({
          data: {
            config: ((_emailDomainRestricti4 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti4.config) || {
              active: false,
              blockPublicDomains: false,
              listType: RestrictionType.ALLOW
            },
            restrictions: (((_emailDomainRestricti5 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti5.restrictions) || []).filter((restriction) => restriction.id === id)
          },
          saving: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/security/securityCenterActions.mocks.js
var securityCenterActions_mocks_default;
var init_securityCenterActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/security/securityCenterActions.mocks.js"() {
    init_SecurityCenterState();
    init_auth2();
    init_helpers();
    init_dummy();
    init_helpers10();
    securityCenterActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default23(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setSecurityCenterState", "setSecurityCenterStateError", "setSecurityCenterStateLoader", "resetSecurityCenterState"]);
      mockedActions.loadRecommendations = async () => {
        const key = SecurityCenterStateKeys.RECOMMENDATIONS;
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: true
        });
        await delay();
        mockedActions.setSecurityCenterState({
          recommendations: securityCenterRecommendationsMock.recommendations.items,
          score: securityCenterRecommendationsMock.scoring.score
        });
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: false
        });
      };
      mockedActions.loadInsights = async () => {
        const key = SecurityCenterStateKeys.INSIGHTS;
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: true
        });
        await delay();
        mockedActions.setSecurityCenterState({
          insights: securityCenterInsightsMock.insights.items
        });
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: false
        });
      };
      mockedActions.loadBreachedPasswordUsers = async () => {
        const key = SecurityCenterStateKeys.BREACHED_PASSWORD_USERS_TABLE;
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: true
        });
        await delay();
        mockedActions.setSecurityCenterState({
          breachedPasswordUsersTable: securityCenterBreachedPasswordUsersMock
        });
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: false
        });
      };
      mockedActions.loadUnenrolledMfaUsers = async () => {
        const key = SecurityCenterStateKeys.UNENROLLED_MFA_USERS_TABLE;
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: true
        });
        await delay();
        mockedActions.setSecurityCenterState({
          unenrolledMfaUsersTable: securityCenterUnenrolledMfaUsersMock
        });
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: false
        });
      };
      mockedActions.loadInactiveUsers = async () => {
        const key = SecurityCenterStateKeys.INACTIVE_USERS_TABLE;
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: true
        });
        await delay();
        mockedActions.setSecurityCenterState({
          inactiveUsersTable: securityCenterInactivityPasswordUsersMock
        });
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: false
        });
      };
      mockedActions.sendResetBreachedPasswordEmail = async (payload) => {
        const {
          callback
        } = payload;
        const key = SecurityCenterStateKeys.SEND_BREACHED_PASSWORD_EMAIL;
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: true
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setSecurityCenterStateLoader({
          key,
          value: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/security/securityPolicyActions.mocks.js
var _excluded78, _excluded229, _excluded319, securityPolicyActions_mocks_default;
var init_securityPolicyActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/security/securityPolicyActions.mocks.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_SecurityPolicyState();
    init_helpers();
    init_dummy();
    init_helpers10();
    _excluded78 = ["callback"];
    _excluded229 = ["callback"];
    _excluded319 = ["callback"];
    securityPolicyActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default24(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setSecurityPolicyState", "setSecurityPolicyGlobalState", "setSecurityPolicyPublicState", "setSecurityPolicyMfaState", "setSecurityPolicyVendorMfaState", "setSecurityPolicyLockoutState", "setSecurityPolicyVendorLockoutState", "setSecurityPolicyCaptchaState", "setSecurityPolicyPasswordHistoryState", "setSecurityPolicyVendorPasswordHistoryState", "resetSecurityPolicyState", "setSecurityPolicyPasswordState", "setSecurityPolicyAuthStrategyPublicState"]);
      mockedActions.loadSecurityPolicy = async () => {
        mockedActions.setSecurityPolicyGlobalState({
          loading: true,
          error: null
        });
        await Promise.all([mockedActions.loadSecurityPolicyMfa(), mockedActions.loadSecurityPolicyVendorMfa(), mockedActions.loadSecurityPolicyLockout(), mockedActions.loadSecurityPolicyVendorLockout(), mockedActions.loadSecurityPolicyPasswordHistory(), mockedActions.loadSecurityPolicyVendorPasswordHistory(), mockedActions.loadSecurityPolicyCaptcha()]);
        await delay();
        mockedActions.setSecurityPolicyGlobalState({
          policy: policyDemo,
          loading: false
        });
      };
      mockedActions.loadPublicSecurityPolicy = async () => {
        mockedActions.setSecurityPolicyPublicState({
          loading: true,
          error: null
        });
        try {
          mockedActions.setSecurityPolicyPublicState({
            policy: publicSecurityPolicy,
            loading: false
          });
        } catch (e) {
          mockedActions.setSecurityPolicyPublicState({
            error: errorHandler(e),
            loading: false
          });
        }
      };
      mockedActions.saveSecurityPolicyMfa = async (payload) => {
        var _newSecurityPolicy$id;
        const {
          callback
        } = payload, newSecurityPolicy = _objectWithoutPropertiesLoose(payload, _excluded78);
        mockedActions.setSecurityPolicyMfaState({
          saving: true,
          error: null
        });
        const policy = _extends({}, policyLockoutDemo, {
          id: (_newSecurityPolicy$id = newSecurityPolicy.id) != null ? _newSecurityPolicy$id : policyLockoutDemo.id,
          enforceMFAType: newSecurityPolicy.enforceMFAType
        });
        await delay();
        mockedActions.setSecurityPolicyMfaState({
          policy,
          saving: false
        });
        callback == null ? void 0 : callback(policy);
      };
      mockedActions.loadSecurityPolicyMfa = async () => {
        mockedActions.setSecurityPolicyMfaState({
          loading: true,
          error: null
        });
        await delay();
        mockedActions.setSecurityPolicyMfaState({
          policy: policyMfaDemo,
          loading: false
        });
      };
      mockedActions.loadSecurityPolicyVendorMfa = async () => {
        mockedActions.setSecurityPolicyVendorMfaState({
          loading: true,
          error: null
        });
        await delay();
        mockedActions.setSecurityPolicyVendorMfaState({
          policy: policyMfaDemo,
          loading: false
        });
      };
      mockedActions.saveSecurityPolicyLockout = async (payload) => {
        const {
          callback
        } = payload, newSecurityPolicy = _objectWithoutPropertiesLoose(payload, _excluded229);
        mockedActions.setSecurityPolicyLockoutState({
          saving: true,
          error: null
        });
        await delay();
        const policy = _extends({}, policyLockoutDemo, newSecurityPolicy, {
          id: newSecurityPolicy.id ? newSecurityPolicy.id : policyLockoutDemo.id
        });
        callback == null ? void 0 : callback(policy);
        mockedActions.setSecurityPolicyLockoutState({
          policy,
          saving: false
        });
      };
      mockedActions.loadSecurityPolicyLockout = async () => {
        mockedActions.setSecurityPolicyLockoutState({
          loading: true,
          error: null
        });
        await delay();
        mockedActions.setSecurityPolicyLockoutState({
          policy: policyLockoutDemo,
          loading: false
        });
      };
      mockedActions.loadSecurityPolicyVendorLockout = async () => {
        mockedActions.setSecurityPolicyVendorLockoutState({
          loading: true,
          error: null
        });
        await delay();
        mockedActions.setSecurityPolicyVendorLockoutState({
          policy: policyLockoutDemo,
          loading: false
        });
      };
      mockedActions.loadSecurityPolicyCaptcha = async () => {
        mockedActions.setSecurityPolicyLockoutState({
          loading: true,
          error: null
        });
        await delay();
        mockedActions.setSecurityPolicyLockoutState({
          policy: policyLockoutDemo,
          loading: false
        });
      };
      mockedActions.saveSecurityPolicyPasswordHistory = async (payload) => {
        const {
          callback
        } = payload, newSecurityPolicy = _objectWithoutPropertiesLoose(payload, _excluded319);
        mockedActions.setSecurityPolicyPasswordHistoryState({
          saving: true,
          error: null
        });
        await delay();
        const policy = _extends({}, policyPasswordHistoryDemo, newSecurityPolicy, {
          id: newSecurityPolicy.id ? newSecurityPolicy.id : policyPasswordHistoryDemo.id
        });
        callback == null ? void 0 : callback(policy);
        mockedActions.setSecurityPolicyPasswordHistoryState({
          policy,
          saving: false
        });
      };
      mockedActions.loadSecurityPolicyPasswordHistory = async () => {
        mockedActions.setSecurityPolicyPasswordHistoryState({
          loading: true,
          error: null
        });
        await delay();
        mockedActions.setSecurityPolicyPasswordHistoryState({
          policy: policyPasswordHistoryDemo,
          loading: false
        });
      };
      mockedActions.loadSecurityPolicyVendorPasswordHistory = async () => {
        mockedActions.setSecurityPolicyVendorPasswordHistoryState({
          loading: true,
          error: null
        });
        await delay();
        mockedActions.setSecurityPolicyVendorPasswordHistoryState({
          policy: policyPasswordHistoryDemo,
          loading: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/security/sessionsPolicyActions.mocks.js
var _excluded79, sessionsPolicyActions_mocks_default;
var init_sessionsPolicyActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/security/sessionsPolicyActions.mocks.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_SessionsPolicyState();
    init_helpers10();
    _excluded79 = ["callback"];
    sessionsPolicyActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default25(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setSessionsPolicyState", "resetSessionsPolicyState"]);
      mockedActions.loadSessionsPolicy = async () => {
        mockedActions.setSessionsPolicyState({
          loading: true,
          error: null
        });
        const sessionPolicyState = store.auth.sessionsPolicyState;
        mockedActions.setSessionsPolicyState(_extends({}, sessionPolicyState, {
          loading: false
        }));
      };
      mockedActions.createOrUpdateSessionsPolicy = async (payload) => {
        const {
          callback
        } = payload, rest = _objectWithoutPropertiesLoose(payload, _excluded79);
        mockedActions.setSessionsPolicyState({
          loading: true,
          error: null
        });
        callback == null ? void 0 : callback(true);
        mockedActions.setSessionsPolicyState({
          configurations: rest,
          loading: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/sessionsActions.mocks.js
var sessionsActions_mocks_default;
var init_sessionsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/sessionsActions.mocks.js"() {
    init_dummy();
    init_SessionsState();
    init_helpers10();
    sessionsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default26(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setSessionsState", "resetSessionsState"]);
      mockedActions.loadUserSessions = async () => {
        mockedActions.setSessionsState({
          loading: true,
          error: null
        });
        mockedActions.setSessionsState({
          sessions: sessionsMock,
          loading: false
        });
      };
      mockedActions.deleteUserSession = async (payload) => {
        const {
          id
        } = payload;
        mockedActions.setSessionsState({
          loading: true,
          error: null
        });
        const currentSessions = store.auth.sessionsState.sessions;
        const newSessions = currentSessions.filter((s) => s.id !== id);
        mockedActions.setSessionsState({
          sessions: newSessions,
          loading: false
        });
      };
      mockedActions.deleteAllUserSessions = async () => {
        mockedActions.setSessionsState({
          loading: true,
          error: null
        });
        const newSessions = sessionsMock.filter((s) => s.current);
        mockedActions.setSessionsState({
          sessions: newSessions,
          loading: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/signUpActions.mocks.js
var signUpActions_mocks_default;
var init_signUpActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/signUpActions.mocks.js"() {
    init_helpers10();
    init_SignUpState();
    signUpActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default27(store, api2, actions);
      return mockActionsExpect(originalActions, ["setSignUpState", "resetSignUpState", "resetSignUpStateSoft"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/smsActions.mocks.js
var smsActions_mocks_default;
var init_smsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/smsActions.mocks.js"() {
    init_helpers10();
    init_SmsState();
    smsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default28(store, api2, actions);
      return mockActionsExpect(originalActions, ["setSmsState", "resetSmsState"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/socialLoginActions.mocks.js
var socialLoginActions_mocks_default;
var init_socialLoginActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/socialLoginActions.mocks.js"() {
    init_SocialLoginState();
    init_helpers10();
    socialLoginActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default29(store, api2, actions);
      return mockActionsExpect(originalActions, ["setSocialLoginsState", "resetSocialLoginsState", "setSocialLoginError"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/ssoActions.mocks.js
var _excluded80, ssoActions_mocks_default;
var init_ssoActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/ssoActions.mocks.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_helpers();
    init_dummy();
    init_SSOState();
    init_helpers10();
    _excluded80 = ["callback", "samlVendor"];
    ssoActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default30(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setSSOState", "resetSSOState"]);
      mockedActions.loadSSOConfigurations = async () => {
        mockedActions.setSSOState({
          loading: true
        });
        await delay();
        mockedActions.setSSOState({
          samlConfiguration: samlConfigurationDemo,
          loading: false,
          firstLoad: false
        });
      };
      mockedActions.saveSSOConfigurations = async (payload) => {
        var _samlMetadataDemo$con, _samlMetadataDemo$con2;
        const {
          callback,
          samlVendor
        } = payload, newSamlConfiguration = _objectWithoutPropertiesLoose(payload, _excluded80);
        const oldSamlConfiguration = ssoStateDemo.samlConfiguration;
        const samlConfiguration = _extends({}, oldSamlConfiguration, newSamlConfiguration);
        let loaderKey = "saving";
        if ((samlConfiguration == null ? void 0 : samlConfiguration.enabled) !== oldSamlConfiguration.enabled) {
          loaderKey = "loading";
        }
        const firstTimeConfigure = !(samlConfiguration != null && samlConfiguration.domain);
        if (firstTimeConfigure) {
          mockedActions.setSSOState({
            samlConfiguration: _extends({}, oldSamlConfiguration, samlConfiguration)
          });
          return;
        } else {
          mockedActions.setSSOState({
            error: void 0,
            [loaderKey]: true
          });
        }
        await delay();
        samlConfiguration.acsUrl = samlMetadataDemo == null ? void 0 : (_samlMetadataDemo$con = samlMetadataDemo.configuration) == null ? void 0 : _samlMetadataDemo$con.acsUrl;
        samlConfiguration.spEntityId = samlMetadataDemo == null ? void 0 : (_samlMetadataDemo$con2 = samlMetadataDemo.configuration) == null ? void 0 : _samlMetadataDemo$con2.spEntityId;
        const updateSamlConfiguration = omitProps(samlConfiguration, ["validated", "generatedVerification", "createdAt", "updatedAt"]);
        if ((oldSamlConfiguration == null ? void 0 : oldSamlConfiguration.domain) !== (updateSamlConfiguration == null ? void 0 : updateSamlConfiguration.domain)) {
          updateSamlConfiguration.ssoEndpoint = "";
          updateSamlConfiguration.publicCertificate = "";
          updateSamlConfiguration.signRequest = false;
        }
        updateSamlConfiguration.type = samlVendor == null ? void 0 : samlVendor.toLowerCase();
        await delay();
        mockedActions.setSSOState({
          samlConfiguration: updateSamlConfiguration,
          error: void 0,
          [loaderKey]: false
        });
        callback == null ? void 0 : callback(true);
      };
      mockedActions.saveSSOConfigurationsFile = async (configFile) => {
        const loaderKey = "saving";
        mockedActions.setSSOState({
          error: void 0,
          [loaderKey]: true
        });
        const oldSamlConfiguration = store.auth.ssoState.samlConfiguration;
        const newSamlConfiguration = _extends({}, oldSamlConfiguration, {
          enabled: true
        }, configFile[0]);
        mockedActions.setSSOState({
          samlConfiguration: newSamlConfiguration,
          error: void 0,
          [loaderKey]: false
        });
      };
      mockedActions.validateSSODomain = async (payload) => {
        const {
          callback
        } = payload != null ? payload : {};
        const samlConfiguration = ssoStateDemo.samlConfiguration;
        mockedActions.setSSOState({
          error: void 0,
          saving: true
        });
        await delay();
        mockedActions.setSSOState({
          samlConfiguration: _extends({}, samlConfiguration, {
            validated: true
          }),
          error: void 0,
          saving: false
        });
        callback == null ? void 0 : callback(true);
      };
      mockedActions.loadSSOAuthorizationRoles = async () => {
        await delay();
        const data = {
          roleIds: ["1", "2", "3"]
        };
        mockedActions.setSSOState({
          authorizationRoles: data.roleIds,
          error: void 0
        });
      };
      mockedActions.updateSSOAuthorizationRoles = async (payload) => {
        const {
          callback,
          authorizationRoles
        } = payload;
        mockedActions.setSSOState({
          error: void 0,
          saving: true
        });
        await delay();
        mockedActions.setSSOState({
          authorizationRoles,
          error: void 0,
          saving: false
        });
        callback == null ? void 0 : callback(true);
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/stepUpActions.mocks.js
var stepUpActions_mocks_default;
var init_stepUpActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/stepUpActions.mocks.js"() {
    init_helpers10();
    init_StepUpState();
    stepUpActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default31(store, api2, actions);
      return mockActionsExpect(originalActions, ["setStepUpState", "resetStepUpState"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/teamActions.mocks.js
var _excluded81, _excluded230, _excluded320, _excluded415, _excluded511, _excluded610, _excluded710, _excluded84, _excluded93, _excluded103, _excluded113, teamActions_mocks_default;
var init_teamActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/teamActions.mocks.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_auth2();
    init_helpers();
    init_dummy();
    init_TeamState();
    init_esm_browser();
    init_helpers10();
    _excluded81 = ["callback"];
    _excluded230 = ["callback"];
    _excluded320 = ["callback", "profileImage"];
    _excluded415 = ["callback"];
    _excluded511 = ["callback"];
    _excluded610 = ["callback"];
    _excluded710 = ["callback"];
    _excluded84 = ["callback"];
    _excluded93 = ["callback"];
    _excluded103 = ["callback"];
    _excluded113 = ["callback"];
    teamActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default32(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setTeamState", "resetTeamState", "setTeamLoader", "setTeamError", "openAddUserDialog", "closeAddUserDialog", "openDeleteUserDialog", "closeDeleteUserDialog"]);
      mockedActions.loadUsersV2 = async (payload) => {
        var _payload$pageSize, _payload$pageOffset, _payload$filter, _payload$sort;
        const {
          silentLoading,
          callback
        } = payload;
        const teamState = store.auth.teamState;
        const pageSize = (_payload$pageSize = payload.pageSize) != null ? _payload$pageSize : teamState.pageSize;
        const pageOffset = (_payload$pageOffset = payload.pageOffset) != null ? _payload$pageOffset : teamState.pageOffset;
        const filter = (_payload$filter = payload.filter) != null ? _payload$filter : teamState.filterV2;
        const sort = (_payload$sort = payload.sort) != null ? _payload$sort : teamState.sortV2;
        mockedActions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: !silentLoading
        });
        mockedActions.setTeamState({
          pageSize,
          pageOffset,
          filterV2: filter,
          sortV2: sort
        });
        const totalPages = 2;
        const totalItems = 10;
        await delay();
        mockedActions.setTeamState({
          users: usersDemo,
          totalPages,
          totalItems,
          roles: rolesDemo,
          permissions: permissionsDemo
        });
        mockedActions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: false
        });
        callback == null ? void 0 : callback(usersDemo);
      };
      mockedActions.loadAllSubTenantsUsers = async (payload) => {
        var _payload$_limit, _payload$_offset, _payload$_filter, _payload$_sortBy, _payload$_order;
        const {
          silentLoading,
          callback
        } = payload;
        const teamState = store.auth.teamState;
        const _limit = (_payload$_limit = payload._limit) != null ? _payload$_limit : teamState.allUsersQueryParams._limit;
        const _offset = (_payload$_offset = payload._offset) != null ? _payload$_offset : teamState.allUsersQueryParams._offset;
        const _filter = (_payload$_filter = payload._filter) != null ? _payload$_filter : teamState.allUsersQueryParams._filter;
        const _sortBy = (_payload$_sortBy = payload._sortBy) != null ? _payload$_sortBy : teamState.allUsersQueryParams._sortBy;
        const _order = (_payload$_order = payload._order) != null ? _payload$_order : teamState.allUsersQueryParams._order;
        mockedActions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: !silentLoading
        });
        mockedActions.setTeamState({
          allUsersQueryParams: {
            _limit,
            _offset,
            _filter,
            _sortBy,
            _order
          }
        });
        const totalPages = 2;
        const totalItems = 10;
        await delay();
        mockedActions.setTeamState({
          allUsers: allUsersDemo,
          totalPages,
          totalItems,
          roles: rolesDemo,
          permissions: permissionsDemo
        });
        mockedActions.setTeamLoader({
          key: TeamStateKeys.USERS,
          value: false
        });
        callback == null ? void 0 : callback(allUsersDemo);
      };
      mockedActions.loadRoles = async (payload) => {
        var _payload$callback;
        mockedActions.setTeamLoader({
          key: TeamStateKeys.ROLES_AND_PERMISSIONS,
          value: true
        });
        await delay();
        mockedActions.setTeamState({
          roles: rolesDemo,
          permissions: permissionsDemo
        });
        mockedActions.setTeamLoader({
          key: TeamStateKeys.ROLES_AND_PERMISSIONS,
          value: true
        });
        payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, {
          roles: rolesDemo,
          permissions: permissionsDemo
        });
      };
      mockedActions.addUser = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded81);
        const teamState = store.auth.teamState;
        mockedActions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          })
        });
        await delay();
        const date = /* @__PURE__ */ new Date();
        const newUser = _extends({}, userTeamDemo, {
          groups: []
        }, body, {
          id: `${v4_default()}`,
          temporaryExpirationDate: body.expirationInSeconds ? new Date(date.setSeconds(date.getSeconds() + body.expirationInSeconds)) : void 0
        });
        callback == null ? void 0 : callback(newUser);
        mockedActions.setTeamState({
          users: [newUser, ...teamState.users],
          addUserDialogState: {
            open: false,
            loading: false
          }
        });
      };
      mockedActions.addUserToSubTenants = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded230);
        const teamState = store.auth.teamState;
        mockedActions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          })
        });
        await delay();
        const newUser = _extends({}, userTeamDemo, body, {
          id: `${v4_default()}`
        });
        mockedActions.setTeamState({
          users: [newUser, ...teamState.users],
          addUserDialogState: {
            open: false,
            loading: false
          }
        });
        callback == null ? void 0 : callback(null);
      };
      mockedActions.updateUser = async (payload) => {
        var _body$roleIds;
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded320);
        const {
          id: userId
        } = body;
        const teamState = store.auth.teamState;
        const oldUserData = teamState.users.find((user) => user.id === body.id);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER,
          value: userId || ""
        });
        mockedActions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          })
        });
        mockedActions.setTeamState({
          addUserDialogState: _extends({}, teamState.addUserDialogState, {
            loading: true
          }),
          users: teamState.users.map((user) => {
            if (user.id === body.id) {
              return _extends({}, user, body);
            }
            return user;
          })
        });
        if (oldUserData.roleIds.length > 0 && ((_body$roleIds = body.roleIds) == null ? void 0 : _body$roleIds.length) === 0) {
          body.roleIds = [""];
        }
        await delay();
        const newUser = _extends({}, oldUserData, body);
        callback == null ? void 0 : callback(newUser);
        mockedActions.setTeamState({
          users: teamState.users.map((user) => user.id === newUser.id ? _extends({}, user, newUser, {
            createdAt: user.createdAt,
            customData: user.customData,
            lastLogin: user.lastLogin
          }) : user)
        });
        mockedActions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER,
          value: false
        });
      };
      mockedActions.deleteUser = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded415);
        const teamState = store.auth.teamState;
        mockedActions.setTeamState({
          deleteUserDialogState: _extends({}, teamState.deleteUserDialogState, {
            loading: true
          })
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setTeamState({
          users: teamState.users.filter((user) => user.id !== body.userId),
          deleteUserDialogState: {
            open: false,
            loading: false
          }
        });
      };
      mockedActions.updateUserExpirationTime = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded511);
        const teamState = store.auth.teamState;
        mockedActions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
          value: true
        });
        const date = /* @__PURE__ */ new Date();
        mockedActions.setTeamState({
          users: teamState.users.map((user) => {
            return user.id === body.userId ? _extends({}, user, {
              temporaryExpirationDate: body.expirationInSeconds ? new Date(date.setSeconds(date.getSeconds() + body.expirationInSeconds)) : void 0
            }) : user;
          })
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
          value: false
        });
      };
      mockedActions.setUserAsPermanent = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded610);
        const teamState = store.auth.teamState;
        mockedActions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
          value: true
        });
        mockedActions.setTeamState({
          users: teamState.users.map((user) => {
            return user.id === body.userId ? _extends({}, user, {
              temporaryExpirationDate: void 0
            }) : user;
          })
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.UPDATE_USER_EXPIRATION_TIME,
          value: false
        });
      };
      mockedActions.deleteUserFromSubTenants = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded710);
        const teamState = store.auth.teamState;
        mockedActions.setTeamState({
          deleteUserDialogState: _extends({}, teamState.deleteUserDialogState, {
            loading: true
          })
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setTeamState({
          allUsers: teamState.allUsers.filter((user) => user.id !== body.userId),
          deleteUserDialogState: {
            open: false,
            loading: false
          }
        });
      };
      mockedActions.resendActivationLink = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded84);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.RESEND_ACTIVATE_LINK,
          value: body.userId
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.RESEND_ACTIVATE_LINK,
          value: false
        });
      };
      mockedActions.resendInvitationLink = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded93);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.RESEND_INVITATION_LINK,
          value: body.email
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.RESEND_INVITATION_LINK,
          value: false
        });
      };
      mockedActions.resendInvitationEmail = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded103);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.RESEND_INVITATION_LINK,
          value: body.email
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.RESEND_INVITATION_LINK,
          value: false
        });
      };
      mockedActions.resendInvitationLinkToAllSubTenants = async (payload) => {
        const {
          callback
        } = payload, body = _objectWithoutPropertiesLoose(payload, _excluded113);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.RESEND_INVITATION_LINK,
          value: body.email
        });
        await delay();
        callback == null ? void 0 : callback(true);
        mockedActions.setTeamLoader({
          key: TeamStateKeys.RESEND_INVITATION_LINK,
          value: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/tenantsActions.mocks.js
var tenantsActions_mocks_default;
var init_tenantsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/tenantsActions.mocks.js"() {
    init_TenantsState();
    init_dummy();
    init_helpers10();
    tenantsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default33(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setTenantsState", "resetTenantsState"]);
      mockedActions.loadTenants = async () => {
        mockedActions.setTenantsState({
          loading: true
        });
        mockedActions.setTenantsState({
          tenants: tenantsDemo,
          activeTenant: tenantsDemo[0],
          loading: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/unlockAccountActions.mocks.js
var unlockAccountActions_mocks_default;
var init_unlockAccountActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/unlockAccountActions.mocks.js"() {
    init_UnlockAccountState();
    init_helpers10();
    unlockAccountActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default4(store, api2, actions);
      return mockActionsExpect(originalActions, ["setUnlockAccountState", "resetUnlockAccountState"]);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/auth-mocks/index.js
var _excluded85, buildAuthActions2;
var init_auth_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/auth-mocks/index.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_acceptInvitationActions_mocks();
    init_accountSettingsActions_mocks();
    init_activateAccountActions_mocks();
    init_allAccountsActions_mocks();
    init_MSP();
    init_apiTokensActions_mocks();
    init_applicationsActions_mocks();
    init_customLoginActions_mocks();
    init_entitlementsActions_mocks();
    init_forgotPasswordActions_mocks();
    init_passwordRotationActions_mocks();
    init_groupsActions_mocks();
    init_GroupsDialogsState();
    init_impersonateActions_mocks();
    init_loginActions_mocks();
    init_mfaActions_mocks();
    init_passkeysActions_mocks();
    init_profileActions_mocks();
    init_provisioningActions_mocks();
    init_resetPhoneNumberActions_mocks();
    init_rolesActions_mocks();
    init_restrictionsActions_mocks();
    init_securityCenterActions_mocks();
    init_securityPolicyActions_mocks();
    init_sessionsPolicyActions_mocks();
    init_sessionsActions_mocks();
    init_signUpActions_mocks();
    init_smsActions_mocks();
    init_socialLoginActions_mocks();
    init_ssoActions_mocks();
    init_stepUpActions_mocks();
    init_teamActions_mocks();
    init_tenantsActions_mocks();
    init_unlockAccountActions_mocks();
    init_helpers();
    _excluded85 = ["requestName"];
    buildAuthActions2 = (store, api2, actions, snapshotAuthState) => {
      const acceptInvitationActions = acceptInvitationActions_mocks_default(store, api2, actions);
      const accountSettingsActions = accountSettingsActions_mocks_default(store, api2, actions);
      const unlockAccountActions = unlockAccountActions_mocks_default(store, api2, actions);
      const activateAccountActions = activateAccountActions_mocks_default(store, api2, actions);
      const allAccountsActions = allAccountsActions_mocks_default(store, api2, actions);
      const allAccountsDialogActions = actions_default16(store, api2, actions);
      const apiTokensActions = apiTokensActions_mocks_default(store, api2, actions);
      const applicationsActions = applicationsActions_mocks_default(store, api2, actions);
      const customLoginActions = customLoginActions_mocks_default(store, api2, actions);
      const entitlementsActions = entitlementsActions_mocks_default(store, api2, actions);
      const forgotPasswordActions = forgotPasswordActions_mocks_default(store, api2, actions);
      const passwordRotationActions = passwordRotationActions_mocks_default(store, api2, actions);
      const groupsActions = groupsActions_mocks_default(store, api2, actions);
      const groupsDialogsActions = actions_default11(store, api2, actions);
      const impersonateActions = impersonateActions_mocks_default(store, api2, actions);
      const loginActions = loginActions_mocks_default(store, api2, actions);
      const mfaActions = mfaActions_mocks_default(store, api2, actions);
      const passkeysActions = passkeysActions_mocks_default(store, api2, actions);
      const profileActions = profileActions_mocks_default(store, api2, actions);
      const provisioningActions = provisioningActions_mocks_default(store, api2, actions);
      const resetPhoneNumberActions = resetPhoneNumberActions_mocks_default(store, api2, actions);
      const restrictionsActions = restrictionsActions_mocks_default(store, api2, actions);
      const rolesActions = rolesActions_mocks_default(store, api2, actions);
      const securityCenterActions = securityCenterActions_mocks_default(store, api2, actions);
      const securityPolicyActions = securityPolicyActions_mocks_default(store, api2, actions);
      const sessionsActions = sessionsActions_mocks_default(store, api2, actions);
      const sessionsPolicyActions = sessionsPolicyActions_mocks_default(store, api2, actions);
      const signUpActions = signUpActions_mocks_default(store, api2, actions);
      const smsActions = smsActions_mocks_default(store, api2, actions);
      const socialLoginActions = socialLoginActions_mocks_default(store, api2, actions);
      const ssoActions = ssoActions_mocks_default(store, api2, actions);
      const stepUpActions = stepUpActions_mocks_default(store, api2, actions);
      const teamActions = teamActions_mocks_default(store, api2, actions);
      const tenantsActions = tenantsActions_mocks_default(store, api2, actions);
      const authStateActions = {
        acceptInvitationActions,
        accountSettingsActions,
        unlockAccountActions,
        activateAccountActions,
        allAccountsActions,
        allAccountsDialogActions,
        apiTokensActions,
        applicationsActions,
        customLoginActions,
        entitlementsActions,
        forgotPasswordActions,
        passwordRotationActions,
        groupsActions,
        groupsDialogsActions,
        impersonateActions,
        loginActions,
        mfaActions,
        passkeysActions,
        profileActions,
        provisioningActions,
        resetPhoneNumberActions,
        restrictionsActions,
        rolesActions,
        securityCenterActions,
        securityPolicyActions,
        sessionsActions,
        sessionsPolicyActions,
        signUpActions,
        smsActions,
        socialLoginActions,
        ssoActions,
        stepUpActions,
        teamActions,
        tenantsActions
      };
      const setAuthState = (state) => {
        Object.keys(state).forEach((key) => {
          const authKey = key;
          if (isProxy(store.auth[authKey])) {
            Object.assign(store.auth[authKey], state[authKey]);
          } else {
            store.auth[authKey] = state[authKey];
          }
        });
      };
      const resetAuthState = () => {
        deepResetState(store, ["auth"], snapshotAuthState);
      };
      const setUser = (user) => {
        setAuthState({
          user
        });
      };
      const setErrorByRequestName = (_ref) => {
        let {
          requestName
        } = _ref, data = _objectWithoutPropertiesLoose(_ref, _excluded85);
        store.auth.errorByRequest = _extends({}, store.auth.errorByRequest, {
          [requestName]: _extends({}, data, {
            isError: true
          })
        });
      };
      const authActions = _extends({
        setState: setAuthState,
        setAuthState,
        setErrorByRequestName,
        resetAuthState,
        setUser
      }, acceptInvitationActions, accountSettingsActions, activateAccountActions, unlockAccountActions, allAccountsActions, allAccountsDialogActions, apiTokensActions, applicationsActions, customLoginActions, entitlementsActions, forgotPasswordActions, passwordRotationActions, groupsActions, groupsDialogsActions, impersonateActions, loginActions, mfaActions, passkeysActions, profileActions, provisioningActions, resetPhoneNumberActions, restrictionsActions, rolesActions, securityCenterActions, securityPolicyActions, sessionsActions, sessionsPolicyActions, signUpActions, smsActions, socialLoginActions, ssoActions, stepUpActions, teamActions, tenantsActions);
      return {
        authActions,
        authStateActions
      };
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/audits-mocks/dummy.js
var sortMethodBasedOnOrder, filterAuditsByQuery, filterOutTimeFilterForDummyMode, auditsLogsFilterAndSort, randomAction, auditLogsDataDemo, auditLogsMetadataDemo;
var init_dummy2 = __esm({
  "node_modules/@frontegg/redux-store/mocks/audits-mocks/dummy.js"() {
    init_extends();
    sortMethodBasedOnOrder = (sortBy, desc) => (a, b) => {
      if (a[sortBy] > b[sortBy]) {
        return desc ? -1 : 1;
      }
      if (b[sortBy] > a[sortBy]) {
        return desc ? 1 : -1;
      }
      return 0;
    };
    filterAuditsByQuery = (filterOptions) => (log) => filterOptions.filter(filterOutTimeFilterForDummyMode).every((filterItem) => log[filterItem.id].includes(filterItem.value));
    filterOutTimeFilterForDummyMode = (filterItem) => filterItem.id !== "createdAt";
    auditsLogsFilterAndSort = (filterOptions, sortOptions) => {
      const {
        data
      } = auditLogsDataDemo;
      let dataByQuery = data.filter(filterAuditsByQuery(filterOptions));
      if (sortOptions.length) {
        const {
          id,
          desc = false
        } = sortOptions[0];
        dataByQuery = dataByQuery.sort(sortMethodBasedOnOrder(id, desc));
      }
      return {
        data: dataByQuery,
        total: dataByQuery.length
      };
    };
    randomAction = () => {
      const random = Math.floor(Math.random() * 6);
      switch (random) {
        case 0:
          return {
            action: "Updated profile",
            description: "User updated profile details",
            severity: "Info"
          };
        case 1:
          return {
            action: "User logged in",
            severity: "Info",
            description: "User logged in to the product"
          };
        case 2:
          return {
            action: "User failed to login",
            severity: "High",
            description: "User failed to login with password"
          };
        case 3:
          return {
            action: "Added user",
            severity: "Info",
            description: "Added user david+535@frontegg.com to tenant"
          };
        case 4:
          return {
            action: "Assigned roles",
            severity: "Info",
            description: "Assigned 0 roles for user"
          };
        case 5:
          return {
            action: "Removed user david+108@frontegg.com from account",
            severity: "Info",
            description: "Removed access from the account for user david+108@frontegg.com"
          };
      }
    };
    auditLogsDataDemo = {
      total: 20,
      data: Array.from(Array(5).keys()).map((i) => _extends({
        ip: "198.143.51.1",
        user: "Demo User Name",
        email: "demo-user@frontegg.com"
      }, randomAction(), {
        json: {
          key1: "value1",
          key2: "value2",
          key3: "value3",
          key4: "value4"
        },
        tenantId: "my-tenant-id",
        vendorId: "my-vendor-id",
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36",
        createdAt: `2022-04-07 10:${50 - i}:40.201`
      }))
    };
    auditLogsMetadataDemo = {
      properties: [{
        showInTable: true,
        name: "createdAt",
        displayName: "Time",
        type: "Timestamp",
        sortable: true,
        filterable: true,
        showInMoreInfo: "Always",
        chosen: false,
        selected: false,
        isPredefined: false
      }, {
        showInTable: true,
        name: "email",
        displayName: "User",
        type: "Email",
        filterable: true,
        sortable: true,
        isPredefined: true,
        chosen: false,
        selected: false
      }, {
        showInTable: true,
        name: "action",
        displayName: "Action",
        type: "AlphaNumeric",
        sortable: true,
        filterable: true,
        showInMoreInfo: "Always",
        chosen: false,
        selected: false,
        isPredefined: true
      }, {
        showInTable: true,
        name: "description",
        type: "AlphaNumeric",
        sortable: false,
        filterable: false,
        displayName: "Description",
        isPredefined: true,
        chosen: false,
        selected: false
      }, {
        showInTable: true,
        name: "ip",
        displayName: "IP Address",
        type: "IpAddress",
        sortable: true,
        filterable: true,
        showInMoreInfo: "Always",
        chosen: false,
        selected: false,
        isPredefined: true
      }, {
        showInTable: false,
        name: "severity",
        displayName: "Severity",
        type: "Severity",
        sortable: true,
        filterable: true,
        showInMoreInfo: "Always",
        chosen: false,
        selected: false,
        isPredefined: true
      }, {
        showInTable: false,
        name: "userAgent",
        displayName: "User Agent",
        type: "AlphaNumeric",
        filterable: true,
        sortable: true,
        isPredefined: true,
        chosen: false,
        selected: false
      }, {
        showInTable: false,
        name: "json",
        type: "Json",
        sortable: true,
        filterable: true,
        displayName: "Json Data",
        showInMoreInfo: "Always",
        isPredefined: false
      }]
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/audits-mocks/auditLogsActions.mocks.js
var auditLogsActions_mocks_default;
var init_auditLogsActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/audits-mocks/auditLogsActions.mocks.js"() {
    init_helpers10();
    init_AuditLogsState();
    init_helpers();
    init_dummy2();
    auditLogsActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default46(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setAuditLogsState", "resetAuditLogsState"]);
      mockedActions.loadAuditLogs = async (payload) => {
        mockedActions.setAuditLogsState({
          loading: !payload.silentLoading,
          error: null
        });
        const state = store.auditLogs.auditLogsState;
        const {
          columns
        } = store.auditLogs.auditsMetadataState;
        try {
          var _payload$pageSize, _payload$pageOffset, _payload$filter, _payload$sort, _payload$callback;
          const pageSize = (_payload$pageSize = payload.pageSize) != null ? _payload$pageSize : state.pageSize;
          const pageOffset = (_payload$pageOffset = payload.pageOffset) != null ? _payload$pageOffset : state.pageOffset;
          const filter = (_payload$filter = payload.filter) != null ? _payload$filter : state.filter;
          const sort = (_payload$sort = payload.sort) != null ? _payload$sort : state.sort;
          mockedActions.setAuditLogsState({
            pageSize,
            pageOffset,
            filter,
            sort
          });
          if (!columns) {
            await actions.loadAuditsMetadata();
          }
          const {
            data,
            total
          } = auditsLogsFilterAndSort(filter, sort);
          mockedActions.setAuditLogsState({
            loading: false,
            logs: data != null ? data : [],
            totalPages: +Math.ceil(total / pageSize)
          });
          payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
        } catch (e) {
          var _payload$callback2;
          mockedActions.setAuditLogsState({
            loading: false,
            error: errorHandler(e)
          });
          payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
        }
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/audits-mocks/auditsMetadataActions.mocks.js
var auditsMetadataActions_mocks_default;
var init_auditsMetadataActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/audits-mocks/auditsMetadataActions.mocks.js"() {
    init_helpers10();
    init_dummy2();
    init_AuditsMetadataState();
    auditsMetadataActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default47(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setAuditsMetadataState", "resetAuditsMetadataState"]);
      mockedActions.loadAuditsMetadata = async () => {
        mockedActions.setAuditsMetadataState({
          loading: true,
          error: null
        });
        try {
          const {
            properties
          } = auditLogsMetadataDemo;
          mockedActions.setAuditsMetadataState({
            columns: properties,
            loading: false
          });
        } catch (e) {
          mockedActions.setAuditsMetadataState({
            error: e,
            loading: false
          });
        }
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/audits-mocks/index.js
var buildAuditsActions2;
var init_audits_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/audits-mocks/index.js"() {
    init_extends();
    init_auditLogsActions_mocks();
    init_auditsMetadataActions_mocks();
    buildAuditsActions2 = (store, api2, actions) => {
      const auditLogsActions = auditLogsActions_mocks_default(store, api2, actions);
      const auditsMetadataActions = auditsMetadataActions_mocks_default(store, api2, actions);
      return _extends({}, auditLogsActions, auditsMetadataActions);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/connectivity-mocks/index.js
var buildConnectivityActions;
var init_connectivity_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/connectivity-mocks/index.js"() {
    init_connectivity2();
    init_helpers10();
    buildConnectivityActions = (store, api2, actions) => {
      const originalActions = actions_default35(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setConnectivityState", "resetConnectivityState", "initData", "resetConnectivityState", "cleanWebhookTestData", "cleanWebhookLogsData", "cleanWebhookTestMessage", "cleanError", "cleanSlackData"]);
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/configActions.mocks.js
var configActions_mocks_default;
var init_configActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/configActions.mocks.js"() {
    init_helpers10();
    init_helpers();
    init_Config();
    init_interfaces71();
    configActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default36(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setPaymentConfigState", "resetPaymentConfigState"]);
      mockedActions.loadPaymentConfiguration = async () => {
        mockedActions.setPaymentConfigState({
          loading: true
        });
        await delay(500);
        mockedActions.setPaymentConfigState({
          loading: false,
          fetching: false,
          config: {
            paymentProvider: PaymentProvider.STRIPE,
            apiKey: ""
          }
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/dummy.js
var subscriptionResponseMock, planResponseMock, invoicesMock, paymentMethodsMock, vendorPublicConfigurationResponseMock;
var init_dummy3 = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/dummy.js"() {
    init_rest_api();
    subscriptionResponseMock = {
      id: "sub_1JbhYVEwsu4qiqnnfMhYAdY6",
      externalId: "sub_1JbhYVEwsu4qiqnnfMhYAdY6",
      startDate: "2021-09-20T08:08:51.000Z",
      status: ISubscriptionStatus.ACTIVE,
      externallyManaged: false,
      cancellation: null,
      currentPeriodStart: "2021-09-20T08:08:51.000Z",
      currentPeriodEnd: "2021-10-20T08:08:51.000Z",
      plan: {
        // TODO: fix dummy data
        slug: "test"
      }
      // items: [
      //   {
      //     id: 'si_KGE0p5himocPXH',
      //     externalId: 'prod_J60fUEvI7qV1eL',
      //     planId: 'prod_J60fUEvI7qV1eL',
      //     price: {
      //       id: 'price_1IToe8Ewsu4qiqnndAV76J69',
      //       externalId: 'price_1IToe8Ewsu4qiqnndAV76J69',
      //       currency: 'usd',
      //       amount: 10000,
      //     },
      //   },
      // ],
    };
    planResponseMock = [{
      id: "prod_J60fUEvI7qV1eL",
      externalId: "prod_J60fUEvI7qV1eL",
      name: "Premium",
      description: "",
      price: {
        id: "price_1IToe8Ewsu4qiqnndAV76J69",
        externalId: "price_1IToe8Ewsu4qiqnndAV76J69",
        currency: "usd",
        amount: 1e4
      },
      slug: "premium"
    }, {
      id: "prod_J60duauCpXfcur",
      externalId: "prod_J60duauCpXfcur",
      name: "Free",
      description: "Totally free plan. Nothing to pay.",
      price: {
        id: "price_1ITocfEwsu4qiqnnnBHDx9fQ",
        externalId: "price_1ITocfEwsu4qiqnnnBHDx9fQ",
        currency: "usd",
        amount: 0
      },
      slug: "free"
    }];
    invoicesMock = [{
      id: "in_1JbhYWEwsu4qiqnnrUh6hsHa",
      externalId: "in_1JbhYWEwsu4qiqnnrUh6hsHa",
      subscriptionId: "sub_1JbhYVEwsu4qiqnnfMhYAdY6",
      paymentDate: "2021-09-20T08:08:51.000Z",
      totalAmount: 1e4,
      currency: "usd",
      paid: true,
      receiptNumber: ""
    }, {
      id: "in_1JbhYWEwsu4qiqnnrUh6hsHa",
      externalId: "in_1JbhYWEwsu4qiqnnrUh6hsHa",
      subscriptionId: "sub_1JbhYVEwsu4qiqnnfMhYAdY6",
      paymentDate: "2021-08-20T08:08:51.000Z",
      totalAmount: 1e4,
      currency: "usd",
      paid: true,
      receiptNumber: ""
    }];
    paymentMethodsMock = [{
      id: "id",
      externalId: "externalId",
      type: PaymentMethodType.CARD,
      isDefault: true,
      last4: "4242",
      expMonth: 11,
      expYear: 25,
      brand: "visa",
      billingDetails: {
        name: "Dummy",
        email: "dummy@email.com"
      }
    }];
    vendorPublicConfigurationResponseMock = {
      allowPlanDowngrade: true,
      allowPlanCancellation: true
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/informationActions.mocks.js
var informationActions_mocks_default;
var init_informationActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/informationActions.mocks.js"() {
    init_extends();
    init_helpers10();
    init_Information();
    init_dummy3();
    init_rest_api();
    init_helpers();
    informationActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default37(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setBillingInformationState", "resetBillingInformationState"]);
      mockedActions.loadBillingInformation = async () => {
        var _planResponseMock$0$p, _planResponseMock$0$p2;
        mockedActions.setBillingInformationState({
          loading: true
        });
        await delay(500);
        mockedActions.setBillingInformationState({
          loading: false,
          fetching: false,
          summary: {
            subscriptionId: subscriptionResponseMock.id,
            paymentMethodId: "mockPaymentMethodId",
            tenantConfigurationId: "mockTenantConfigurationId",
            providerType: ProviderType.Stripe,
            externallyManaged: false,
            currentPlanId: planResponseMock[0].id,
            defaultPlanId: planResponseMock[0].id
          },
          plan: _extends({}, planResponseMock[0], {
            price: (_planResponseMock$0$p = planResponseMock[0].price) == null ? void 0 : _planResponseMock$0$p.amount,
            currency: (_planResponseMock$0$p2 = planResponseMock[0].price) == null ? void 0 : _planResponseMock$0$p2.currency,
            recurringInterval: "month"
          })
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/paymentMethodActions.mocks.js
var paymentMethodActions_mocks_default;
var init_paymentMethodActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/paymentMethodActions.mocks.js"() {
    init_helpers10();
    init_dummy3();
    init_helpers();
    init_PaymentMethod();
    paymentMethodActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default39(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setBillingPaymentMethodState", "resetBillingPaymentMethodState"]);
      mockedActions.loadPaymentMethod = async () => {
        mockedActions.setBillingPaymentMethodState({
          loading: true
        });
        await delay(500);
        mockedActions.setBillingPaymentMethodState({
          paymentMethod: paymentMethodsMock[0],
          loading: false,
          fetching: false
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/invoicesActions.mocks.js
var invoicesActions_mocks_default;
var init_invoicesActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/invoicesActions.mocks.js"() {
    init_extends();
    init_helpers10();
    init_dummy3();
    init_helpers();
    init_Invoices();
    invoicesActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default38(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setBillingInvoiceState", "resetBillingInvoiceState"]);
      mockedActions.loadBillingInvoices = async () => {
        mockedActions.setBillingInvoiceState({
          loading: true
        });
        await delay(500);
        const selectPlanTitle = "Premium";
        mockedActions.setBillingInvoiceState({
          loading: false,
          fetching: false,
          invoices: invoicesMock.map((invoice) => _extends({}, invoice, {
            selectedPlan: selectPlanTitle,
            paymentDate: new Date(Date.parse(invoice.paymentDate)),
            totalAmount: +((invoice.totalAmount || 0) / 100).toFixed(2)
          }))
        });
      };
      mockedActions.loadInvoices = mockedActions.loadBillingInvoices;
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/subscriptionActions.mocks.js
var subscriptionActions_mocks_default;
var init_subscriptionActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/subscriptionActions.mocks.js"() {
    init_helpers10();
    init_dummy3();
    init_helpers();
    init_Subscription();
    subscriptionActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default40(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setBillingSubscriptionState", "resetBillingSubscriptionState", "setCancellationLoading", "setCancellationError", "setRenewalLoading", "setRenewalError"]);
      mockedActions.loadSubscription = async () => {
        mockedActions.setBillingSubscriptionState({
          loading: true
        });
        await delay(500);
        mockedActions.setBillingSubscriptionState({
          subscription: subscriptionResponseMock,
          fetching: false,
          loading: false,
          error: null
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/index.js
var billingActions_mocks_default;
var init_billingActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/billingActions-mocks/index.js"() {
    init_extends();
    init_informationActions_mocks();
    init_paymentMethodActions_mocks();
    init_invoicesActions_mocks();
    init_subscriptionActions_mocks();
    billingActions_mocks_default = (store, api2, actions) => {
      const informationActions = informationActions_mocks_default(store, api2, actions);
      const paymentMethodActions = paymentMethodActions_mocks_default(store, api2, actions);
      const invoicesActions = invoicesActions_mocks_default(store, api2, actions);
      const subscriptionActions = subscriptionActions_mocks_default(store, api2, actions);
      return [_extends({}, informationActions, paymentMethodActions, invoicesActions, subscriptionActions), {
        information: informationActions,
        invoices: invoicesActions,
        paymentMethod: paymentMethodActions,
        subscription: subscriptionActions
      }];
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/plansActions.mocks.js
var plansActions_mocks_default;
var init_plansActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/plansActions.mocks.js"() {
    init_extends();
    init_helpers10();
    init_Plans();
    init_helpers();
    init_dummy3();
    plansActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default41(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setPlansState", "resetPlansState"]);
      mockedActions.loadPlans = async () => {
        mockedActions.setPlansState({
          loading: true
        });
        await delay(500);
        mockedActions.setPlansState({
          fetching: false,
          loading: false,
          plans: planResponseMock.map((item) => {
            var _item$price, _item$price2;
            return _extends({}, item, {
              price: ((_item$price = item.price) == null ? void 0 : _item$price.amount) || 0,
              currency: ((_item$price2 = item.price) == null ? void 0 : _item$price2.currency) || "usd",
              recurringInterval: "month"
            });
          })
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/checkoutActions.mocks.js
var checkoutActions_mocks_default;
var init_checkoutActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/checkoutActions.mocks.js"() {
    init_helpers10();
    init_Checkout();
    checkoutActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default42(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setCheckoutState", "resetCheckoutState", "errorCheckout", "resetCheckout"]);
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/stripeActions.mocks.js
var stripeActions_mocks_default;
var init_stripeActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/stripeActions.mocks.js"() {
    init_helpers10();
    init_Stripe();
    stripeActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default43(store, api2, actions);
      return mockActionsExpect(originalActions, []);
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/vendorPublicConfigActions.mocks.js
var vendorPublicConfigActions_mocks_default;
var init_vendorPublicConfigActions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/vendorPublicConfigActions.mocks.js"() {
    init_helpers10();
    init_VendorPublicConfig();
    init_helpers();
    init_dummy3();
    vendorPublicConfigActions_mocks_default = (store, api2, actions) => {
      const originalActions = actions_default44(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setVendorPublicConfigState", "resetVendorPublicConfigState", "setVendorPublicConfigError", "setVendorPublicConfigLoading"]);
      mockedActions.loadVendorPublicConfiguration = async () => {
        mockedActions.setVendorPublicConfigLoading(true);
        await delay();
        mockedActions.setVendorPublicConfigState({
          fetching: false,
          loading: false,
          vendorPublicConfig: vendorPublicConfigurationResponseMock
        });
      };
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/index.js
var buildSubscriptionsActions2;
var init_subscriptions_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/subscriptions-mocks/index.js"() {
    init_extends();
    init_configActions_mocks();
    init_billingActions_mocks();
    init_plansActions_mocks();
    init_checkoutActions_mocks();
    init_stripeActions_mocks();
    init_vendorPublicConfigActions_mocks();
    buildSubscriptionsActions2 = (store, api2, actions) => {
      const configActions = configActions_mocks_default(store, api2, actions);
      const [billingActions, billingStateActions] = billingActions_mocks_default(store, api2, actions);
      const plansActions = plansActions_mocks_default(store, api2, actions);
      const checkoutActions = checkoutActions_mocks_default(store, api2, actions);
      const stripeActions = stripeActions_mocks_default(store, api2, actions);
      const vendorPublicConfigActions = vendorPublicConfigActions_mocks_default(store, api2, actions);
      return [_extends({}, configActions, billingActions, plansActions, checkoutActions, stripeActions, vendorPublicConfigActions), {
        config: configActions,
        billing: billingStateActions,
        plans: plansActions,
        checkout: checkoutActions,
        stripe: stripeActions,
        vendorPublicConfig: vendorPublicConfigActions
      }];
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/vendor-mocks/index.js
var buildVendorActions;
var init_vendor_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/vendor-mocks/index.js"() {
    init_vendor2();
    init_helpers10();
    init_helpers();
    buildVendorActions = (store, api2, actions) => {
      const originalActions = actions_default45(store, api2, actions);
      const mockedActions = mockActionsExpect(originalActions, ["setVendorState", "resetVendorState"]);
      mockedActions.loadVendorPublicInfo = async () => {
        try {
          mockedActions.setVendorState({
            whiteLabelMode: false
          });
          await delay();
        } catch (e) {
          console.error("failed to getVendorPublicInfo - ", e);
        }
      };
      mockedActions.loadVendorPublicConfiguration = mockedActions.loadVendorPublicInfo;
      return mockedActions;
    };
  }
});

// node_modules/@frontegg/redux-store/mocks/index.js
var buildMockActions, mocks_default;
var init_mocks = __esm({
  "node_modules/@frontegg/redux-store/mocks/index.js"() {
    init_auth_mocks();
    init_audits_mocks();
    init_connectivity_mocks();
    init_subscriptions_mocks();
    init_vendor_mocks();
    buildMockActions = (store, api2, actions, snapshotAuthState) => {
      const {
        authActions,
        authStateActions
      } = buildAuthActions2(store, api2, actions, snapshotAuthState);
      const connectivityActions = buildConnectivityActions(store, api2, actions);
      const [subscriptionsActions, subscriptionsStateActions] = buildSubscriptionsActions2(store, api2, actions);
      const vendorActions = buildVendorActions(store, api2, actions);
      const auditsActions = buildAuditsActions2(store, api2, actions);
      return {
        authActions,
        authStateActions,
        connectivityActions,
        subscriptionsActions,
        subscriptionsStateActions,
        vendorActions,
        auditsActions
      };
    };
    mocks_default = buildMockActions;
  }
});

// node_modules/@frontegg/redux-store/interfaces.js
var init_interfaces72 = __esm({
  "node_modules/@frontegg/redux-store/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/toolkit/store.js
var import_set_value2, createFronteggStore, createStore;
var init_store = __esm({
  "node_modules/@frontegg/redux-store/toolkit/store.js"() {
    init_extends();
    init_valtio2();
    init_rest_api();
    init_auth2();
    init_connectivity2();
    init_subscriptions3();
    init_vendor2();
    init_audits2();
    import_set_value2 = __toESM(require_set_value());
    init_audits_backward_compatibility();
    init_mocks();
    init_proxy();
    init_auth2();
    init_interfaces72();
    createFronteggStore = (rootInitialState, storeHolder, previewMode = false, authInitialState, overrideInitialState, builderMode = false, urlStrategy = "path") => {
      return createStore({
        name: rootInitialState.appName,
        context: rootInitialState.context,
        storeHolder,
        previewMode,
        builderMode,
        urlStrategy,
        initialState: {
          root: _extends({}, rootInitialState),
          auth: _extends({}, overrideInitialState == null ? void 0 : overrideInitialState.auth, authInitialState),
          connectivity: _extends({}, overrideInitialState == null ? void 0 : overrideInitialState.connectivity),
          subscriptions: _extends({}, overrideInitialState == null ? void 0 : overrideInitialState.subscriptions),
          vendor: _extends({}, overrideInitialState == null ? void 0 : overrideInitialState.vendor),
          auditLogs: _extends({}, overrideInitialState == null ? void 0 : overrideInitialState.auditLogs),
          audits: _extends({}, overrideInitialState == null ? void 0 : overrideInitialState.audits)
        }
      });
    };
    createStore = (options) => {
      var _options$initialState, _options$initialState2, _options$initialState3, _options$initialState4, _options$initialState5, _options$initialState6, _options$initialState7;
      const {
        storeHolder
      } = options;
      const isSSR = typeof window === "undefined";
      let holder = storeHolder;
      if (isSSR && storeHolder == null) {
        throw Error("createFronteggStore(initState, storeHolder) failed, storeHolder must not be null in Server-Side rendering");
      }
      if (!holder) {
        holder = window;
      }
      if (holder.store) {
        return holder.store;
      }
      const appName = options.name || "default";
      const {
        context,
        previewMode = false,
        builderMode = false,
        urlStrategy = "path"
      } = options;
      const contextHolder = ContextHolder.for(appName);
      if (!previewMode && !builderMode) {
        contextHolder.setContext(context);
      }
      if (context.requestCredentials === void 0) {
        context.requestCredentials = "include";
      }
      const authState = createAuthState((_options$initialState = options.initialState) == null ? void 0 : _options$initialState.auth);
      const connectivityState = state_default34((_options$initialState2 = options.initialState) == null ? void 0 : _options$initialState2.connectivity);
      const subscriptionsState = createSubscriptionsState((_options$initialState3 = options.initialState) == null ? void 0 : _options$initialState3.subscriptions);
      const vendorState = state_default44((_options$initialState4 = options.initialState) == null ? void 0 : _options$initialState4.vendor);
      const auditsState = createAuditsState((_options$initialState5 = options.initialState) == null ? void 0 : _options$initialState5.auditLogs);
      const oldAuditsState = state_default47((_options$initialState6 = options.initialState) == null ? void 0 : _options$initialState6.audits);
      const overrideAuthState = (_options$initialState7 = options.initialState) == null ? void 0 : _options$initialState7.auth;
      if (overrideAuthState) {
        Object.keys(overrideAuthState).forEach((key) => {
          (0, import_set_value2.default)(authState, key, overrideAuthState[key], {
            merge: true
          });
        });
      }
      const snapshotAuthState = JSON.parse(JSON.stringify(authState));
      const store = createProxy2({
        root: {
          appName,
          context,
          urlStrategy,
          previewMode
        },
        auth: authState,
        connectivity: connectivityState,
        subscriptions: subscriptionsState,
        vendor: vendorState,
        auditLogs: auditsState,
        audits: oldAuditsState
      });
      if (typeof window !== "undefined" && window.localStorage && (window.localStorage["DEBUG_FRONTEGG_STORE"] === "true" || true)) {
        devtools(store, {
          name: `${appName} Store`,
          enabled: true
        });
      }
      const stateActions = {};
      const actions = {};
      contextHolder.setContext(options.context);
      contextHolder.setAppName(appName);
      const restApiInstance = createApiClient(appName);
      const fetchInstance = new FetchClient(appName);
      const api2 = _extends({}, restApiInstance, {
        fetch: fetchInstance
      });
      if (options.previewMode || options.builderMode) {
        const {
          authActions,
          authStateActions,
          connectivityActions,
          subscriptionsActions,
          subscriptionsStateActions,
          vendorActions,
          auditsActions
        } = mocks_default(store, api2, actions, snapshotAuthState);
        stateActions.auth = authStateActions;
        stateActions.connectivity = connectivityActions;
        stateActions.subscriptions = subscriptionsStateActions;
        stateActions.vendor = vendorActions;
        stateActions.auditLogs = auditsActions;
        stateActions.audits = {};
        Object.assign(actions, _extends({}, authActions, connectivityActions, subscriptionsActions, vendorActions, auditsActions));
        const fronteggStore = {
          dispatch: (action) => {
            setTimeout(() => {
              const [namespace, ...rest] = action.type.split("/");
              const actionName = rest.join("/");
              if (namespace === "auth" && typeof authActions[actionName] === "function") {
                authActions[actionName](action.payload);
              } else if (namespace === "connectivity" && typeof connectivityActions[actionName] === "function") {
                connectivityActions[actionName](action.payload);
              } else if (namespace === "subscriptions" && typeof subscriptionsActions[actionName] === "function") {
                subscriptionsActions[actionName](action.payload);
              } else if (namespace === "vendor" && typeof vendorActions[actionName] === "function") {
                vendorActions[actionName](action.payload);
              }
            });
          },
          getState: () => store,
          subscribe: (callback) => subscribe(store, callback),
          subscribeStateChanged: (callback) => subscribe(store, () => callback(store)),
          store,
          actions,
          stateActions
        };
        if (options.previewMode) {
          fronteggStore.dispatch({
            type: "auth/requestAuthorize",
            payload: true
          });
        }
        if (holder) {
          holder.store = fronteggStore;
        }
        return fronteggStore;
      } else {
        const [authActions, authStateActions] = buildAuthActions(store, api2, actions, snapshotAuthState);
        const connectivityActions = actions_default35(store, api2, actions);
        const [subscriptionsActions, subscriptionsStateActions] = buildSubscriptionsActions(store, api2, actions);
        const vendorActions = actions_default45(store, api2, actions);
        const auditsActions = buildAuditsActions(store, api2, actions);
        const oldAuditsActions = actions_default48(store, api2, actions);
        stateActions.auth = authStateActions;
        stateActions.connectivity = connectivityActions;
        stateActions.subscriptions = subscriptionsStateActions;
        stateActions.vendor = vendorActions;
        stateActions.auditLogs = auditsActions;
        stateActions.audits = oldAuditsActions;
        Object.assign(actions, _extends({}, authActions, connectivityActions, subscriptionsActions, vendorActions, auditsActions));
        return {
          dispatch: (action) => {
            const [namespace, ...rest] = action.type.split("/");
            const actionName = rest.join("/");
            if (namespace === "auth" && typeof authActions[actionName] === "function") {
              authActions[actionName](action.payload);
            } else if (namespace === "connectivity" && typeof connectivityActions[actionName] === "function") {
              connectivityActions[actionName](action.payload);
            } else if (namespace === "subscriptions" && typeof subscriptionsActions[actionName] === "function") {
              subscriptionsActions[actionName](action.payload);
            } else if (namespace === "vendor" && typeof vendorActions[actionName] === "function") {
              vendorActions[actionName](action.payload);
            }
          },
          getState: () => store,
          subscribe: (callback) => subscribe(store, callback),
          subscribeStateChanged: (callback) => subscribe(store, () => callback(store)),
          store,
          actions,
          stateActions
        };
      }
    };
  }
});

// node_modules/@frontegg/redux-store/toolkit/index.js
var init_toolkit = __esm({
  "node_modules/@frontegg/redux-store/toolkit/index.js"() {
    init_FronteggNativeModule();
    init_store();
    init_valtio2();
    init_proxy();
  }
});

// node_modules/@frontegg/redux-store/connectivity/interfaces.js
var init_interfaces73 = __esm({
  "node_modules/@frontegg/redux-store/connectivity/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/vendor/interfaces.js
var init_interfaces74 = __esm({
  "node_modules/@frontegg/redux-store/vendor/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/audits/AuditLogsState/interfaces.js
var init_interfaces75 = __esm({
  "node_modules/@frontegg/redux-store/audits/AuditLogsState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/audits/AuditsMetadataState/interfaces.js
var init_interfaces76 = __esm({
  "node_modules/@frontegg/redux-store/audits/AuditsMetadataState/interfaces.js"() {
  }
});

// node_modules/@frontegg/redux-store/audits/interfaces.js
var init_interfaces77 = __esm({
  "node_modules/@frontegg/redux-store/audits/interfaces.js"() {
    init_interfaces75();
    init_interfaces76();
  }
});

// node_modules/@frontegg/redux-store/index.js
var redux_store_exports = {};
__export(redux_store_exports, {
  ACR_VALUE: () => ACR_VALUE,
  AMR_ADDITIONAL_VALUE: () => AMR_ADDITIONAL_VALUE,
  AMR_MFA_VALUE: () => AMR_MFA_VALUE,
  AcceptInvitationStep: () => AcceptInvitationStep,
  ActivateAccountStep: () => ActivateAccountStep,
  AdminPortalPages: () => AdminPortalPages,
  AdminPortalPagesForEvents: () => AdminPortalPagesForEvents,
  AllAccountsStateKeys: () => AllAccountsStateKeys,
  ApiStateKeys: () => ApiStateKeys,
  AuthStrategyEnum: () => AuthStrategyEnum,
  AuthenticationTypes: () => AuthenticationTypes,
  DEFAULT_RETRY_CONFIG: () => DEFAULT_RETRY_CONFIG,
  FRONTEGG_AFTER_AUTH_REDIRECT_URL: () => FRONTEGG_AFTER_AUTH_REDIRECT_URL,
  ForgotPasswordStep: () => ForgotPasswordStep,
  FronteggNativeModule: () => FronteggNativeModule_default,
  GTMEventAction: () => GTMEventAction,
  GroupRelations: () => GroupRelations2,
  GroupsStateKeys: () => GroupsStateKeys,
  HOSTED_LOGIN_VERIFIER_KEY: () => HOSTED_LOGIN_VERIFIER_KEY,
  ImpersonateStep: () => ImpersonateStep,
  LoginActionTypes: () => LoginActionTypes,
  LoginFlow: () => LoginFlow,
  LoginStep: () => LoginStep,
  MFAStep: () => MFAStep,
  MachineToMachineAuthStrategy: () => MachineToMachineAuthStrategy,
  PasswordRotationStep: () => PasswordRotationStep,
  PaymentMethodType: () => PaymentMethodType2,
  PaymentProvider: () => PaymentProvider,
  QuickLoginStrategy: () => QuickLoginStrategy,
  REQUEST_NAME: () => REQUEST_NAME,
  ResetPhoneNumberStep: () => ResetPhoneNumberStep,
  RolesStateKeys: () => RolesStateKeys,
  SHOULD_STEP_UP_KEY: () => SHOULD_STEP_UP_KEY,
  SSOStateKeys: () => SSOStateKeys,
  STEP_UP_MAX_AGE_PARAM_NAME: () => STEP_UP_MAX_AGE_PARAM_NAME,
  SamlVendors: () => SamlVendors,
  SecurityCenterStateKeys: () => SecurityCenterStateKeys,
  SignUpStage: () => SignUpStage,
  SubscriptionCancellationPolicy: () => SubscriptionCancellationPolicy,
  SubscriptionStatus: () => SubscriptionStatus,
  TENANT_ID_PARAM_KEY: () => TENANT_ID_PARAM_KEY,
  TeamStateKeys: () => TeamStateKeys,
  UserVerifiedOriginTypes: () => UserVerifiedOriginTypes,
  authStrategyLoginStepMap: () => authStrategyLoginStepMap,
  base64ToFormData: () => base64ToFormData,
  base64urlDecode: () => base64urlDecode,
  base64urlEncode: () => base64urlEncode,
  buildAuditsActions: () => buildAuditsActions,
  buildAuthActions: () => buildAuthActions,
  buildConnectivityActions: () => actions_default35,
  buildSubscriptionsActions: () => buildSubscriptionsActions,
  buildVendorActions: () => actions_default45,
  createAuditsState: () => createAuditsState,
  createAuthState: () => createAuthState,
  createConnectivityState: () => state_default34,
  createFronteggStore: () => createFronteggStore,
  createProxy: () => createProxy2,
  createRandomString: () => createRandomString,
  createStore: () => createStore,
  createSubscriptionsState: () => createSubscriptionsState,
  createVendorState: () => state_default44,
  deepClone: () => deepClone,
  deepResetState: () => deepResetState,
  defaultFronteggRoutes: () => defaultFronteggRoutes,
  delay: () => delay,
  errorHandler: () => errorHandler,
  errorTraceId: () => errorTraceId,
  generateCodeChallenge: () => generateCodeChallenge,
  generateCodeChallengeNative: () => generateCodeChallengeNative,
  generateCodeChallengePureJs: () => generateCodeChallengePureJs,
  getBaseNameWithoutSlashSuffix: () => getBaseNameWithoutSlashSuffix,
  getEntitlements: () => getEntitlements,
  getFeatureEntitlements: () => getFeatureEntitlements,
  getMfaStepForEnrolledUsers: () => getMfaStepForEnrolledUsers,
  getMfaStepForNotEnrolledUsers: () => getMfaStepForNotEnrolledUsers,
  getNumberOfMfaDevices: () => getNumberOfMfaDevices,
  getPathAndSearchParamsFromUrl: () => getPathAndSearchParamsFromUrl,
  getPermissionEntitlements: () => getPermissionEntitlements,
  getRedirectUrl: () => getRedirectUrl,
  getSearchParam: () => getSearchParam,
  getSearchParamsFromUrl: () => getSearchParamsFromUrl,
  getUri: () => getUri,
  hmac: () => hmac,
  isAbsoluteUrl: () => isAbsoluteUrl,
  isAuthRoute: () => isAuthRoute,
  isEmailPayload: () => isEmailPayload,
  isEntitlementsDeeplyEqual: () => isEntitlementsDeeplyEqual,
  isError: () => isError,
  isFronteggApiError: () => isFronteggApiError,
  isMfaRequired: () => isMfaRequired,
  isOauthCallbackRoute: () => isOauthCallbackRoute,
  isProxy: () => isProxy,
  isResetPasswordRequired: () => isResetPasswordRequired,
  isSteppedUp: () => isSteppedUp,
  mapMetaDataObjectToActions: () => mapMetaDataObjectToActions,
  omitProps: () => omitProps,
  prepareIdentifiersForSignup: () => prepareIdentifiersForSignup,
  publicKeyCredentialToJSON: () => publicKeyCredentialToJSON,
  readFileAsText: () => readFileAsText,
  redirectByStepUpUrl: () => redirectByStepUpUrl,
  reportGTMEvent: () => reportGTMEvent,
  retry: () => retry,
  retryIfNeeded: () => retryIfNeeded2,
  setAfterAuthRedirectUrlForStepUp: () => setAfterAuthRedirectUrlForStepUp,
  sha256: () => sha256,
  shouldShowPasswordRotationPromptFunc: () => shouldShowPasswordRotationPromptFunc,
  snapshot: () => snapshot,
  subscribe: () => subscribe,
  withRetryConfig: () => withRetryConfig
});
var init_redux_store = __esm({
  "node_modules/@frontegg/redux-store/index.js"() {
    init_toolkit();
    init_constants3();
    init_helpers();
    init_helpers5();
    init_interfaces72();
    init_auth2();
    init_interfaces30();
    init_connectivity2();
    init_interfaces73();
    init_subscriptions3();
    init_interfaces71();
    init_vendor2();
    init_interfaces74();
    init_audits2();
    init_interfaces77();
    init_helpers();
    init_constants3();
  }
});

// node_modules/@frontegg/types/FronteggAppInstance.js
var init_FronteggAppInstance = __esm({
  "node_modules/@frontegg/types/FronteggAppInstance.js"() {
  }
});

// node_modules/@frontegg/types/FronteggAppOptions.js
var init_FronteggAppOptions = __esm({
  "node_modules/@frontegg/types/FronteggAppOptions.js"() {
  }
});

// node_modules/@frontegg/types/FronteggMetadata.js
var init_FronteggMetadata = __esm({
  "node_modules/@frontegg/types/FronteggMetadata.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/LoginBoxCommon.js
var init_LoginBoxCommon = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/LoginBoxCommon.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/LoginPageTheme.js
var init_LoginPageTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/LoginPageTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/SignupPageTheme.js
var SignupFields;
var init_SignupPageTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/SignupPageTheme.js"() {
    (function(SignupFields2) {
      SignupFields2["phoneNumber"] = "phoneNumber";
    })(SignupFields || (SignupFields = {}));
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/UnlockAccountPageTheme.js
var init_UnlockAccountPageTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/UnlockAccountPageTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/CustomLoginComponents.js
var init_CustomLoginComponents = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/CustomLoginComponents.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/SocialLoginsTheme.js
var init_SocialLoginsTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/SocialLoginsTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/ForgotPasswordTheme.js
var init_ForgotPasswordTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/ForgotPasswordTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/ResetPhoneNumberTheme.js
var init_ResetPhoneNumberTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/ResetPhoneNumberTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/ResetPasswordTheme.js
var init_ResetPasswordTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/ResetPasswordTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/ActivateAccountPageTheme.js
var init_ActivateAccountPageTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/ActivateAccountPageTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/AcceptInvitationTheme.js
var init_AcceptInvitationTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/AcceptInvitationTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/OpenAppPageTheme.js
var init_OpenAppPageTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/OpenAppPageTheme.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/DynamicFields/OverrideSignupFields.js
var init_OverrideSignupFields = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/DynamicFields/OverrideSignupFields.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/DynamicFields/index.js
var init_DynamicFields = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/DynamicFields/index.js"() {
    init_OverrideSignupFields();
  }
});

// node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/index.js
var init_LoginBoxTheme = __esm({
  "node_modules/@frontegg/types/ThemeOptions/LoginBoxTheme/index.js"() {
    init_LoginBoxCommon();
    init_LoginPageTheme();
    init_SignupPageTheme();
    init_UnlockAccountPageTheme();
    init_CustomLoginComponents();
    init_SocialLoginsTheme();
    init_ForgotPasswordTheme();
    init_ResetPhoneNumberTheme();
    init_ResetPasswordTheme();
    init_ActivateAccountPageTheme();
    init_AcceptInvitationTheme();
    init_OpenAppPageTheme();
    init_DynamicFields();
  }
});

// node_modules/@frontegg/types/ThemeOptions/ComponentsOptions.js
var init_ComponentsOptions = __esm({
  "node_modules/@frontegg/types/ThemeOptions/ComponentsOptions.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/fieldsAppearanceConsts.js
var ProfilePageFields, PrivacyPageFields, InviteUserModalFields, AccountPageFields, UsersTableColumns, SubscriptionsPageFields, SecurityPageTabs, SessionManagementTabFields, GeneralSettingsTabFields, IpRestrictionsTabFields, DomainRestrictionsTabFields, AccountDetailsPageTabs;
var init_fieldsAppearanceConsts = __esm({
  "node_modules/@frontegg/types/ThemeOptions/fieldsAppearanceConsts.js"() {
    (function(ProfilePageFields2) {
      ProfilePageFields2["Name"] = "name";
      ProfilePageFields2["PhoneNumber"] = "phoneNumber";
      ProfilePageFields2["Address"] = "address";
      ProfilePageFields2["JobTitle"] = "jobTitle";
    })(ProfilePageFields || (ProfilePageFields = {}));
    (function(PrivacyPageFields2) {
      PrivacyPageFields2["LoginSessions"] = "loginSessions";
      PrivacyPageFields2["Mfa"] = "mfa";
    })(PrivacyPageFields || (PrivacyPageFields = {}));
    (function(InviteUserModalFields2) {
      InviteUserModalFields2["Name"] = "name";
      InviteUserModalFields2["PhoneNumber"] = "phoneNumber";
    })(InviteUserModalFields || (InviteUserModalFields = {}));
    (function(AccountPageFields2) {
      AccountPageFields2["CompanyName"] = "companyName";
      AccountPageFields2["Address"] = "address";
      AccountPageFields2["Website"] = "website";
      AccountPageFields2["Timezone"] = "timezone";
      AccountPageFields2["Currency"] = "currency";
    })(AccountPageFields || (AccountPageFields = {}));
    (function(UsersTableColumns2) {
      UsersTableColumns2["User"] = "user";
      UsersTableColumns2["Applications"] = "applications";
      UsersTableColumns2["Groups"] = "groups";
      UsersTableColumns2["Roles"] = "roles";
      UsersTableColumns2["JoinedAt"] = "joinedAt";
      UsersTableColumns2["LastSeen"] = "lastSeen";
      UsersTableColumns2["ManagedBy"] = "managedBy";
    })(UsersTableColumns || (UsersTableColumns = {}));
    (function(SubscriptionsPageFields2) {
      SubscriptionsPageFields2["Invoices"] = "invoices";
    })(SubscriptionsPageFields || (SubscriptionsPageFields = {}));
    (function(SecurityPageTabs2) {
      SecurityPageTabs2["SessionManagement"] = "sessionManagement";
      SecurityPageTabs2["GeneralSettings"] = "generalSettings";
      SecurityPageTabs2["IpRestrictions"] = "ipRestrictions";
      SecurityPageTabs2["DomainRestrictions"] = "domainRestrictions";
    })(SecurityPageTabs || (SecurityPageTabs = {}));
    (function(SessionManagementTabFields2) {
      SessionManagementTabFields2["IdleSessionTimeout"] = "idleSessionTimeout";
      SessionManagementTabFields2["ForceReLogin"] = "forceReLogin";
      SessionManagementTabFields2["MaximumConcurrentSessions"] = "maximumConcurrentSessions";
    })(SessionManagementTabFields || (SessionManagementTabFields = {}));
    (function(GeneralSettingsTabFields2) {
      GeneralSettingsTabFields2["Mfa"] = "mfa";
      GeneralSettingsTabFields2["UserLockout"] = "userLockout";
      GeneralSettingsTabFields2["PasswordHistory"] = "passwordHistory";
    })(GeneralSettingsTabFields || (GeneralSettingsTabFields = {}));
    (function(IpRestrictionsTabFields2) {
      IpRestrictionsTabFields2["IpAddressRestrictions"] = "ipAddressRestrictions";
    })(IpRestrictionsTabFields || (IpRestrictionsTabFields = {}));
    (function(DomainRestrictionsTabFields2) {
      DomainRestrictionsTabFields2["RestrictSignupByEmailDomain"] = "restrictSignupByEmailDomain";
    })(DomainRestrictionsTabFields || (DomainRestrictionsTabFields = {}));
    (function(AccountDetailsPageTabs2) {
      AccountDetailsPageTabs2["Settings"] = "settings";
      AccountDetailsPageTabs2["CustomLogin"] = "customLogin";
    })(AccountDetailsPageTabs || (AccountDetailsPageTabs = {}));
  }
});

// node_modules/@frontegg/types/ThemeOptions/fieldsAppearanceTypes.js
var init_fieldsAppearanceTypes = __esm({
  "node_modules/@frontegg/types/ThemeOptions/fieldsAppearanceTypes.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/AdminPortalThemeOptions.js
var init_AdminPortalThemeOptions = __esm({
  "node_modules/@frontegg/types/ThemeOptions/AdminPortalThemeOptions.js"() {
  }
});

// node_modules/@frontegg/types/ThemeOptions/index.js
var fieldAppearance, tabAppearance;
var init_ThemeOptions = __esm({
  "node_modules/@frontegg/types/ThemeOptions/index.js"() {
    init_LoginBoxTheme();
    init_ComponentsOptions();
    init_fieldsAppearanceConsts();
    init_fieldsAppearanceTypes();
    init_AdminPortalThemeOptions();
    fieldAppearance = {
      hidden: "hidden",
      viewOnly: "viewOnly",
      edit: "edit"
    };
    tabAppearance = {
      hidden: "hidden",
      edit: "edit"
    };
  }
});

// node_modules/@frontegg/types/Localizations/LocalizationOverrides.js
var init_LocalizationOverrides = __esm({
  "node_modules/@frontegg/types/Localizations/LocalizationOverrides.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LocalizationType.js
var init_LocalizationType = __esm({
  "node_modules/@frontegg/types/Localizations/LocalizationType.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/navigation.js
var init_navigation = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/navigation.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/profile.js
var init_profile = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/profile.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/personalTokens.js
var init_personalTokens = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/personalTokens.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/auditLogs.js
var init_auditLogs = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/auditLogs.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/apiTokens.js
var init_apiTokens = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/apiTokens.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/accountSettings.js
var init_accountSettings = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/accountSettings.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/privacy.js
var init_privacy = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/privacy.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/security.js
var init_security = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/security.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/roles.js
var init_roles2 = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/roles.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/sso.js
var init_sso = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/sso.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/users.js
var init_users2 = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/users.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/groups.js
var init_groups2 = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/groups.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/webhooks.js
var init_webhooks = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/webhooks.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/subscriptions.js
var init_subscriptions4 = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/subscriptions.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/allUsers.js
var init_allUsers = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/allUsers.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/provisioning.js
var init_provisioning = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/provisioning.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/allAccounts.js
var init_allAccounts = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/allAccounts.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/appDialog.js
var init_appDialog = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/appDialog.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/index.js
var init_AdminPortalLocalizations = __esm({
  "node_modules/@frontegg/types/Localizations/AdminPortalLocalizations/index.js"() {
    init_navigation();
    init_profile();
    init_personalTokens();
    init_auditLogs();
    init_apiTokens();
    init_accountSettings();
    init_privacy();
    init_security();
    init_roles2();
    init_sso();
    init_users2();
    init_groups2();
    init_webhooks();
    init_subscriptions4();
    init_allUsers();
    init_provisioning();
    init_allAccounts();
    init_appDialog();
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/login.js
var init_login = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/login.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/stepUp.js
var init_stepUp = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/stepUp.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/signup.js
var init_signup = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/signup.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/forgetPassword.js
var init_forgetPassword = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/forgetPassword.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/resetPhoneNumber.js
var init_resetPhoneNumber = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/resetPhoneNumber.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/resetPassword.js
var init_resetPassword = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/resetPassword.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/socialLogins.js
var init_socialLogins = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/socialLogins.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/acceptInvitation.js
var init_acceptInvitation = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/acceptInvitation.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/activateAccount.js
var init_activateAccount = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/activateAccount.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/recoveryMfa.js
var init_recoveryMfa = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/recoveryMfa.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/SplitPageTypes/index.js
var init_SplitPageTypes = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/SplitPageTypes/index.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/impersonate.js
var init_impersonate2 = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/impersonate.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/openApp.js
var init_openApp = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/openApp.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/unlockAccount.js
var init_unlockAccount = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/unlockAccount.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/prestep.js
var init_prestep = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/prestep.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/LoginBoxLocalization/index.js
var init_LoginBoxLocalization = __esm({
  "node_modules/@frontegg/types/Localizations/LoginBoxLocalization/index.js"() {
    init_login();
    init_stepUp();
    init_signup();
    init_forgetPassword();
    init_resetPhoneNumber();
    init_resetPassword();
    init_socialLogins();
    init_acceptInvitation();
    init_activateAccount();
    init_recoveryMfa();
    init_SplitPageTypes();
    init_impersonate2();
    init_openApp();
    init_unlockAccount();
    init_prestep();
  }
});

// node_modules/@frontegg/types/Localizations/Common/passwordStrength.js
var init_passwordStrength = __esm({
  "node_modules/@frontegg/types/Localizations/Common/passwordStrength.js"() {
  }
});

// node_modules/@frontegg/types/Localizations/Common/index.js
var init_Common = __esm({
  "node_modules/@frontegg/types/Localizations/Common/index.js"() {
    init_passwordStrength();
  }
});

// node_modules/@frontegg/types/Localizations/index.js
var init_Localizations = __esm({
  "node_modules/@frontegg/types/Localizations/index.js"() {
    init_LocalizationOverrides();
    init_LocalizationType();
    init_AdminPortalLocalizations();
    init_LoginBoxLocalization();
    init_Common();
  }
});

// node_modules/@frontegg/types/Metadata/colorManipulator.js
function clamp(value, min = 0, max = 1) {
  return Math.min(Math.max(min, value), max);
}
function hexToRgb(color) {
  color = color.substr(1);
  const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, "g");
  let colors = color.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n) => n + n);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function intToHex(int) {
  const hex = int.toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function decomposeColor(color) {
  if (color.type) {
    return color;
  }
  if (color.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color));
  }
  const marker = color.indexOf("(");
  const type = color.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error("MUI: Unsupported `%s` color.\nThe following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color(). " + color);
  }
  const valuesStr = color.substring(marker + 1, color.length - 1);
  let colorSpace;
  let valuesColor;
  if (type === "color") {
    valuesColor = valuesStr.split(" ");
    colorSpace = valuesColor.shift();
    if (valuesColor.length === 4 && valuesColor[3].charAt(0) === "/") {
      valuesColor[3] = valuesColor[3].substr(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error("MUI: unsupported `%s` color space.\nThe following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020." + colorSpace);
    }
  } else {
    valuesColor = valuesStr.split(",");
  }
  const values = valuesColor.map((value) => parseFloat(value));
  return {
    type,
    values,
    colorSpace
  };
}
function recomposeColor(color) {
  const {
    type,
    colorSpace
  } = color;
  let {
    values
  } = color;
  if (type.indexOf("rgb") !== -1) {
    values = values.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.indexOf("hsl") !== -1) {
    values[1] = `${values[1]}%`;
    values[2] = `${values[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values = `${colorSpace} ${values.join(" ")}`;
  } else {
    values = `${values.join(", ")}`;
  }
  return `${type}(${values})`;
}
function rgbToHex(color) {
  if (color.indexOf("#") === 0) {
    return color;
  }
  const {
    values
  } = decomposeColor(color);
  return `#${values.map((n, i) => intToHex(i === 3 ? Math.round(255 * n) : n)).join("")}`;
}
function alpha(color, value) {
  color = decomposeColor(color);
  value = clamp(value);
  if (color.type === "rgb" || color.type === "hsl") {
    color.type += "a";
  }
  if (color.type === "color") {
    color.values[3] = `/${value}`;
  } else {
    color.values[3] = value;
  }
  return recomposeColor(color);
}
function darken(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);
  if (color.type.indexOf("hsl") !== -1) {
    color.values[2] *= 1 - coefficient;
  } else if (color.type.indexOf("rgb") !== -1 || color.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color);
}
function lighten(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);
  if (color.type.indexOf("hsl") !== -1) {
    color.values[2] += (100 - color.values[2]) * coefficient;
  } else if (color.type.indexOf("rgb") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (255 - color.values[i]) * coefficient;
    }
  } else if (color.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (1 - color.values[i]) * coefficient;
    }
  }
  return recomposeColor(color);
}
var init_colorManipulator = __esm({
  "node_modules/@frontegg/types/Metadata/colorManipulator.js"() {
  }
});

// node_modules/@frontegg/types/Metadata/getPalette.js
var generateMainColorObject, generateSubColorObject, getPalette;
var init_getPalette = __esm({
  "node_modules/@frontegg/types/Metadata/getPalette.js"() {
    init_extends();
    init_colorManipulator();
    generateMainColorObject = (color) => {
      if (color) {
        return {
          main: color,
          light: rgbToHex(lighten(color, 0.4)),
          dark: rgbToHex(darken(color, 0.15)),
          hover: rgbToHex(darken(color, 0.15)),
          active: rgbToHex(darken(color, 0.2))
        };
      }
    };
    generateSubColorObject = (color) => {
      if (color) {
        return {
          main: color,
          light: lighten(color, 0.7),
          dark: darken(color, 0.2)
        };
      }
    };
    getPalette = (theme, defaultTheme2) => {
      var _theme$palette, _theme$palette2, _theme$palette$primar, _theme$palette3, _theme$palette4, _theme$palette$second, _theme$palette5, _theme$palette6, _theme$palette7, _theme$palette8, _theme$palette9, _theme$palette10;
      if (!(theme != null && theme.palette) || typeof (theme == null ? void 0 : (_theme$palette = theme.palette) == null ? void 0 : _theme$palette.primary) !== "string") {
        return {};
      }
      return _extends({}, defaultTheme2, {
        palette: {
          primary: _extends({}, generateMainColorObject(theme == null ? void 0 : (_theme$palette2 = theme.palette) == null ? void 0 : _theme$palette2.primary), {
            contrastText: (_theme$palette$primar = theme == null ? void 0 : (_theme$palette3 = theme.palette) == null ? void 0 : _theme$palette3.primaryText) != null ? _theme$palette$primar : "#000000"
          }),
          secondary: _extends({}, generateMainColorObject(theme == null ? void 0 : (_theme$palette4 = theme.palette) == null ? void 0 : _theme$palette4.secondary), {
            contrastText: (_theme$palette$second = theme == null ? void 0 : (_theme$palette5 = theme.palette) == null ? void 0 : _theme$palette5.secondaryText) != null ? _theme$palette$second : "#000000"
          }),
          danger: _extends({}, generateMainColorObject(theme == null ? void 0 : (_theme$palette6 = theme.palette) == null ? void 0 : _theme$palette6.error), {
            contrastText: "#FFF"
          }),
          success: _extends({}, generateSubColorObject(theme == null ? void 0 : (_theme$palette7 = theme.palette) == null ? void 0 : _theme$palette7.success), {
            contrastText: "#FFF"
          }),
          error: _extends({}, generateSubColorObject(theme == null ? void 0 : (_theme$palette8 = theme.palette) == null ? void 0 : _theme$palette8.error), {
            contrastText: "#FFF"
          }),
          warning: _extends({}, generateSubColorObject(theme == null ? void 0 : (_theme$palette9 = theme.palette) == null ? void 0 : _theme$palette9.warning), {
            contrastText: "#FFF"
          }),
          info: _extends({}, generateSubColorObject(theme == null ? void 0 : (_theme$palette10 = theme.palette) == null ? void 0 : _theme$palette10.info), {
            contrastText: "#FFF"
          })
        }
      });
    };
  }
});

// node_modules/@frontegg/types/Metadata/index.js
var import_deepmerge2, defaultMetadata, Metadata;
var init_Metadata = __esm({
  "node_modules/@frontegg/types/Metadata/index.js"() {
    import_deepmerge2 = __toESM(require_cjs());
    init_getPalette();
    init_colorManipulator();
    defaultMetadata = {
      theme: {},
      themeV2: {},
      localizations: {},
      navigation: {
        usage: {
          visibility: "hidden",
          permissions: ["fe.usage.read"],
          featureFlag: "fe-usage-page"
        },
        webhooks: {
          visibility: "hidden",
          permissions: ["fe.connectivity.read.webhooks"]
        },
        roles: {
          visibility: "hidden",
          permissions: ["fe.secure.read.roles"]
        },
        users: {
          visibility: "always",
          permissions: ["fe.secure.read.users"],
          inviteDialog: {
            phoneNumberField: "optional"
          }
        },
        personalApiTokens: {
          visibility: "hidden",
          permissions: ["fe.secure.read.userApiTokens"]
        },
        apiTokens: {
          visibility: "hidden",
          permissions: ["fe.secure.read.tenantApiTokens"]
        },
        profile: {
          visibility: "always"
        },
        privacy: {
          visibility: "always"
        },
        account: {
          visibility: "always",
          permissions: ["fe.secure.read.accountSettings"]
        },
        security: {
          visibility: "always",
          permissions: ["fe.secure.read.securityPolicy"]
        },
        sso: {
          visibility: "hidden",
          permissions: ["fe.secure.read.samlConfiguration"]
        },
        provisioning: {
          visibility: "hidden",
          permissions: ["fe.secure.read.provisioningConfiguration"]
        },
        audits: {
          visibility: "always",
          permissions: ["fe.secure.read.audits"]
        },
        subscriptions: {
          visibility: "hidden",
          permissions: ["fe.subscriptions.*"]
        },
        allAccounts: {
          visibility: "byPermissions",
          permissions: ["fe.account-hierarchy.read.subAccount"]
        },
        groups: {
          visibility: "hidden",
          permissions: ["fe.secure.read.groups"]
        }
      }
    };
    Metadata = class _Metadata {
      constructor() {
        this._theme = defaultMetadata.theme;
        this._themeV2 = defaultMetadata.themeV2;
        this._navigation = defaultMetadata.navigation;
        this._localizations = defaultMetadata.localizations;
        this._integrations = defaultMetadata.integrations;
      }
      static getInstance(name = "default") {
        return this._instances[name];
      }
      static set(metadata, name = "default") {
        const metadataInstance = new _Metadata();
        metadataInstance.set(metadata);
        _Metadata._instances[name] = metadataInstance;
        return metadataInstance;
      }
      get theme() {
        var _this$_theme;
        return (_this$_theme = this._theme) != null ? _this$_theme : {};
      }
      get themeV2() {
        var _this$_themeV;
        return (_this$_themeV = this._themeV2) != null ? _this$_themeV : {};
      }
      get navigation() {
        var _this$_navigation;
        return (_this$_navigation = this._navigation) != null ? _this$_navigation : {};
      }
      get localizations() {
        var _this$_localizations;
        return (_this$_localizations = this._localizations) != null ? _this$_localizations : {};
      }
      get integrations() {
        var _this$_integrations;
        return (_this$_integrations = this._integrations) != null ? _this$_integrations : {};
      }
      set(metadata) {
        try {
          var _defaultMetadata$navi, _metadata$navigation, _defaultMetadata$them, _defaultMetadata$them2, _metadata$themeV, _defaultMetadata$loca, _metadata$localizatio, _defaultMetadata$inte, _metadata$integration;
          this._navigation = import_deepmerge2.default.all([(_defaultMetadata$navi = defaultMetadata.navigation) != null ? _defaultMetadata$navi : {}, (_metadata$navigation = metadata == null ? void 0 : metadata.navigation) != null ? _metadata$navigation : {}]);
          this._theme = import_deepmerge2.default.all([(_defaultMetadata$them = defaultMetadata.theme) != null ? _defaultMetadata$them : {}, getPalette(metadata == null ? void 0 : metadata.theme, defaultMetadata.theme)]);
          this._themeV2 = import_deepmerge2.default.all([(_defaultMetadata$them2 = defaultMetadata.themeV2) != null ? _defaultMetadata$them2 : {}, (_metadata$themeV = metadata == null ? void 0 : metadata.themeV2) != null ? _metadata$themeV : {}]);
          this._localizations = import_deepmerge2.default.all([(_defaultMetadata$loca = defaultMetadata.localizations) != null ? _defaultMetadata$loca : {}, (_metadata$localizatio = metadata == null ? void 0 : metadata.localizations) != null ? _metadata$localizatio : {}]);
          this._integrations = import_deepmerge2.default.all([(_defaultMetadata$inte = defaultMetadata.integrations) != null ? _defaultMetadata$inte : {}, (_metadata$integration = metadata == null ? void 0 : metadata.integrations) != null ? _metadata$integration : {}]);
        } catch (e) {
          this._navigation = defaultMetadata.navigation;
          this._theme = defaultMetadata.theme;
          this._themeV2 = defaultMetadata.themeV2;
          this._localizations = defaultMetadata.localizations;
          this._integrations = defaultMetadata.integrations;
        }
      }
    };
    Metadata._instances = {};
  }
});

// node_modules/@frontegg/types/CheckoutDialogOptions.js
var init_CheckoutDialogOptions = __esm({
  "node_modules/@frontegg/types/CheckoutDialogOptions.js"() {
  }
});

// node_modules/@frontegg/types/CustomLoginTypes.js
var init_CustomLoginTypes = __esm({
  "node_modules/@frontegg/types/CustomLoginTypes.js"() {
  }
});

// node_modules/@frontegg/types/ShowAdminPortalOptions.js
var init_ShowAdminPortalOptions = __esm({
  "node_modules/@frontegg/types/ShowAdminPortalOptions.js"() {
  }
});

// node_modules/@frontegg/types/Common.js
var init_Common2 = __esm({
  "node_modules/@frontegg/types/Common.js"() {
  }
});

// node_modules/@frontegg/types/index.js
var types_exports = {};
__export(types_exports, {
  AccountDetailsPageTabs: () => AccountDetailsPageTabs,
  AccountPageFields: () => AccountPageFields,
  DomainRestrictionsTabFields: () => DomainRestrictionsTabFields,
  GeneralSettingsTabFields: () => GeneralSettingsTabFields,
  InviteUserModalFields: () => InviteUserModalFields,
  IpRestrictionsTabFields: () => IpRestrictionsTabFields,
  Metadata: () => Metadata,
  PrivacyPageFields: () => PrivacyPageFields,
  ProfilePageFields: () => ProfilePageFields,
  SecurityPageTabs: () => SecurityPageTabs,
  SessionManagementTabFields: () => SessionManagementTabFields,
  SignupFields: () => SignupFields,
  SubscriptionsPageFields: () => SubscriptionsPageFields,
  UsersTableColumns: () => UsersTableColumns,
  alpha: () => alpha,
  fieldAppearance: () => fieldAppearance,
  tabAppearance: () => tabAppearance
});
var init_types = __esm({
  "node_modules/@frontegg/types/index.js"() {
    init_FronteggAppInstance();
    init_FronteggAppOptions();
    init_FronteggMetadata();
    init_ThemeOptions();
    init_Localizations();
    init_Metadata();
    init_CheckoutDialogOptions();
    init_CustomLoginTypes();
    init_ShowAdminPortalOptions();
    init_Common2();
  }
});

// node_modules/@frontegg/js/utils/index.js
var formatName, createElement, waitThemeSetter, restoreSearchParams;
var init_utils3 = __esm({
  "node_modules/@frontegg/js/utils/index.js"() {
    formatName = function formatName2(name) {
      return name.replace(/\W+/g, " ").split(/ |\B(?=[A-Z])/).map(function(word) {
        return word.toLowerCase();
      }).join("");
    };
    createElement = function createElement2(container, type) {
      var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var el = document.createElement(type);
      Object.keys(attrs).forEach(function(key) {
        return el.setAttribute(key, attrs[key]);
      });
      container.appendChild(el);
      return el;
    };
    waitThemeSetter = function waitThemeSetter2(instance) {
      return new Promise(function(resolve, reject) {
        var timeout = 4e3;
        var interval = setInterval(function() {
          if (instance.themeSetter != null) {
            clearInterval(interval);
            resolve(true);
            return;
          }
          if (timeout < 0) {
            reject("Failed to load Renderer with themeSetter");
            clearInterval(interval);
            return;
          }
          timeout -= 50;
        }, 50);
      });
    };
    restoreSearchParams = function restoreSearchParams2(searchParams) {
      var stringifiedSearchParams = searchParams.toString();
      if (!stringifiedSearchParams) {
        return;
      }
      var url = new URL(window.location.href);
      url.search = stringifiedSearchParams;
      window.history.pushState(null, "", url.toString());
    };
  }
});

// node_modules/@frontegg/js/version.js
var version_default2;
var init_version2 = __esm({
  "node_modules/@frontegg/js/version.js"() {
    version_default2 = {
      cdnVersion: "7.69.0"
    };
  }
});

// node_modules/@frontegg/js/utils/mockFlagsList.js
var mockFlagsList;
var init_mockFlagsList = __esm({
  "node_modules/@frontegg/js/utils/mockFlagsList.js"() {
    mockFlagsList = {
      admin_portal_ip_restrictions: "on",
      admin_portal_domain_restrictions: "on",
      "new-mfa-pages": "on",
      "show-passkeys-new": "on",
      "groups-admin-box-new": "on",
      "msp-all-accounts-new": "on",
      "temporary-users": "on"
    };
  }
});

// node_modules/@frontegg/js/FronteggApp/utils.js
var import_regenerator, import_deepmerge3, isValidGTMKey, loadGTM, getOverriddenMetadata;
var init_utils4 = __esm({
  "node_modules/@frontegg/js/FronteggApp/utils.js"() {
    init_asyncToGenerator();
    import_regenerator = __toESM(require_regenerator());
    init_types();
    import_deepmerge3 = __toESM(require_cjs());
    init_redux_store();
    isValidGTMKey = function isValidGTMKey2(key) {
      return /^GTM-[a-zA-Z0-9]+$/.test(key);
    };
    loadGTM = function loadGTM2(fronteggAppName) {
      var _metadata$integration;
      var metadata = Metadata.getInstance(fronteggAppName);
      var gtmKeysConfig = metadata == null ? void 0 : (_metadata$integration = metadata.integrations) == null ? void 0 : _metadata$integration.gtm;
      gtmKeysConfig == null ? void 0 : gtmKeysConfig.filter(function(_ref) {
        var id = _ref.id, enabled = _ref.enabled;
        return enabled && isValidGTMKey(id);
      }).forEach(function(_ref2) {
        var id = _ref2.id;
        var script = document.createElement("script");
        script.innerHTML = "\n        (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':\n        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],\n        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=\n        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);\n        })(window,document,'script','dataLayer','".concat(id, "');\n      ");
        document.body.appendChild(script);
      });
    };
    getOverriddenMetadata = function() {
      var _ref3 = _asyncToGenerator(import_regenerator.default.mark(function _callee(metadata, fetchClient, retryConfig) {
        var _metadata$metadataOve;
        var overrideUrl, overrideData, overriddenMetadata;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              overrideUrl = (_metadata$metadataOve = metadata.metadataOverrides) == null ? void 0 : _metadata$metadataOve.url;
              if (overrideUrl) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return", metadata);
            case 3:
              _context.prev = 3;
              _context.next = 6;
              return retryIfNeeded2(function() {
                return fetchClient.sendRequest({
                  url: overrideUrl,
                  method: "GET",
                  credentials: "omit"
                });
              }, retryConfig);
            case 6:
              overrideData = _context.sent;
              if (!overrideData) {
                _context.next = 10;
                break;
              }
              overriddenMetadata = (0, import_deepmerge3.default)(metadata, overrideData);
              return _context.abrupt("return", overriddenMetadata);
            case 10:
              _context.next = 15;
              break;
            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](3);
              console.error("Failed to get metadata overrides", _context.t0);
            case 15:
              return _context.abrupt("return", metadata);
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[3, 12]]);
      }));
      return function getOverriddenMetadata2(_x, _x2, _x3) {
        return _ref3.apply(this, arguments);
      };
    }();
  }
});

// node_modules/@frontegg/js/FronteggApp/FronteggApp.js
var import_regenerator2, FronteggApp;
var init_FronteggApp = __esm({
  "node_modules/@frontegg/js/FronteggApp/FronteggApp.js"() {
    init_slicedToArray();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_regenerator2 = __toESM(require_regenerator());
    init_redux_store();
    init_redux_store();
    init_types();
    init_types();
    init_utils3();
    init_AppHolder();
    init_rest_api();
    init_rest_api();
    init_version2();
    init_mockFlagsList();
    init_utils4();
    FronteggApp = function() {
      function FronteggApp2(_options, name) {
        var _this = this, _this$options$authOpt3, _options$authOptions, _options$authOptions2;
        var iframeRendering = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var allowMultipleRenderers = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        _classCallCheck(this, FronteggApp2);
        this.name = void 0;
        this.iframeRendering = void 0;
        this.options = void 0;
        this.loading = true;
        this.cdnUrl = "https://assets.frontegg.com/admin-box/".concat(version_default2.cdnVersion);
        this.assetsUrl = "https://adminBox.frontegg.com/admin-box/".concat(version_default2.cdnVersion);
        this.customElementName = "";
        this.adminPortalEl = void 0;
        this.adminPortalRenderer = void 0;
        this.loginBoxEl = void 0;
        this.checkoutDialogEl = void 0;
        this.checkoutDialogRenderer = void 0;
        this.adminPortalContainer = void 0;
        this.loginBoxContainer = void 0;
        this.checkoutDialogContainer = void 0;
        this.loginBoxRenderer = void 0;
        this.store = void 0;
        this.loadingListeners = [];
        this.fetchClient = void 0;
        this.apiClient = void 0;
        this.updateLocalizations = void 0;
        this.loadAdminBoxMetadata = _asyncToGenerator(import_regenerator2.default.mark(function _callee() {
          var _data$rows$0$configur, _data$rows, _data$rows$, data, metadata;
          return import_regenerator2.default.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (_this.options.metadata) {
                  _context.next = 21;
                  break;
                }
                _context.prev = 1;
                _context.next = 4;
                return retryIfNeeded2(function() {
                  return _this.fetchClient.get("/metadata", {
                    entityName: "adminBox"
                  });
                }, DEFAULT_RETRY_CONFIG);
              case 4:
                data = _context.sent;
                metadata = (_data$rows$0$configur = data == null ? void 0 : (_data$rows = data.rows) == null ? void 0 : (_data$rows$ = _data$rows[0]) == null ? void 0 : _data$rows$.configuration) != null ? _data$rows$0$configur : {};
                _context.prev = 6;
                _context.next = 9;
                return getOverriddenMetadata(metadata, _this.fetchClient, DEFAULT_RETRY_CONFIG);
              case 9:
                _this.options.metadata = _context.sent;
                _context.next = 15;
                break;
              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](6);
                console.error("failed to get admin portal overridden metadata", _context.t0);
              case 15:
                _context.next = 21;
                break;
              case 17:
                _context.prev = 17;
                _context.t1 = _context["catch"](1);
                console.error("failed to get admin portal metadata", _context.t1);
                _this.dispatchErrorByRequestName(_context.t1, REQUEST_NAME.LOAD_ADMIN_BOX_METADATA);
              case 21:
                Metadata.set(_this.options.metadata, _this.name);
              case 22:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[1, 17], [6, 12]]);
        }));
        this.requestAuthorize = _asyncToGenerator(import_regenerator2.default.mark(function _callee2() {
          var _this$options$authOpt, _this$options$authOpt2;
          var shouldRequestHostedLoginAuthorize;
          return import_regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                shouldRequestHostedLoginAuthorize = (_this$options$authOpt = _this.options.authOptions) == null ? void 0 : (_this$options$authOpt2 = _this$options$authOpt.hostedLoginOptions) == null ? void 0 : _this$options$authOpt2.loadUserOnFirstLoad;
                if (!_this.options.builderMode && _this.options.framework !== "nextjs") {
                  if (_this.options.hostedLoginBox && !_this.options.customLoginBox) {
                    if (shouldRequestHostedLoginAuthorize) {
                      _this.store.dispatch({
                        type: "auth/requestHostedLoginAuthorizeV2",
                        payload: {
                          shouldRedirectToLogin: false,
                          firstTime: true
                        }
                      });
                    }
                  } else {
                    _this.store.dispatch({
                      type: "auth/requestAuthorize",
                      payload: true
                    });
                  }
                }
              case 2:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        this.loadFeatureFlags = _asyncToGenerator(import_regenerator2.default.mark(function _callee3() {
          var flags;
          return import_regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                if (!(_this.options.previewMode || _this.options.builderMode)) {
                  _context3.next = 4;
                  break;
                }
                FeatureFlags.set(mockFlagsList, _this.name);
                _context3.next = 16;
                break;
              case 4:
                _context3.prev = 4;
                _context3.next = 7;
                return retryIfNeeded2(function() {
                  return _this.apiClient.featureFlags.loadFeatureFlags();
                }, DEFAULT_RETRY_CONFIG);
              case 7:
                flags = _context3.sent;
                if (_this.options.overrideFeatureFlags) {
                  Object.assign(flags, _this.options.overrideFeatureFlags);
                }
                FeatureFlags.set(flags, _this.name);
                _context3.next = 16;
                break;
              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](4);
                console.error("failed to get admin portal feature flags", _context3.t0);
                _this.dispatchErrorByRequestName(_context3.t0, REQUEST_NAME.LOAD_FEATURE_FLAGS);
              case 16:
              case "end":
                return _context3.stop();
            }
          }, _callee3, null, [[4, 12]]);
        }));
        this.setFeatureFlagsForPreview = function(previewFeatureFlags) {
          FeatureFlags.set(Object.assign({}, mockFlagsList, previewFeatureFlags), _this.name);
        };
        this.queryFeatureFlags = function(flags) {
          return FeatureFlags.getFeatureFlags(flags, _this.name);
        };
        this.updateLocalizationsSetter = function(localizationUpdateFn) {
          _this.updateLocalizations = localizationUpdateFn;
        };
        this.getEntitlementsFromStore = function() {
          var _this$store$getState$;
          return (_this$store$getState$ = _this.store.getState().auth.user) == null ? void 0 : _this$store$getState$.entitlements;
        };
        this.getUserFromStore = function() {
          return _this.store.getState().auth.user;
        };
        this.getEntitlementsQueryData = function(customAttributes) {
          var user = _this.getUserFromStore();
          var entitlements = _this.getEntitlementsFromStore();
          var attributes = {
            custom: customAttributes,
            jwt: user
          };
          return {
            entitlements,
            attributes
          };
        };
        var appName = formatName(name);
        var customElementName = "frontegg-app-".concat(appName);
        this.iframeRendering = iframeRendering;
        this.name = appName;
        this.options = Object.assign({}, _options, {
          contextOptions: Object.assign({
            requestCredentials: "include"
          }, _options.contextOptions)
        });
        this.fetchClient = new FetchClient(this.name);
        this.apiClient = createApiClient(this.name);
        if (this.options.cdnUrl) {
          this.cdnUrl = this.options.cdnUrl;
        }
        if (this.options.assetsUrl) {
          this.assetsUrl = this.options.assetsUrl;
        }
        ContextHolder["for"](this.name).setCdnUrl(this.cdnUrl);
        ContextHolder["for"](this.name).setAssetsUrl(this.assetsUrl);
        this.customElementName = customElementName;
        var authOptions = this.options.authOptions ? Object.assign({}, this.options.authOptions, {
          hostedLoginBox: this.options.hostedLoginBox
        }) : {
          hostedLoginBox: this.options.hostedLoginBox
        };
        authOptions.onRedirectTo = _options.onRedirectTo;
        authOptions.disableSilentRefresh = (_this$options$authOpt3 = this.options.authOptions) == null ? void 0 : _this$options$authOpt3.disableSilentRefresh;
        if (this.options.store) {
          this.store = this.options.store;
          if (!allowMultipleRenderers && this.options.store.getState().root.appName !== name) {
            throw Error("Mismatch in store names");
          }
        } else {
          var _this$options$authOpt4, _this$options$auditsO;
          this.store = createStore({
            context: this.options.contextOptions,
            name: this.name,
            builderMode: this.options.builderMode,
            previewMode: this.options.previewMode,
            storeHolder: this,
            urlStrategy: this.options.urlStrategy,
            initialState: {
              auth: Object.assign({}, authOptions, (_this$options$authOpt4 = this.options.authOptions) != null ? _this$options$authOpt4 : {}),
              auditLogs: Object.assign({}, (_this$options$auditsO = this.options.auditsOptions) != null ? _this$options$auditsO : {})
            }
          });
        }
        AppHolder.setInstance(appName, this);
        var contextHolder = ContextHolder["for"](appName);
        contextHolder.setAppName(appName);
        this.setEntitlementsOptions(_options.entitlementsOptions);
        this.setSessionContext({
          enableSessionPerTenant: (_options$authOptions = _options.authOptions) == null ? void 0 : _options$authOptions.enableSessionPerTenant,
          skipUserLoading: (_options$authOptions2 = _options.authOptions) == null ? void 0 : _options$authOptions2.skipUserLoading
        });
        var basename = _options.basename;
        if (basename) {
          contextHolder.setBasename(basename);
        }
      }
      _createClass(FronteggApp2, [{
        key: "setEntitlementsOptions",
        value: function setEntitlementsOptions(entitlementsOptions) {
          ContextHolder["for"](this.name).setEntitlementsOptions(Object.assign({}, entitlementsOptions));
        }
      }, {
        key: "setSessionContext",
        value: function setSessionContext(sessionContext) {
          ContextHolder["for"](this.name).setSessionContext(Object.assign({}, sessionContext));
        }
      }, {
        key: "dispatchErrorByRequestName",
        value: function dispatchErrorByRequestName(error, requestName) {
          if ((error == null ? void 0 : error.statusCode) < 500) return;
          this.store.dispatch({
            type: "auth/setErrorByRequestName",
            payload: {
              requestName,
              traceId: errorTraceId(error)
            }
          });
        }
      }, {
        key: "initContainers",
        value: function() {
          var _initContainers = _asyncToGenerator(import_regenerator2.default.mark(function _callee4(elements) {
            return import_regenerator2.default.wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  this.adminPortalEl = elements.adminPortalEl;
                  this.loginBoxEl = elements.loginBoxEl;
                  this.checkoutDialogEl = elements.checkoutDialogEl;
                  this.adminPortalContainer = elements.adminPortalContainer;
                  this.loginBoxContainer = elements.loginBoxContainer;
                  this.checkoutDialogContainer = elements.checkoutDialogContainer;
                  try {
                    if (this.options.framework !== "nextjs") {
                      document.body.classList.add("frontegg-loading");
                    }
                  } catch (e) {
                    console.error("Failed to add frontegg-loading to body classList");
                  }
                  _context4.next = 9;
                  return Promise.all([this.loadFeatureFlags(), this.loadAdminBoxMetadata(), this.requestAuthorize()]);
                case 9:
                  if (!this.options.previewMode && !this.options.customLoginBox) {
                    this.loadLoginBox();
                    loadGTM(this.name);
                  }
                  if (!this.options.lazyLoadAdminPortal) {
                    this.loadScript("FronteggAdminPortal");
                  }
                case 11:
                case "end":
                  return _context4.stop();
              }
            }, _callee4, this);
          }));
          function initContainers(_x) {
            return _initContainers.apply(this, arguments);
          }
          return initContainers;
        }()
      }, {
        key: "updateMetadata",
        value: function updateMetadata(metadata) {
          Metadata.set(metadata, this.name);
          if (metadata != null && metadata.localizations) {
            var _this$updateLocalizat;
            (_this$updateLocalizat = this.updateLocalizations) == null ? void 0 : _this$updateLocalizat.call(this, metadata.localizations);
          }
        }
      }, {
        key: "addOnLoadedListener",
        value: function addOnLoadedListener(listener) {
          if (!this.loading) {
            listener();
            return;
          }
          this.loadingListeners.push(listener);
        }
      }, {
        key: "ready",
        value: function ready(listener) {
          if (this.loading) {
            listener();
          } else {
            this.addOnLoadedListener(listener);
          }
        }
      }, {
        key: "loginWithRedirect",
        value: function loginWithRedirect() {
          var additionalParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.store.dispatch({
            type: "auth/setState",
            payload: {
              isLoading: true
            }
          });
          this.store.dispatch({
            type: "auth/requestHostedLoginAuthorize",
            payload: additionalParams
          });
        }
      }, {
        key: "loginWithRedirectV2",
        value: function loginWithRedirectV2(payload) {
          this.store.dispatch({
            type: "auth/requestHostedLoginAuthorizeV2",
            payload
          });
        }
      }, {
        key: "logout",
        value: function logout(callback) {
          this.store.dispatch({
            type: "auth/setState",
            payload: {
              isLoading: true
            }
          });
          this.store.dispatch({
            type: "auth/logout",
            payload: callback
          });
        }
      }, {
        key: "loadScript",
        value: function loadScript(component) {
          var _this2 = this;
          return new Promise(function(resolve, reject) {
            var scriptHolder = window;
            if (scriptHolder[component]) {
              resolve(scriptHolder[component]);
              return;
            }
            var entries = {
              FronteggLoginBox: "login-box/index.js",
              FronteggAdminPortal: "admin-portal/index.js"
            };
            var script = document.createElement("script");
            script.src = "".concat(_this2.cdnUrl, "/").concat(entries[component]);
            script.setAttribute("id", "".concat(component, "Script"));
            script.setAttribute("cdn-url", _this2.cdnUrl);
            script.onload = function() {
              if (scriptHolder["".concat(component, "Init")]) {
                resolve(scriptHolder["".concat(component, "Init")]({
                  FronteggRestApi: rest_api_exports,
                  FronteggTypes: types_exports,
                  FronteggReduxStore: redux_store_exports
                }));
              } else {
                resolve(scriptHolder[component]);
              }
            };
            script.onerror = function(e) {
              console.log("Profile page error", e);
              reject(e);
            };
            document.body.append(script);
          });
        }
      }, {
        key: "loadLoginBox",
        value: function() {
          var _loadLoginBox = _asyncToGenerator(import_regenerator2.default.mark(function _callee5() {
            var FronteggLoginBox;
            return import_regenerator2.default.wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return this.loadScript("FronteggLoginBox");
                case 2:
                  FronteggLoginBox = _context5.sent;
                  FronteggLoginBox.render(this.loginBoxEl, {
                    injector: this,
                    options: this.options
                  });
                  this.loading = false;
                  this.loadingListeners.forEach(function(listener) {
                    try {
                      listener();
                    } catch (e) {
                      console.error("Failed to call loadLoginBoxListener", e);
                    }
                  });
                  this.loadingListeners = [];
                case 7:
                case "end":
                  return _context5.stop();
              }
            }, _callee5, this);
          }));
          function loadLoginBox() {
            return _loadLoginBox.apply(this, arguments);
          }
          return loadLoginBox;
        }()
      }, {
        key: "showAdminPortal",
        value: function() {
          var _showAdminPortal = _asyncToGenerator(import_regenerator2.default.mark(function _callee6(options) {
            var _ref4, isMultiApp, _this$queryFeatureFla, _this$queryFeatureFla2, multiAppsFlag, FronteggAdminPortal;
            return import_regenerator2.default.wrap(function _callee6$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  _ref4 = options != null ? options : {
                    isMultiApp: false
                  }, isMultiApp = _ref4.isMultiApp;
                  _this$queryFeatureFla = this.queryFeatureFlags(["multi-apps-admin-portal"]), _this$queryFeatureFla2 = _slicedToArray(_this$queryFeatureFla, 1), multiAppsFlag = _this$queryFeatureFla2[0];
                  ContextHolder["for"](this.name).setRequestSource(RequestSource.AdminPortal);
                  _context6.next = 5;
                  return this.loadScript("FronteggAdminPortal");
                case 5:
                  FronteggAdminPortal = _context6.sent;
                  this.adminPortalRenderer = FronteggAdminPortal.render(this.adminPortalEl, {
                    injector: this,
                    options: Object.assign({
                      isMultiApp: multiAppsFlag && isMultiApp
                    }, this.options)
                  });
                case 7:
                case "end":
                  return _context6.stop();
              }
            }, _callee6, this);
          }));
          function showAdminPortal(_x2) {
            return _showAdminPortal.apply(this, arguments);
          }
          return showAdminPortal;
        }()
        /**
         * Open the hosted portal must be called synchronously with user interaction
         *
         * @param newTab - open the portal in a new tab = true
         */
      }, {
        key: "openHostedAdminPortal",
        value: function openHostedAdminPortal() {
          var newTab = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          var baseUrl = this.options.contextOptions.baseUrl;
          var hostedPortalUrl = "".concat(baseUrl, "/oauth/portal");
          if (newTab) {
            window.open(hostedPortalUrl, "_blank");
            return;
          }
          window.location.href = hostedPortalUrl;
        }
      }, {
        key: "hideAdminPortal",
        value: function hideAdminPortal() {
          try {
            var _this$adminPortalRend;
            var searchParams = new URLSearchParams(window.location.search);
            (_this$adminPortalRend = this.adminPortalRenderer) == null ? void 0 : _this$adminPortalRend.unmount();
            restoreSearchParams(searchParams);
            ContextHolder["for"](this.name).setRequestSource(null);
          } catch (e) {
            console.error("Failed to unmount admin portal", e);
          }
        }
      }, {
        key: "showCheckoutDialog",
        value: function() {
          var _showCheckoutDialog = _asyncToGenerator(import_regenerator2.default.mark(function _callee7(opts) {
            var FronteggAdminPortal;
            return import_regenerator2.default.wrap(function _callee7$(_context7) {
              while (1) switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return this.loadScript("FronteggAdminPortal");
                case 2:
                  FronteggAdminPortal = _context7.sent;
                  this.checkoutDialogRenderer = FronteggAdminPortal.renderCheckoutDialog(this.checkoutDialogEl, Object.assign({
                    injector: this
                  }, opts, {
                    options: this.options
                  }));
                case 4:
                case "end":
                  return _context7.stop();
              }
            }, _callee7, this);
          }));
          function showCheckoutDialog(_x3) {
            return _showCheckoutDialog.apply(this, arguments);
          }
          return showCheckoutDialog;
        }()
      }, {
        key: "hideCheckoutDialog",
        value: function hideCheckoutDialog() {
          try {
            var _this$checkoutDialogR;
            (_this$checkoutDialogR = this.checkoutDialogRenderer) == null ? void 0 : _this$checkoutDialogR.unmount();
          } catch (e) {
            console.error("Failed to unmount checkout dialog", e);
          }
        }
        /**
         * @returns entitlements store data
         */
      }, {
        key: "getFeatureEntitlements",
        value: (
          /**
            @param key feature key
            @param customAttributes user attributes
            @returns if the user is entitled to the given feature. Attaching the justification if not
            @throws when entitlement is not enabled via frontegg options
          */
          function getFeatureEntitlements2(key, customAttributes) {
            var _this$getEntitlements = this.getEntitlementsQueryData(customAttributes), entitlements = _this$getEntitlements.entitlements, attributes = _this$getEntitlements.attributes;
            return getFeatureEntitlements(entitlements, key, attributes);
          }
        )
        /**
          @param key permission key
          @param customAttributes user attributes
          @returns if the user is entitled to the given permission. Attaching the justification if not
          @throws when entitlement is not enabled via frontegg options
        */
      }, {
        key: "getPermissionEntitlements",
        value: function getPermissionEntitlements2(key, customAttributes) {
          var _this$getEntitlements2 = this.getEntitlementsQueryData(customAttributes), entitlements = _this$getEntitlements2.entitlements, attributes = _this$getEntitlements2.attributes;
          return getPermissionEntitlements(entitlements, key, attributes);
        }
        /**
          @param options - including permission or feature key
          @param customAttributes user attributes
          @returns if the user is entitled to the given permission or feature. Attaching the justification if not
          @throws when entitlement is not enabled via frontegg options
        */
      }, {
        key: "getEntitlements",
        value: function getEntitlements2(options, customAttributes) {
          if ("permissionKey" in options) {
            return this.getPermissionEntitlements(options.permissionKey, customAttributes);
          }
          return this.getFeatureEntitlements(options.featureKey, customAttributes);
        }
        /**
         * Load entitlements
         * @param callback called on request completed with true if succeeded, false if failed
         */
      }, {
        key: "loadEntitlements",
        value: function loadEntitlements(callback) {
          this.store.dispatch({
            type: "auth/loadEntitlements",
            payload: {
              callback
            }
          });
        }
        /**
         * Redirects to the step up page with the max age param and set the redirect url in the local storage
         * @param options.maxAge optional max age
         */
      }, {
        key: "stepUp",
        value: function stepUp(options) {
          var state = this.store.getState();
          var _ref5 = (state == null ? void 0 : state.auth) || {}, hostedLoginBox = _ref5.hostedLoginBox, stepUpUrl = _ref5.routes.stepUpUrl;
          if (hostedLoginBox) {
            this.store.dispatch({
              type: "auth/stepUpHostedLogin",
              payload: options
            });
            return;
          }
          redirectByStepUpUrl(stepUpUrl, state.auth.onRedirectTo, options == null ? void 0 : options.maxAge);
        }
        /**
         * @param options.maxAge optional max age
         * @return true when user is stepped up, false otherwise
         */
      }, {
        key: "isSteppedUp",
        value: function isSteppedUp2() {
          var _this$store$getState;
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _ref6 = ((_this$store$getState = this.store.getState()) == null ? void 0 : _this$store$getState.auth) || {}, user = _ref6.user;
          return isSteppedUp(user, options);
        }
        /**
         * Switch tenant
         * @param payload.tenantId tenant id to switch for
         * @param payload.callback optional callback to be called with true / false for success / failure tenant switching operation
         */
      }, {
        key: "switchTenant",
        value: function switchTenant(payload) {
          this.store.dispatch({
            type: "auth/switchTenant",
            payload
          });
        }
      }, {
        key: "close",
        value: function close() {
          this.hideAdminPortal();
          this.hideCheckoutDialog();
        }
      }]);
      return FronteggApp2;
    }();
  }
});

// node_modules/@frontegg/js/FronteggApp/index.js
var init_FronteggApp2 = __esm({
  "node_modules/@frontegg/js/FronteggApp/index.js"() {
    init_FronteggApp();
    init_utils4();
  }
});

// node_modules/@frontegg/js/HostedLogin/index.js
var HostedLogin;
var init_HostedLogin = __esm({
  "node_modules/@frontegg/js/HostedLogin/index.js"() {
    init_classCallCheck();
    init_createClass();
    init_AppHolder();
    init_rest_api();
    HostedLogin = function() {
      function HostedLogin2() {
        _classCallCheck(this, HostedLogin2);
      }
      _createClass(HostedLogin2, null, [{
        key: "setAuthentication",
        value: function setAuthentication(isAuthenticated, accessToken, user) {
          var appName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "default";
          var app = AppHolder.getInstance(appName);
          var contextHolder = ContextHolder["for"](appName);
          if (isAuthenticated && accessToken) {
            contextHolder.setAccessToken(accessToken);
            contextHolder.setUser(Object.assign({}, user, {
              accessToken
            }));
            app.store.actions.setAuthState({
              isLoading: false,
              isAuthenticated,
              user
            });
            app.store.actions.loadTenants();
          } else {
            contextHolder.setAccessToken(null);
            contextHolder.setUser(null);
            app.store.actions.setAuthState({
              isLoading: false,
              isAuthenticated: false,
              user: null
            });
          }
        }
      }]);
      return HostedLogin2;
    }();
  }
});

// node_modules/@frontegg/js/AdminPortal/index.js
var AdminPortal;
var init_AdminPortal = __esm({
  "node_modules/@frontegg/js/AdminPortal/index.js"() {
    init_classCallCheck();
    init_createClass();
    init_AppHolder();
    AdminPortal = function() {
      function AdminPortal2() {
        _classCallCheck(this, AdminPortal2);
      }
      _createClass(AdminPortal2, null, [{
        key: "show",
        value: function show() {
          var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
          AppHolder.getInstance(name).showAdminPortal();
        }
      }, {
        key: "showMultiApp",
        value: function showMultiApp() {
          var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
          AppHolder.getInstance(name).showAdminPortal({
            isMultiApp: true
          });
        }
        /**
         * Open the hosted portal must be called synchronously with user interaction
         *
         * @param newTab - open the portal in a new tab = true
         * @param name - the app name = 'default'
         */
      }, {
        key: "openHosted",
        value: function openHosted() {
          var newTab = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
          AppHolder.getInstance(name).openHostedAdminPortal(newTab);
        }
      }, {
        key: "hide",
        value: function hide() {
          var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
          AppHolder.getInstance(name).hideAdminPortal();
        }
      }]);
      return AdminPortal2;
    }();
  }
});

// node_modules/@frontegg/js/CheckoutDialog/index.js
var CheckoutDialog;
var init_CheckoutDialog = __esm({
  "node_modules/@frontegg/js/CheckoutDialog/index.js"() {
    init_classCallCheck();
    init_createClass();
    init_AppHolder();
    CheckoutDialog = function() {
      function CheckoutDialog2() {
        _classCallCheck(this, CheckoutDialog2);
      }
      _createClass(CheckoutDialog2, null, [{
        key: "show",
        value: function show(opts) {
          var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
          AppHolder.getInstance(name).showCheckoutDialog(opts);
        }
      }, {
        key: "hide",
        value: function hide() {
          var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
          AppHolder.getInstance(name).hideCheckoutDialog();
        }
      }]);
      return CheckoutDialog2;
    }();
  }
});

// node_modules/@frontegg/js/AdminPortalRenderer/index.js
var import_regenerator3, getThemeAdminByName, AdminPortalRenderer;
var init_AdminPortalRenderer = __esm({
  "node_modules/@frontegg/js/AdminPortalRenderer/index.js"() {
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_regenerator3 = __toESM(require_regenerator());
    init_redux_store();
    init_types();
    init_FronteggApp2();
    init_utils3();
    getThemeAdminByName = function getThemeAdminByName2(name) {
      var _name;
      var adminPortalThemes = window["FronteggAdminPortal"].adminPortalStaticThemesDefaults;
      return (_name = adminPortalThemes[name]) != null ? _name : void 0;
    };
    AdminPortalRenderer = function() {
      function AdminPortalRenderer2(name, themeOptions, store, appOptions) {
        var allowMultipleRenderers = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
        _classCallCheck(this, AdminPortalRenderer2);
        this.app = void 0;
        this.options = void 0;
        this.store = void 0;
        this.setRoute = function() {
        };
        this.themeSetter = void 0;
        this.themeOptions = {};
        var contextOptions = {
          baseUrl: "preview"
        };
        if (store) {
          this.store = store;
          if (!allowMultipleRenderers && store.getState().root.appName !== name) {
            throw Error("Mismatch in store names");
          }
        } else {
          this.store = createFronteggStore({
            context: contextOptions,
            appName: name
          }, this, true, void 0, void 0, true);
        }
        this.options = Object.assign({
          themeOptions,
          iframeRendering: true,
          metadata: {},
          previewMode: true,
          builderMode: true,
          store: this.store,
          contextOptions
        }, appOptions);
        this.app = new FronteggApp(this.options, name, true);
        Metadata.set({}, name);
      }
      _createClass(AdminPortalRenderer2, [{
        key: "render",
        value: function() {
          var _render = _asyncToGenerator(import_regenerator3.default.mark(function _callee(adminPortalContainer) {
            var _this = this;
            var adminPortalEl, setThemeSetter, setStaticRouteSetter, FronteggAdminPortal;
            return import_regenerator3.default.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  adminPortalEl = adminPortalContainer.querySelector("#root");
                  if (!adminPortalEl) {
                    adminPortalEl = adminPortalContainer.ownerDocument.createElement("div");
                    adminPortalEl.setAttribute("id", "root");
                    adminPortalContainer.appendChild(adminPortalEl);
                  }
                  this.app.adminPortalContainer = adminPortalContainer;
                  this.app.adminPortalEl = adminPortalEl;
                  setThemeSetter = function setThemeSetter2(themeSetter) {
                    _this.themeSetter = themeSetter;
                  };
                  setStaticRouteSetter = function setStaticRouteSetter2(setStaticRoute) {
                    _this.setRoute = setStaticRoute;
                  };
                  _context.next = 8;
                  return this.app.loadScript("FronteggAdminPortal");
                case 8:
                  FronteggAdminPortal = _context.sent;
                  this.app.adminPortalRenderer = FronteggAdminPortal.renderPage(adminPortalEl, {
                    options: this.options,
                    injector: this.app,
                    setThemeSetter,
                    setStaticRouteSetter
                  });
                  this.app.loading = false;
                  _context.next = 13;
                  return waitThemeSetter(this);
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function render(_x) {
            return _render.apply(this, arguments);
          }
          return render;
        }()
      }, {
        key: "setStaticRoute",
        value: function setStaticRoute(staticRoute) {
          var _this$setRoute;
          (_this$setRoute = this.setRoute) == null ? void 0 : _this$setRoute.call(this, staticRoute);
        }
      }, {
        key: "unmount",
        value: function unmount() {
          try {
            var _this$app$adminPortal;
            (_this$app$adminPortal = this.app.adminPortalRenderer) == null ? void 0 : _this$app$adminPortal.unmount();
          } catch (e) {
            console.error("Failed to unmount admin Portal renderer", e);
          }
        }
      }, {
        key: "setTheme",
        value: function setTheme(themeOptions) {
          var _this$themeSetter;
          this.themeOptions = themeOptions;
          if (!this.themeSetter) {
            console.warn("this.themeSetter is not defined yet");
          }
          (_this$themeSetter = this.themeSetter) == null ? void 0 : _this$themeSetter.call(this, this.themeOptions);
        }
      }]);
      return AdminPortalRenderer2;
    }();
  }
});

// node_modules/@frontegg/js/LoginBoxRenderer/index.js
var import_regenerator4, defaultTheme, getThemeByName, LoginBoxRenderer;
var init_LoginBoxRenderer = __esm({
  "node_modules/@frontegg/js/LoginBoxRenderer/index.js"() {
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_regenerator4 = __toESM(require_regenerator());
    init_redux_store();
    init_types();
    init_FronteggApp2();
    init_utils3();
    defaultTheme = "modern";
    getThemeByName = function getThemeByName2(name) {
      var _name;
      var themes = window["FronteggAdminPortal"].themes;
      return (_name = themes[name]) != null ? _name : themes[defaultTheme];
    };
    LoginBoxRenderer = function() {
      function LoginBoxRenderer2(name, themeOptions, store, appOptions) {
        var allowMultipleRenderers = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
        _classCallCheck(this, LoginBoxRenderer2);
        this.app = void 0;
        this.options = void 0;
        this.store = void 0;
        this.themeSetter = void 0;
        this.setRoute = function() {
        };
        this.themeOptions = {};
        var contextOptions = {
          baseUrl: "preview"
        };
        if (store) {
          this.store = store;
          if (!allowMultipleRenderers && store.getState().root.appName !== name) {
            throw Error("Mismatch in store names");
          }
        } else {
          this.store = createFronteggStore({
            context: contextOptions,
            appName: name
          }, this, true, void 0, void 0, true);
        }
        this.options = Object.assign({
          themeOptions,
          iframeRendering: true,
          metadata: {},
          previewMode: true,
          builderMode: true,
          store: this.store,
          contextOptions,
          onRedirectTo: function onRedirectTo() {
            console.debug("path");
          }
        }, appOptions);
        this.app = new FronteggApp(this.options, name, true, allowMultipleRenderers);
        Metadata.set({}, name);
      }
      _createClass(LoginBoxRenderer2, [{
        key: "render",
        value: function() {
          var _render = _asyncToGenerator(import_regenerator4.default.mark(function _callee(loginBoxContainer) {
            var _this = this;
            var loginBoxEl, setThemeSetter, setStaticRouteSetter, FronteggLoginBox;
            return import_regenerator4.default.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  loginBoxEl = loginBoxContainer.querySelector("#root");
                  if (!loginBoxEl) {
                    loginBoxEl = loginBoxContainer.ownerDocument.createElement("div");
                    loginBoxEl.setAttribute("id", "root");
                    loginBoxContainer.appendChild(loginBoxEl);
                  }
                  this.app.loginBoxContainer = loginBoxContainer;
                  this.app.loginBoxEl = loginBoxEl;
                  setThemeSetter = function setThemeSetter2(themeSetter) {
                    _this.themeSetter = themeSetter;
                  };
                  setStaticRouteSetter = function setStaticRouteSetter2(setStaticRoute) {
                    _this.setRoute = setStaticRoute;
                  };
                  _context.next = 8;
                  return this.app.loadScript("FronteggLoginBox");
                case 8:
                  FronteggLoginBox = _context.sent;
                  this.app.loginBoxRenderer = FronteggLoginBox.renderPage(loginBoxEl, {
                    options: this.options,
                    injector: this.app,
                    setThemeSetter,
                    setStaticRouteSetter,
                    staticRoute: "/account/login"
                  });
                  _context.next = 12;
                  return waitThemeSetter(this);
                case 12:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function render(_x) {
            return _render.apply(this, arguments);
          }
          return render;
        }()
      }, {
        key: "unmount",
        value: function unmount() {
          try {
            var _this$app$loginBoxRen;
            (_this$app$loginBoxRen = this.app.loginBoxRenderer) == null ? void 0 : _this$app$loginBoxRen.unmount();
          } catch (e) {
            console.error("Failed to unmount login box renderer", e);
          }
        }
      }, {
        key: "setTheme",
        value: function setTheme(themeOptions) {
          var _this$themeSetter;
          this.themeOptions = themeOptions;
          if (!this.themeSetter) {
            console.warn("this.themeSetter is not defined yet");
          }
          (_this$themeSetter = this.themeSetter) == null ? void 0 : _this$themeSetter.call(this, this.themeOptions);
        }
      }, {
        key: "setStaticRoute",
        value: function setStaticRoute(staticRoute) {
          var _this$setRoute;
          if (!this.setRoute) {
            console.warn("this.setRoute is not defined yet");
          }
          (_this$setRoute = this.setRoute) == null ? void 0 : _this$setRoute.call(this, staticRoute);
        }
      }, {
        key: "setStore",
        value: function setStore(state) {
          this.store.dispatch({
            type: "auth/setState",
            payload: state
          });
        }
      }]);
      return LoginBoxRenderer2;
    }();
  }
});

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
var init_setPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
var init_inherits = __esm({
  "node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
var init_assertThisInitialized = __esm({
  "node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
var init_getPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
var init_isNativeFunction = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct3() {
    return !!t;
  })();
}
var init_isNativeReflectConstruct = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}
var init_construct = __esm({
  "node_modules/@babel/runtime/helpers/esm/construct.js"() {
    init_isNativeReflectConstruct();
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
    if (null === t2 || !_isNativeFunction(t2)) return t2;
    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t2)) return r.get(t2);
      r.set(t2, Wrapper);
    }
    function Wrapper() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t2);
  }, _wrapNativeSuper(t);
}
var init_wrapNativeSuper = __esm({
  "node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js"() {
    init_getPrototypeOf();
    init_setPrototypeOf();
    init_isNativeFunction();
    init_construct();
  }
});

// node_modules/@frontegg/js/initialize.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var initialize;
var init_initialize = __esm({
  "node_modules/@frontegg/js/initialize.js"() {
    init_classCallCheck();
    init_createClass();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_wrapNativeSuper();
    init_FronteggApp2();
    init_AppHolder();
    init_utils3();
    initialize = function initialize2(options) {
      var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
      var createdApp = new FronteggApp(options, name);
      if (typeof document !== "undefined") {
        var _document$querySelect;
        if (!options.contextOptions.baseUrl) {
          var error = new Error('Edit <FronteggProvider/> options { ContextOptions: { baseUrl: "" } } in order to connect your application');
          document.body.innerHTML = "";
          alert(error.message);
          throw error;
        }
        if (!customElements.get("frontegg-app")) {
          var FronteggAppContainer = function(_HTMLElement) {
            _inherits(FronteggAppContainer2, _HTMLElement);
            var _super = _createSuper(FronteggAppContainer2);
            function FronteggAppContainer2() {
              var _this;
              _classCallCheck(this, FronteggAppContainer2);
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              _this = _super.call.apply(_super, [this].concat(args));
              _this.app = null;
              return _this;
            }
            _createClass(FronteggAppContainer2, [{
              key: "connectedCallback",
              value: function connectedCallback() {
                this.updateContent();
              }
            }, {
              key: "attributeChangedCallback",
              value: function attributeChangedCallback(name2, oldValue, newValue) {
                if (name2 === "app-name") {
                  if (oldValue === null) {
                    return;
                  }
                  if (oldValue === newValue) {
                    return;
                  }
                  this.innerHTML = "";
                  if (newValue === null) {
                    this.remove();
                  } else {
                    this.updateContent();
                  }
                }
                console.debug("attributeChangedCallback", name2, oldValue, newValue);
              }
            }, {
              key: "updateContent",
              value: function updateContent() {
                var _this$getAttribute;
                var appName = (_this$getAttribute = this.getAttribute("app-name")) != null ? _this$getAttribute : "default";
                var app = AppHolder.getInstance(appName);
                if (app === null) {
                  throw Error("FronteggApp not found for appName: '".concat(appName, "'"));
                }
                this.setAttribute("id", "frontegg-app-".concat(app.name));
                var adminPortalContainer = createElement(this, "div", {
                  id: "frontegg-admin-portal-container-".concat(app.name)
                });
                var loginBoxContainer = createElement(this, "div", {
                  id: "frontegg-login-box-container-".concat(app.name)
                });
                var checkoutDialogContainer = createElement(this, "div", {
                  id: "frontegg-checkout-dialog-container-".concat(app.name)
                });
                var adminBoxShadowEl = adminPortalContainer.attachShadow({
                  mode: "open"
                });
                var loginBoxShadowEl = loginBoxContainer.attachShadow({
                  mode: "open"
                });
                var checkoutDialogShadowEl = checkoutDialogContainer.attachShadow({
                  mode: "open"
                });
                var adminPortalEl = createElement(adminBoxShadowEl, "div", {
                  id: "frontegg-admin-portal-".concat(app.name),
                  "class": "frontegg-root-content"
                });
                var loginBoxEl = createElement(loginBoxShadowEl, "div", {
                  id: "frontegg-login-box-".concat(app.name),
                  "class": "frontegg-root-content"
                });
                var checkoutDialogEl = createElement(checkoutDialogShadowEl, "div", {
                  id: "frontegg-checkout-dialog-".concat(app.name),
                  "class": "frontegg-root-content"
                });
                app.initContainers({
                  adminPortalEl,
                  loginBoxEl,
                  adminPortalContainer,
                  loginBoxContainer,
                  checkoutDialogContainer,
                  checkoutDialogEl
                });
              }
            }], [{
              key: "observedAttributes",
              get: function get() {
                return ["app-name"];
              }
            }]);
            return FronteggAppContainer2;
          }(_wrapNativeSuper(HTMLElement));
          customElements.define("frontegg-app", FronteggAppContainer);
        }
        (_document$querySelect = document.querySelector('frontegg-app[app-name="'.concat(createdApp.name, '"]'))) == null ? void 0 : _document$querySelect.remove();
        var element = document.createElement("frontegg-app");
        element.setAttribute("app-name", createdApp.name);
        document.body.appendChild(element);
      }
      return createdApp;
    };
  }
});

// node_modules/@frontegg/js/index.js
var js_exports = {};
__export(js_exports, {
  AdminPortal: () => AdminPortal,
  AdminPortalRenderer: () => AdminPortalRenderer,
  AppHolder: () => AppHolder,
  CheckoutDialog: () => CheckoutDialog,
  FronteggApp: () => FronteggApp,
  HostedLogin: () => HostedLogin,
  LoginBoxRenderer: () => LoginBoxRenderer,
  createElement: () => createElement,
  defaultTheme: () => defaultTheme,
  formatName: () => formatName,
  getOverriddenMetadata: () => getOverriddenMetadata,
  getThemeAdminByName: () => getThemeAdminByName,
  getThemeByName: () => getThemeByName,
  initialize: () => initialize,
  mockFlagsList: () => mockFlagsList,
  restoreSearchParams: () => restoreSearchParams,
  waitThemeSetter: () => waitThemeSetter
});
var init_js = __esm({
  "node_modules/@frontegg/js/index.js"() {
    init_AppHolder();
    init_FronteggApp2();
    init_HostedLogin();
    init_AdminPortal();
    init_CheckoutDialog();
    init_AdminPortalRenderer();
    init_LoginBoxRenderer();
    init_initialize();
    init_utils3();
    init_mockFlagsList();
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    (function() {
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                validateChildKeys(children[isStaticChildren]);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
          children = getComponentNameFromType(type);
          var keys = Object.keys(config).filter(function(k) {
            return "key" !== k;
          });
          isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        return ReactElement(
          type,
          children,
          self,
          source,
          getOwner(),
          maybeKey,
          debugStack,
          debugTask
        );
      }
      function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
      }
      var React5 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React5.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      React5 = {
        "react-stack-bottom-frame": function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = React5["react-stack-bottom-frame"].bind(
        React5,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutKeySpread = {};
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = function(type, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          false,
          source,
          self,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports.jsxs = function(type, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          true,
          source,
          self,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
    })();
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/@frontegg/react-hooks/FronteggStoreContext/FronteggStoreContext.js
var import_react, import_jsx_runtime, FronteggStoreContext, useStore, Provider;
var init_FronteggStoreContext = __esm({
  "node_modules/@frontegg/react-hooks/FronteggStoreContext/FronteggStoreContext.js"() {
    import_react = __toESM(require_react());
    import_jsx_runtime = __toESM(require_jsx_runtime());
    FronteggStoreContext = (0, import_react.createContext)(null);
    if (true) {
      FronteggStoreContext.displayName = "FronteggStoreContext";
    }
    useStore = () => (0, import_react.useContext)(FronteggStoreContext);
    Provider = (props) => {
      return (0, import_jsx_runtime.jsx)(FronteggStoreContext.Provider, {
        value: props.store,
        children: props.children
      });
    };
  }
});

// node_modules/@frontegg/react-hooks/FronteggStoreContext/index.js
var init_FronteggStoreContext2 = __esm({
  "node_modules/@frontegg/react-hooks/FronteggStoreContext/index.js"() {
    init_FronteggStoreContext();
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function useSyncExternalStore$2(subscribe2, getSnapshot) {
        didWarnOld18Alpha || void 0 === React5.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState3({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe2, value, getSnapshot]
        );
        useEffect7(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe2]
        );
        useDebugValue2(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React5 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState3 = React5.useState, useEffect7 = React5.useEffect, useLayoutEffect = React5.useLayoutEffect, useDebugValue2 = React5.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React5.useSyncExternalStore ? React5.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@frontegg/react-hooks/useSnapshot/index.js
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const lastSnapshot = (0, import_react2.useRef)();
  const lastAffected = (0, import_react2.useRef)();
  let inRender = true;
  const currSnapshot = useSyncExternalStore((0, import_react2.useCallback)((callback) => {
    const unsub = subscribe(proxyObject, callback, notifyInSync);
    callback();
    return unsub;
  }, [proxyObject, notifyInSync]), () => {
    const nextSnapshot = snapshot(proxyObject, import_react2.default.use);
    try {
      if (!inRender && lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
        return lastSnapshot.current;
      }
    } catch (e) {
    }
    return nextSnapshot;
  }, () => snapshot(proxyObject, import_react2.default.use));
  inRender = false;
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react2.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = (0, import_react2.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, currAffected, proxyCache, targetCache);
}
var import_react2, import_shim, useSyncExternalStore, targetCache;
var init_useSnapshot = __esm({
  "node_modules/@frontegg/react-hooks/useSnapshot/index.js"() {
    import_react2 = __toESM(require_react());
    init_dist();
    import_shim = __toESM(require_shim());
    init_redux_store();
    ({
      useSyncExternalStore
    } = import_shim.default);
    targetCache = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@frontegg/react-hooks/common/CustomComponentHolder.js
var import_react3, import_react_dom, import_react_is, import_jsx_runtime2, import_jsx_runtime3, CustomComponentHolder, overrideValue, Registerer, CustomComponentRegister;
var init_CustomComponentHolder = __esm({
  "node_modules/@frontegg/react-hooks/common/CustomComponentHolder.js"() {
    import_react3 = __toESM(require_react());
    import_react_dom = __toESM(require_react_dom());
    import_react_is = __toESM(require_react_is());
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    CustomComponentHolder = class _CustomComponentHolder {
      static set(name, element) {
        _CustomComponentHolder.components[name] = element;
      }
      static get(name) {
        return _CustomComponentHolder.components[name];
      }
    };
    CustomComponentHolder.components = {};
    overrideValue = (object, key, value) => {
      const keys = key.split(".");
      let iterator = object;
      while (keys.length > 1) {
        iterator = iterator[keys.shift()];
      }
      iterator[keys.shift()] = value;
    };
    Registerer = (props) => {
      var _app$loginBoxContaine;
      const {
        app,
        themeKey
      } = props;
      const value = CustomComponentHolder.get(themeKey);
      const [mounted, setMounted] = (0, import_react3.useState)(false);
      const [componentProps, setComponentProps] = (0, import_react3.useState)({});
      const mount = (0, import_react3.useCallback)((props2 = {}) => {
        setMounted(true);
        setComponentProps(props2);
      }, []);
      const unmount = (0, import_react3.useCallback)(() => {
        setMounted(false);
      }, []);
      overrideValue(app.options.themeOptions, themeKey, {
        type: "slot",
        themeKey,
        mount,
        unmount
      });
      let element = (_app$loginBoxContaine = app.loginBoxContainer) == null ? void 0 : _app$loginBoxContaine.querySelector(`[slot="${themeKey}"]`);
      if (!element && typeof document !== void 0) {
        var _app$loginBoxContaine2;
        element = document.createElement("div");
        element.slot = themeKey;
        (_app$loginBoxContaine2 = app.loginBoxContainer) == null ? void 0 : _app$loginBoxContaine2.appendChild(element);
      }
      const component = value ? import_react3.default.createElement(value, componentProps) : null;
      return element && mounted ? (0, import_jsx_runtime2.jsx)(import_react3.default.Fragment, {
        children: import_react_dom.default.createPortal(component, element)
      }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime3.Fragment, {});
    };
    CustomComponentRegister = ({
      app,
      themeOptions
    }) => {
      const keys = (0, import_react3.useMemo)(() => {
        if (!themeOptions || !themeOptions.loginBox) {
          return [];
        }
        const loop = (key, obj, keyPath) => {
          if (key === "overrideSignupFields") {
            return [];
          }
          if (typeof obj !== "object" && typeof obj !== "function") {
            return [];
          }
          if (typeof obj === "function" && key) {
            try {
              const reactElement = import_react3.default.createElement(obj, {
                title: "title"
              });
              if ((0, import_react3.isValidElement)(reactElement) || (0, import_react_is.isElement)(reactElement)) {
                const generatedKey = `${keyPath}.${key}`;
                CustomComponentHolder.set(generatedKey, obj);
                return [generatedKey];
              }
            } catch (e) {
            }
          }
          if ((0, import_react3.isValidElement)(obj) || (0, import_react_is.isElement)(obj) || obj === null) {
            const generatedKey = `${keyPath}.${key}`;
            CustomComponentHolder.set(generatedKey, obj);
            return [generatedKey];
          } else {
            const elements = [];
            Object.keys(obj).forEach((k) => {
              elements.push(...loop(k, obj[k], keyPath === "" ? key : `${keyPath}.${key}`));
            });
            return elements;
          }
        };
        return loop("loginBox", themeOptions.loginBox, "");
      }, []);
      return (0, import_jsx_runtime2.jsx)(import_jsx_runtime3.Fragment, {
        children: keys.map((key) => (0, import_jsx_runtime2.jsx)(Registerer, {
          app,
          themeKey: key
        }, key))
      });
    };
  }
});

// node_modules/@frontegg/react-hooks/common/index.js
var import_react4, _excluded86, ShadowDomContext, defaultPathOnRedirectTo, defaultHashOnRedirectTo, useShadowDom, useRootState;
var init_common2 = __esm({
  "node_modules/@frontegg/react-hooks/common/index.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    import_react4 = __toESM(require_react());
    init_FronteggStoreContext2();
    init_useSnapshot();
    init_rest_api();
    init_CustomComponentHolder();
    _excluded86 = ["urlStrategy", "onRedirectTo", "renderByRoute", "customLoader", "customStyles", "contextOptions"];
    ShadowDomContext = (0, import_react4.createContext)({});
    defaultPathOnRedirectTo = (path) => {
      var _window$history, _window$history$pushS;
      return typeof window !== "undefined" && ((_window$history = window.history) == null ? void 0 : (_window$history$pushS = _window$history.pushState) == null ? void 0 : _window$history$pushS.call(_window$history, null, "", path));
    };
    defaultHashOnRedirectTo = (path) => {
      var _window$history2, _window$history2$push;
      return typeof window !== "undefined" && ((_window$history2 = window.history) == null ? void 0 : (_window$history2$push = _window$history2.pushState) == null ? void 0 : _window$history2$push.call(_window$history2, null, "", `#${path}`));
    };
    useShadowDom = () => {
      var _rest$injector$name, _rest$injector;
      const context = (0, import_react4.useContext)(ShadowDomContext);
      const {
        urlStrategy = "path",
        onRedirectTo = urlStrategy === "path" ? defaultPathOnRedirectTo : defaultHashOnRedirectTo,
        renderByRoute = false,
        customLoader = false,
        customStyles,
        contextOptions
      } = context, rest = _objectWithoutPropertiesLoose(context, _excluded86);
      const appName = (_rest$injector$name = (_rest$injector = rest.injector) == null ? void 0 : _rest$injector.name) != null ? _rest$injector$name : "default";
      return _extends({
        isShadowDom: true,
        onRedirectTo,
        renderByRoute,
        customLoader,
        customStyles,
        urlStrategy,
        contextOptions: _extends({
          requestCredentials: "include"
        }, contextOptions)
      }, rest, {
        appName,
        fetchClient: new FetchClient(appName),
        apiClient: createApiClient(appName)
      });
    };
    useRootState = () => {
      return useSnapshot(useStore().store.root);
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/hooks.js
function useAuth(stateMapper = defaultMapper.state) {
  const state = useStore().store.auth;
  return stateMapper(useSnapshot(state));
}
function useAuthState() {
  const state = useStore().store.auth;
  return useSnapshot(state);
}
var import_react5, defaultMapper, useLoginWithRedirect, useLoginWithRedirectV2, useAuthActions, useOnRedirectTo, useAuthRoutes, useIsAuthenticated, useAuthUser, useAuthUserOrNull, useStoreActions;
var init_hooks = __esm({
  "node_modules/@frontegg/react-hooks/auth/hooks.js"() {
    import_react5 = __toESM(require_react());
    init_rest_api();
    init_FronteggStoreContext2();
    init_useSnapshot();
    init_common2();
    defaultMapper = {
      state: (state) => state,
      actions: (actions) => actions
    };
    useLoginWithRedirect = () => {
      const {
        actions
      } = (0, import_react5.useContext)(FronteggStoreContext);
      return actions.requestHostedLoginAuthorize;
    };
    useLoginWithRedirectV2 = () => {
      const {
        actions
      } = (0, import_react5.useContext)(FronteggStoreContext);
      return actions.requestHostedLoginAuthorizeV2;
    };
    useAuthActions = () => {
      return useStore().actions;
    };
    useOnRedirectTo = () => {
      const {
        onRedirectTo
      } = useAuth();
      const {
        appName
      } = useRootState();
      return onRedirectTo || ContextHolder.for(appName).onRedirectTo;
    };
    useAuthRoutes = () => useAuthState().routes;
    useIsAuthenticated = () => {
      const {
        isAuthenticated
      } = useSnapshot(useStore().store.auth);
      return isAuthenticated;
    };
    useAuthUser = () => {
      const authRoutes = useAuthRoutes();
      const onRedirectTo = useOnRedirectTo();
      const loginWithRedirect = useLoginWithRedirectV2();
      const {
        user,
        hostedLoginBox
      } = useAuth();
      const noUser = {};
      const isSSR = typeof window === "undefined";
      (0, import_react5.useEffect)(() => {
        if (user == null && !isSSR) {
          if (hostedLoginBox) {
            loginWithRedirect({
              shouldRedirectToLogin: true
            });
          } else {
            const {
              loginUrl,
              customLoginUrl
            } = authRoutes;
            onRedirectTo(customLoginUrl != null ? customLoginUrl : loginUrl, {
              refresh: true
            });
          }
        }
      }, [hostedLoginBox, user, authRoutes, onRedirectTo, loginWithRedirect]);
      if (user == null && !isSSR) {
        return noUser;
      }
      return user || noUser;
    };
    useAuthUserOrNull = () => {
      const {
        user
      } = useAuth();
      return user || null;
    };
    useStoreActions = () => {
      const store = useStore();
      return store.actions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/acceptInvitation.js
function useAcceptInvitationState(stateMapper = defaultMapper2) {
  const state = useStore().store.auth.acceptInvitationState;
  return stateMapper(useSnapshot(state));
}
var defaultMapper2, useAcceptInvitationActions;
var init_acceptInvitation2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/acceptInvitation.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    defaultMapper2 = (state) => state;
    useAcceptInvitationActions = () => {
      return useStore().stateActions.auth.acceptInvitationActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/unlockAccount.js
function useUnlockAccountState(stateMapper = defaultMapper3) {
  const state = useStore().store.auth.unlockAccountState;
  return stateMapper(useSnapshot(state));
}
var defaultMapper3, useUnlockAccountActions;
var init_unlockAccount2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/unlockAccount.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    defaultMapper3 = (state) => state;
    useUnlockAccountActions = () => {
      return useStore().stateActions.auth.unlockAccountActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/activateAccount.js
function useActivateAccountState(stateMapper = defaultMapper4) {
  const state = useStore().store.auth.activateAccountState;
  return stateMapper(useSnapshot(state));
}
var defaultMapper4, useActivateAccountActions;
var init_activateAccount2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/activateAccount.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    defaultMapper4 = (state) => state;
    useActivateAccountActions = () => {
      return useStore().stateActions.auth.activateAccountActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/allAccounts.js
function useAllAccountsState(stateMapper = defaultMapper5) {
  const state = useStore().store.auth.allAccountsState;
  return stateMapper(useSnapshot(state));
}
function useAllAccountsDialogsState() {
  const state = useStore().store.auth.allAccountsDialogsState;
  return useSnapshot(state);
}
var defaultMapper5, useAllAccountsActions, useAllAccountsDialogsActions;
var init_allAccounts2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/allAccounts.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    defaultMapper5 = (state) => state;
    useAllAccountsActions = () => {
      return useStore().stateActions.auth.allAccountsActions;
    };
    useAllAccountsDialogsActions = () => {
      return useStore().stateActions.auth.allAccountsDialogActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/apiTokens.js
function useApiTokensState() {
  const state = useStore().store.auth.apiTokensState;
  return useSnapshot(state);
}
var useApiTokensActions;
var init_apiTokens2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/apiTokens.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useApiTokensActions = () => {
      return useStore().stateActions.auth.apiTokensActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/customLogin.js
function useCustomLoginState() {
  const state = useStore().store.auth.customLoginState;
  return useSnapshot(state);
}
var import_react6, import_get_value2, useCustomLoginActions, useCustomLoginTheme;
var init_customLogin = __esm({
  "node_modules/@frontegg/react-hooks/auth/customLogin.js"() {
    import_react6 = __toESM(require_react());
    import_get_value2 = __toESM(require_get_value());
    init_FronteggStoreContext2();
    init_useSnapshot();
    useCustomLoginActions = () => {
      return useStore().stateActions.auth.customLoginActions;
    };
    useCustomLoginTheme = () => {
      var _useCustomLoginState$, _useCustomLoginState$2, _useCustomLoginState$3;
      const customLoginTheme = (_useCustomLoginState$ = useCustomLoginState().tenantMetadata) == null ? void 0 : (_useCustomLoginState$2 = _useCustomLoginState$.configuration) == null ? void 0 : (_useCustomLoginState$3 = _useCustomLoginState$2.themeV2) == null ? void 0 : _useCustomLoginState$3.loginBox;
      const getCustomLoginThemeValue = (0, import_react6.useCallback)((path) => {
        return path && customLoginTheme ? (0, import_get_value2.default)(customLoginTheme, path) : customLoginTheme;
      }, [customLoginTheme]);
      return {
        customLoginTheme,
        getCustomLoginThemeValue
      };
    };
  }
});

// node_modules/@frontegg/react-hooks/flags/useFeatureFlags.js
var useFeatureFlags, useFeatureFlagsChecker;
var init_useFeatureFlags = __esm({
  "node_modules/@frontegg/react-hooks/flags/useFeatureFlags.js"() {
    init_rest_api();
    init_common2();
    useFeatureFlags = (flags) => {
      const {
        injector
      } = useShadowDom();
      return FeatureFlags.getFeatureFlags(flags, injector.name);
    };
    useFeatureFlagsChecker = () => {
      const {
        injector
      } = useShadowDom();
      return (flags) => {
        return FeatureFlags.getFeatureFlags(flags, injector.name);
      };
    };
  }
});

// node_modules/@frontegg/react-hooks/flags/index.js
var init_flags = __esm({
  "node_modules/@frontegg/react-hooks/flags/index.js"() {
    init_useFeatureFlags();
  }
});

// node_modules/@frontegg/react-hooks/auth/entitlements.js
var import_react7, useEntitlementsState, useUserState, useEntitlementsQueryData, useFeatureEntitlements, usePermissionEntitlements, useEntitlements, useEntitlementsActions, useEntitlementsOptions;
var init_entitlements2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/entitlements.js"() {
    init_hooks();
    import_react7 = __toESM(require_react());
    init_common2();
    init_flags();
    init_FronteggStoreContext2();
    init_useSnapshot();
    init_redux_store();
    useEntitlementsState = () => {
      var _useSnapshot$user$ent, _useSnapshot$user;
      const state = useStore().store.auth;
      return (_useSnapshot$user$ent = (_useSnapshot$user = useSnapshot(state).user) == null ? void 0 : _useSnapshot$user.entitlements) != null ? _useSnapshot$user$ent : {};
    };
    useUserState = () => {
      return useAuthUserOrNull() || void 0;
    };
    useEntitlementsQueryData = (customAttributes) => {
      const user = useUserState();
      const entitlements = useEntitlementsState();
      const attributes = {
        custom: customAttributes,
        jwt: user
      };
      return {
        entitlements,
        attributes
      };
    };
    useFeatureEntitlements = (key, customAttributes) => {
      const {
        entitlements,
        attributes
      } = useEntitlementsQueryData(customAttributes);
      const {
        appName
      } = useRootState();
      return getFeatureEntitlements(entitlements, key, attributes, void 0, appName);
    };
    usePermissionEntitlements = (key, customAttributes) => {
      const {
        entitlements,
        attributes
      } = useEntitlementsQueryData(customAttributes);
      const {
        appName
      } = useRootState();
      return getPermissionEntitlements(entitlements, key, attributes, void 0, appName);
    };
    useEntitlements = (options, customAttributes) => {
      const {
        entitlements,
        attributes
      } = useEntitlementsQueryData(customAttributes);
      const {
        appName
      } = useRootState();
      return getEntitlements(entitlements, options, attributes, void 0, appName);
    };
    useEntitlementsActions = () => {
      const user = useUserState();
      const entitlements = useEntitlementsState();
      const {
        appName
      } = useRootState();
      return (0, import_react7.useMemo)(() => ({
        isEntitledTo: (options, customAttributes) => {
          const attributes = {
            custom: customAttributes,
            jwt: user
          };
          return getEntitlements(entitlements, options, attributes, void 0, appName);
        }
      }), [user, entitlements]);
    };
    useEntitlementsOptions = () => {
      var _entitlementsOptions$;
      const {
        entitlementsOptions
      } = useShadowDom();
      const isEntitlementsEnabled = (_entitlementsOptions$ = entitlementsOptions == null ? void 0 : entitlementsOptions.enabled) != null ? _entitlementsOptions$ : false;
      const {
        isEntitledTo
      } = useEntitlementsActions();
      const [verifyIsEntitledFF] = useFeatureFlags(["admin-portal-use-is-entitled"]);
      return {
        isEntitlementsEnabled,
        isEntitledTo,
        verifyIsEntitledFF
      };
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/forgotPassword.js
function useForgotPasswordState() {
  const state = useStore().store.auth.forgotPasswordState;
  return useSnapshot(state);
}
var useForgotPasswordActions;
var init_forgotPassword = __esm({
  "node_modules/@frontegg/react-hooks/auth/forgotPassword.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useForgotPasswordActions = () => {
      return useStore().stateActions.auth.forgotPasswordActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/passwordRotation.js
function usePasswordRotationState() {
  const state = useStore().store.auth.passwordRotationState;
  return useSnapshot(state);
}
var usePasswordRotationActions;
var init_passwordRotation = __esm({
  "node_modules/@frontegg/react-hooks/auth/passwordRotation.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    usePasswordRotationActions = () => {
      return useStore().stateActions.auth.passwordRotationActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/groups.js
function useGroupsState() {
  return useSnapshot(useStore().store.auth.groupsState);
}
function useGroupsDialogsState() {
  return useSnapshot(useStore().store.auth.groupsDialogsState);
}
var useGroupsActions, useGroupsDialogsActions;
var init_groups3 = __esm({
  "node_modules/@frontegg/react-hooks/auth/groups.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useGroupsActions = () => {
      return useStore().stateActions.auth.groupsActions;
    };
    useGroupsDialogsActions = () => {
      return useStore().stateActions.auth.groupsDialogsActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/impersonate.js
function useImpersonateState() {
  return useSnapshot(useStore().store.auth.impersonateState);
}
var useImpersonateActions;
var init_impersonate3 = __esm({
  "node_modules/@frontegg/react-hooks/auth/impersonate.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    useImpersonateActions = () => {
      return useStore().stateActions.auth.impersonateActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/login.js
function useLoginState() {
  return useSnapshot(useStore().store.auth.loginState);
}
var useLoginActions;
var init_login2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/login.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    useLoginActions = () => {
      return useStore().stateActions.auth.loginActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/mfa.js
function useMfaState(stateMapper = defaultMapper6) {
  const {
    mfaState
  } = useStore().store.auth;
  return stateMapper(useSnapshot(mfaState));
}
var defaultMapper6, useMfaActions;
var init_mfa = __esm({
  "node_modules/@frontegg/react-hooks/auth/mfa.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    defaultMapper6 = (state) => state;
    useMfaActions = () => {
      return useStore().stateActions.auth.mfaActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/passkeys.js
function usePasskeysState() {
  return useSnapshot(useStore().store.auth.passkeysState);
}
var usePasskeysActions;
var init_passkeys = __esm({
  "node_modules/@frontegg/react-hooks/auth/passkeys.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    usePasskeysActions = () => {
      return useStore().stateActions.auth.passkeysActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/profile.js
function useProfileState() {
  return useSnapshot(useStore().store.auth.profileState);
}
var import_react8, useProfileActions, reloadProfileIfNeeded;
var init_profile2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/profile.js"() {
    import_react8 = __toESM(require_react());
    init_useSnapshot();
    init_FronteggStoreContext2();
    useProfileActions = () => {
      return useStore().stateActions.auth.profileActions;
    };
    reloadProfileIfNeeded = () => {
      const {
        loading
      } = useProfileState();
      const {
        loadProfile
      } = useProfileActions();
      (0, import_react8.useEffect)(() => {
        !loading && loadProfile();
      }, []);
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/provisioning.js
function useProvisioningState() {
  return useSnapshot(useStore().store.auth.provisioningState);
}
var useProvisioningActions;
var init_provisioning2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/provisioning.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    useProvisioningActions = () => {
      return useStore().stateActions.auth.provisioningActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/resetPhoneNumber.js
function useResetPhoneNumberState() {
  return useSnapshot(useStore().store.auth.resetPhoneNumberState);
}
var useResetPhoneNumberActions;
var init_resetPhoneNumber2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/resetPhoneNumber.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    useResetPhoneNumberActions = () => {
      return useStore().stateActions.auth.resetPhoneNumberActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/roles.js
function useRolesState() {
  return useSnapshot(useStore().store.auth.rolesState);
}
var useRolesActions;
var init_roles3 = __esm({
  "node_modules/@frontegg/react-hooks/auth/roles.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    useRolesActions = () => {
      return useStore().stateActions.auth.rolesActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/sessions.js
function useSessionsState() {
  return useSnapshot(useStore().store.auth.sessionsState);
}
var useSessionsActions;
var init_sessions = __esm({
  "node_modules/@frontegg/react-hooks/auth/sessions.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    useSessionsActions = () => {
      return useStore().stateActions.auth.sessionsActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/signup.js
function useSignUpState(stateMapper = defaultMapper7) {
  const {
    signUpState
  } = useStore().store.auth;
  return stateMapper(useSnapshot(signUpState));
}
var defaultMapper7, useSignUpActions;
var init_signup2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/signup.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    defaultMapper7 = (state) => state;
    useSignUpActions = () => {
      return useStore().stateActions.auth.signUpActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/sms.js
function useSmsState() {
  return useSnapshot(useStore().store.auth.smsState);
}
var useSmsActions;
var init_sms = __esm({
  "node_modules/@frontegg/react-hooks/auth/sms.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useSmsActions = () => {
      return useStore().stateActions.auth.smsActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/socialLogin.js
function useSocialLoginState(stateMapper = defaultMapper8) {
  return stateMapper(useSnapshot(useStore().store.auth.socialLoginState));
}
var defaultMapper8, useSocialLoginActions;
var init_socialLogin = __esm({
  "node_modules/@frontegg/react-hooks/auth/socialLogin.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    defaultMapper8 = (state) => state;
    useSocialLoginActions = () => {
      return useStore().stateActions.auth.socialLoginActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/sso.js
function useSSOState(stateMapper = defaultMapper9) {
  return stateMapper(useSnapshot(useStore().store.auth.ssoState));
}
var defaultMapper9, useSSOActions;
var init_sso2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/sso.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    defaultMapper9 = (state) => state;
    useSSOActions = () => {
      return useStore().stateActions.auth.ssoActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/stepUp.js
function useStepUpState() {
  return useSnapshot(useStore().store.auth.stepUpState);
}
var import_react9, useStepUpActions, getMaxAgeFromQueryParam, useStepUp, useIsSteppedUp;
var init_stepUp2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/stepUp.js"() {
    init_redux_store();
    init_useSnapshot();
    init_FronteggStoreContext2();
    init_hooks();
    import_react9 = __toESM(require_react());
    useStepUpActions = () => {
      return useStore().stateActions.auth.stepUpActions;
    };
    getMaxAgeFromQueryParam = () => {
      const str = getSearchParam(STEP_UP_MAX_AGE_PARAM_NAME);
      return str === void 0 ? void 0 : +str;
    };
    useStepUp = () => {
      const {
        stepUpUrl
      } = useAuthRoutes();
      const {
        hostedLoginBox
      } = useAuth();
      const {
        stepUpHostedLogin
      } = useStepUpActions();
      const onRedirectTo = useOnRedirectTo();
      return (0, import_react9.useCallback)((options) => {
        if (hostedLoginBox) {
          stepUpHostedLogin(options || {});
          return;
        }
        redirectByStepUpUrl(stepUpUrl, onRedirectTo, options == null ? void 0 : options.maxAge);
      }, [stepUpUrl, onRedirectTo, stepUpHostedLogin, hostedLoginBox]);
    };
    useIsSteppedUp = (options = {}) => {
      const user = useAuthUserOrNull();
      return isSteppedUp(user, options);
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/team.js
function useTeamState() {
  const state = useStore().store.auth.teamState;
  return useSnapshot(state);
}
function useAuthTeamState(stateMapper = defaultMapper10) {
  return stateMapper(useTeamState());
}
var useTeamActions, defaultMapper10, useAuthTeamActions;
var init_team = __esm({
  "node_modules/@frontegg/react-hooks/auth/team.js"() {
    init_useSnapshot();
    init_FronteggStoreContext2();
    useTeamActions = () => {
      return useStore().stateActions.auth.teamActions;
    };
    defaultMapper10 = (state) => state;
    useAuthTeamActions = () => {
      return useTeamActions();
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/security/restrictions.js
function useRestrictionsState() {
  const state = useStore().store.auth.restrictionsState;
  return useSnapshot(state);
}
var import_react10, useRestrictionsActions, useIpRestrictions, useEmailDomainRestrictions;
var init_restrictions = __esm({
  "node_modules/@frontegg/react-hooks/auth/security/restrictions.js"() {
    import_react10 = __toESM(require_react());
    init_FronteggStoreContext2();
    init_useSnapshot();
    useRestrictionsActions = () => {
      return useStore().stateActions.auth.restrictionsActions;
    };
    useIpRestrictions = () => {
      const {
        loading,
        data,
        saving,
        error,
        pagination,
        totalPages,
        userIpValid
      } = useRestrictionsState().ipRestrictions;
      const {
        loadIpRestrictions
      } = useRestrictionsActions();
      (0, import_react10.useEffect)(() => {
        if (!data && !loading) {
          loadIpRestrictions();
        }
      }, [loadIpRestrictions, data, loading]);
      return {
        loading,
        saving,
        error,
        data,
        pagination,
        totalPages,
        userIpValid
      };
    };
    useEmailDomainRestrictions = () => {
      const {
        loading,
        data,
        saving,
        error
      } = useRestrictionsState().emailDomainRestrictions;
      const {
        loadEmailDomainRestrictions
      } = useRestrictionsActions();
      (0, import_react10.useEffect)(() => {
        if (!data && !loading) {
          loadEmailDomainRestrictions();
        }
      }, [loadEmailDomainRestrictions, data, loading]);
      return {
        loading,
        saving,
        error,
        data
      };
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/security/securityCenter.js
function useSecurityCenterState() {
  const state = useStore().store.auth.securityCenterState;
  return useSnapshot(state);
}
var useSecurityCenterActions;
var init_securityCenter = __esm({
  "node_modules/@frontegg/react-hooks/auth/security/securityCenter.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useSecurityCenterActions = () => {
      return useStore().stateActions.auth.securityCenterActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/security/securityPolicy.js
function useSecurityPolicyState(stateMapper = defaultMapper11) {
  const state = useStore().store.auth.securityPolicyState;
  return stateMapper(useSnapshot(state));
}
var import_react11, defaultMapper11, useSecurityPolicyActions, usePublicPolicySettings, usePublicAuthStrategiesPolicySettings;
var init_securityPolicy = __esm({
  "node_modules/@frontegg/react-hooks/auth/security/securityPolicy.js"() {
    import_react11 = __toESM(require_react());
    init_FronteggStoreContext2();
    init_useSnapshot();
    defaultMapper11 = (state) => state;
    useSecurityPolicyActions = () => {
      return useStore().stateActions.auth.securityPolicyActions;
    };
    usePublicPolicySettings = (loadOnMount = false) => {
      const {
        publicPolicy
      } = useSecurityPolicyState();
      const {
        loadPublicSecurityPolicy
      } = useSecurityPolicyActions();
      (0, import_react11.useEffect)(() => {
        (loadOnMount || !publicPolicy.policy) && loadPublicSecurityPolicy();
      }, [loadOnMount, loadPublicSecurityPolicy]);
      return publicPolicy;
    };
    usePublicAuthStrategiesPolicySettings = (loadOnMount = false) => {
      const {
        publicAuthStrategyPolicy
      } = useSecurityPolicyState();
      const {
        loadPublicAuthStrategiesPolicy
      } = useSecurityPolicyActions();
      (0, import_react11.useEffect)(() => {
        (loadOnMount || !publicAuthStrategyPolicy.policy) && !publicAuthStrategyPolicy.error && loadPublicAuthStrategiesPolicy();
      }, [loadOnMount, loadPublicAuthStrategiesPolicy]);
      return publicAuthStrategyPolicy;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/security/sessionsPolicy.js
function useSessionsPolicyState() {
  const state = useStore().store.auth.sessionsPolicyState;
  return useSnapshot(state);
}
var useSessionsPolicyActions;
var init_sessionsPolicy = __esm({
  "node_modules/@frontegg/react-hooks/auth/security/sessionsPolicy.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useSessionsPolicyActions = () => {
      return useStore().stateActions.auth.sessionsPolicyActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/security/index.js
var init_security2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/security/index.js"() {
    init_restrictions();
    init_securityCenter();
    init_securityPolicy();
    init_sessionsPolicy();
  }
});

// node_modules/@frontegg/react-hooks/auth/tenants.js
function useTenantsState() {
  const state = useStore().store.auth.tenantsState;
  return useSnapshot(state);
}
var useTenantsActions;
var init_tenants2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/tenants.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useTenantsActions = () => {
      return useStore().stateActions.auth.tenantsActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/applications.js
function useApplicationsState() {
  const state = useStore().store.auth.applicationsState;
  return useSnapshot(state);
}
var useApplicationsActions;
var init_applications2 = __esm({
  "node_modules/@frontegg/react-hooks/auth/applications.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useApplicationsActions = () => {
      return useStore().stateActions.auth.applicationsActions;
    };
  }
});

// node_modules/@frontegg/react-hooks/auth/index.js
var init_auth3 = __esm({
  "node_modules/@frontegg/react-hooks/auth/index.js"() {
    init_hooks();
    init_acceptInvitation2();
    init_unlockAccount2();
    init_activateAccount2();
    init_allAccounts2();
    init_apiTokens2();
    init_customLogin();
    init_entitlements2();
    init_forgotPassword();
    init_passwordRotation();
    init_groups3();
    init_impersonate3();
    init_login2();
    init_mfa();
    init_passkeys();
    init_profile2();
    init_provisioning2();
    init_resetPhoneNumber2();
    init_roles3();
    init_sessions();
    init_signup2();
    init_sms();
    init_socialLogin();
    init_sso2();
    init_stepUp2();
    init_team();
    init_security2();
    init_tenants2();
    init_applications2();
  }
});

// node_modules/@frontegg/react-hooks/audits/hooks.js
function useAuditsState(stateMapper = defaultMapper12.state) {
  const state = useStore().store.auditLogs;
  return stateMapper(useSnapshot(state));
}
var defaultMapper12, useAuditsActions;
var init_hooks2 = __esm({
  "node_modules/@frontegg/react-hooks/audits/hooks.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    defaultMapper12 = {
      state: (state) => state,
      actions: (actions) => actions
    };
    useAuditsActions = () => {
      return useStore().stateActions.auditLogs;
    };
  }
});

// node_modules/@frontegg/react-hooks/audits/auditLogs.js
function useAuditLogsState() {
  const state = useStore().store.auditLogs.auditLogsState;
  return useSnapshot(state);
}
var useAuditLogsActions;
var init_auditLogs2 = __esm({
  "node_modules/@frontegg/react-hooks/audits/auditLogs.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useAuditLogsActions = () => {
      return useStore().stateActions.auditLogs;
    };
  }
});

// node_modules/@frontegg/react-hooks/audits/auditsMetadata.js
function useAuditsMetadataState() {
  const state = useStore().store.auditLogs.auditsMetadataState;
  return useSnapshot(state);
}
var useAuditsMetadataActions;
var init_auditsMetadata = __esm({
  "node_modules/@frontegg/react-hooks/audits/auditsMetadata.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useAuditsMetadataActions = () => {
      return useStore().stateActions.auditLogs;
    };
  }
});

// node_modules/@frontegg/react-hooks/audits/index.js
var init_audits3 = __esm({
  "node_modules/@frontegg/react-hooks/audits/index.js"() {
    init_hooks2();
    init_auditLogs2();
    init_auditsMetadata();
  }
});

// node_modules/@frontegg/react-hooks/connectivity/hooks.js
function useConnectivityState() {
  const state = useStore().store.connectivity;
  return useSnapshot(state);
}
var useConnectivityActions;
var init_hooks3 = __esm({
  "node_modules/@frontegg/react-hooks/connectivity/hooks.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    useConnectivityActions = () => {
      return useStore().stateActions.connectivity;
    };
  }
});

// node_modules/@frontegg/react-hooks/connectivity/index.js
var init_connectivity3 = __esm({
  "node_modules/@frontegg/react-hooks/connectivity/index.js"() {
    init_hooks3();
  }
});

// node_modules/@frontegg/react-hooks/subscriptions/hooks.js
function getSubscriptionsState() {
  return useStore().store.subscriptions;
}
var usePaymentProvider, usePaymentProviderActions, usePlans, usePlansActions, useCheckout, useCheckoutActions, useBillingActions, useBillingInformation, useBillingInformationActions, usePaymentMethod, usePaymentMethodActions, useInvoices, useInvoicesActions, useSubscriptionCancellation, useSubscriptionRenewal, useSubscription, useSubscriptionActions, useStripeState, useStripeActions, useVendorPublicConfig, useVendorPublicConfigActions;
var init_hooks4 = __esm({
  "node_modules/@frontegg/react-hooks/subscriptions/hooks.js"() {
    init_extends();
    init_FronteggStoreContext2();
    init_useSnapshot();
    usePaymentProvider = () => {
      const {
        config
      } = getSubscriptionsState();
      return useSnapshot(config);
    };
    usePaymentProviderActions = () => {
      return useStore().stateActions.subscriptions.config;
    };
    usePlans = () => {
      const {
        plans
      } = getSubscriptionsState();
      return useSnapshot(plans);
    };
    usePlansActions = () => {
      return useStore().stateActions.subscriptions.plans;
    };
    useCheckout = () => {
      const {
        checkout
      } = getSubscriptionsState();
      return useSnapshot(checkout);
    };
    useCheckoutActions = () => {
      return useStore().stateActions.subscriptions.checkout;
    };
    useBillingActions = (billingKey) => {
      return useStore().stateActions.subscriptions.billing[billingKey];
    };
    useBillingInformation = () => {
      const {
        billing
      } = getSubscriptionsState();
      return useSnapshot(billing.information);
    };
    useBillingInformationActions = () => {
      return useBillingActions("information");
    };
    usePaymentMethod = () => {
      const {
        billing
      } = getSubscriptionsState();
      return useSnapshot(billing.paymentMethod);
    };
    usePaymentMethodActions = () => {
      return useBillingActions("paymentMethod");
    };
    useInvoices = () => {
      const {
        billing
      } = getSubscriptionsState();
      return useSnapshot(billing.invoices);
    };
    useInvoicesActions = () => {
      return useBillingActions("invoices");
    };
    useSubscriptionCancellation = () => {
      const {
        billing
      } = getSubscriptionsState();
      const {
        cancellation
      } = useSnapshot(billing.subscription);
      return cancellation;
    };
    useSubscriptionRenewal = () => {
      const {
        billing
      } = getSubscriptionsState();
      const {
        renewal
      } = useSnapshot(billing.subscription);
      return renewal;
    };
    useSubscription = () => {
      const {
        billing
      } = getSubscriptionsState();
      return useSnapshot(billing.subscription);
    };
    useSubscriptionActions = () => {
      const actions = useStore().stateActions.subscriptions.billing.subscription;
      return _extends({}, actions, {
        load: actions.loadSubscription
      });
    };
    useStripeState = () => {
      const {
        stripe
      } = getSubscriptionsState();
      return useSnapshot(stripe);
    };
    useStripeActions = () => {
      return useStore().stateActions.subscriptions.stripe;
    };
    useVendorPublicConfig = () => {
      return useSnapshot(useStore().store.subscriptions.vendorPublicConfig);
    };
    useVendorPublicConfigActions = () => {
      return useStore().stateActions.subscriptions.vendorPublicConfig;
    };
  }
});

// node_modules/@frontegg/react-hooks/subscriptions/index.js
var init_subscriptions5 = __esm({
  "node_modules/@frontegg/react-hooks/subscriptions/index.js"() {
    init_hooks4();
  }
});

// node_modules/@frontegg/react-hooks/vendor/hooks.js
function useVendorState(stateMapper = defaultMapper13) {
  const state = useStore().store.vendor;
  return stateMapper(useSnapshot(state));
}
var defaultMapper13, useVendorActions;
var init_hooks5 = __esm({
  "node_modules/@frontegg/react-hooks/vendor/hooks.js"() {
    init_FronteggStoreContext2();
    init_useSnapshot();
    defaultMapper13 = (state) => state;
    useVendorActions = () => {
      return useStore().stateActions.vendor;
    };
  }
});

// node_modules/@frontegg/react-hooks/vendor/index.js
var init_vendor3 = __esm({
  "node_modules/@frontegg/react-hooks/vendor/index.js"() {
    init_hooks5();
  }
});

// node_modules/@frontegg/react-hooks/FronteggProvider/FronteggProvider.js
var import_react12, import_jsx_runtime4, import_jsx_runtime5, import_jsx_runtime6, _excluded87, defaultSetLoading, HideChildrenIfFronteggRoutes, FronteggContent, FronteggStoreProvider;
var init_FronteggProvider = __esm({
  "node_modules/@frontegg/react-hooks/FronteggProvider/FronteggProvider.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    import_react12 = __toESM(require_react());
    init_redux_store();
    init_rest_api();
    init_FronteggStoreContext2();
    init_auth3();
    import_jsx_runtime4 = __toESM(require_jsx_runtime());
    import_jsx_runtime5 = __toESM(require_jsx_runtime());
    import_jsx_runtime6 = __toESM(require_jsx_runtime());
    _excluded87 = ["authenticatedUrl", "signUpSuccessUrl"];
    defaultSetLoading = (loading) => {
      if (loading) {
        document.body.classList.add("frontegg-loading");
      } else {
        document.body.classList.remove("frontegg-loading");
      }
    };
    HideChildrenIfFronteggRoutes = ({
      children,
      basename
    }) => {
      const routes = useAuthRoutes();
      const uriRef = (0, import_react12.useRef)(window.location.pathname);
      const animationFrameRef = (0, import_react12.useRef)(0);
      const [uri, setUri] = (0, import_react12.useState)(window.location.pathname);
      const checker = (0, import_react12.useCallback)(() => {
        if (uriRef.current !== window.location.pathname) {
          uriRef.current = window.location.pathname;
          setUri(document.location.pathname);
        }
        animationFrameRef.current = window.requestAnimationFrame(checker);
      }, []);
      (0, import_react12.useEffect)(() => {
        document.addEventListener("frontegg_onRedirectTo_fired", () => {
          if (uriRef.current !== window.location.pathname) {
            uriRef.current = window.location.pathname;
            setUri(document.location.pathname);
          }
        });
        window.addEventListener("popstate", () => {
          if (uriRef.current !== window.location.pathname) {
            uriRef.current = window.location.pathname;
            setUri(document.location.pathname);
          }
        });
        animationFrameRef.current = window.requestAnimationFrame(checker);
        return () => {
          window.cancelAnimationFrame(animationFrameRef.current);
        };
      }, [checker, setUri]);
      const calculatedBasename = basename ? basename.endsWith("/") ? basename.substring(0, basename.length - 1) : "" : "";
      const checkRoutes = _objectWithoutPropertiesLoose(routes, _excluded87);
      if (Object.values(checkRoutes).map((url) => `${calculatedBasename}${url}`).indexOf(uri) !== -1) {
        return null;
      }
      return (0, import_jsx_runtime5.jsx)(import_jsx_runtime4.Fragment, {
        children
      });
    };
    FronteggContent = ({
      children,
      app,
      setLoading
    }) => {
      var _app$options, _app$options2;
      const {
        isLoading
      } = useAuth();
      const customLoginBox = !app || (app == null ? void 0 : (_app$options = app.options) == null ? void 0 : _app$options.customLoginBox) === true;
      const isNextJS = (app == null ? void 0 : (_app$options2 = app.options) == null ? void 0 : _app$options2.framework) === "nextjs";
      const alwaysShowChildren = customLoginBox || isNextJS;
      const loadingRef = (0, import_react12.useRef)(void 0);
      if (isLoading !== loadingRef.current && !isNextJS) {
        loadingRef.current = isLoading;
        setTimeout(() => {
          setLoading(isLoading);
        });
      }
      if (alwaysShowChildren) {
        return (0, import_jsx_runtime5.jsx)(import_jsx_runtime4.Fragment, {
          children
        });
      }
      if (isLoading && !isNextJS) {
        return null;
      }
      return (0, import_jsx_runtime5.jsx)(HideChildrenIfFronteggRoutes, {
        basename: app == null ? void 0 : app.options.basename,
        children
      });
    };
    FronteggStoreProvider = (props) => {
      var _app$options$contextO, _app$options3, _app$options$previewM, _app$options4, _app$options$builderM, _app$options5, _app$options6, _app$options7, _app$options8, _app$name;
      const {
        children,
        app,
        contextOptions,
        setLoading = defaultSetLoading,
        alwaysVisibleChildren
      } = props;
      const context = (_app$options$contextO = app == null ? void 0 : (_app$options3 = app.options) == null ? void 0 : _app$options3.contextOptions) != null ? _app$options$contextO : contextOptions;
      if (!context) {
        throw Error("contextOptions must not be null or undefined");
      }
      const previewMode = (_app$options$previewM = app == null ? void 0 : (_app$options4 = app.options) == null ? void 0 : _app$options4.previewMode) != null ? _app$options$previewM : false;
      const builderMode = (_app$options$builderM = app == null ? void 0 : (_app$options5 = app.options) == null ? void 0 : _app$options5.builderMode) != null ? _app$options$builderM : false;
      const auditsOptions = app == null ? void 0 : (_app$options6 = app.options) == null ? void 0 : _app$options6.auditsOptions;
      const authOptions = app != null && (_app$options7 = app.options) != null && _app$options7.authOptions ? _extends({}, app.options.authOptions, {
        hostedLoginBox: app.options.hostedLoginBox
      }) : {
        hostedLoginBox: app == null ? void 0 : (_app$options8 = app.options) == null ? void 0 : _app$options8.hostedLoginBox
      };
      const appName = (_app$name = app == null ? void 0 : app.name) != null ? _app$name : "default";
      ContextHolder.for(appName).setContext(context);
      const store = (0, import_react12.useMemo)(() => {
        var _app$store, _app$options9;
        return (_app$store = app == null ? void 0 : app.store) != null ? _app$store : createStore({
          name: appName,
          context,
          previewMode,
          builderMode,
          initialState: {
            auth: authOptions,
            audits: auditsOptions
          },
          urlStrategy: app == null ? void 0 : (_app$options9 = app.options) == null ? void 0 : _app$options9.urlStrategy,
          storeHolder: app
        });
      }, [app, previewMode]);
      return (0, import_jsx_runtime6.jsxs)(Provider, {
        store,
        children: [alwaysVisibleChildren, (0, import_jsx_runtime5.jsx)(FronteggContent, {
          setLoading,
          app,
          children
        })]
      });
    };
  }
});

// node_modules/@frontegg/react-hooks/FronteggProvider/index.js
var init_FronteggProvider2 = __esm({
  "node_modules/@frontegg/react-hooks/FronteggProvider/index.js"() {
    init_FronteggProvider();
  }
});

// node_modules/@frontegg/react-hooks/index.js
var react_hooks_exports = {};
__export(react_hooks_exports, {
  CustomComponentHolder: () => CustomComponentHolder,
  CustomComponentRegister: () => CustomComponentRegister,
  FronteggStoreContext: () => FronteggStoreContext,
  FronteggStoreProvider: () => FronteggStoreProvider,
  Provider: () => Provider,
  ShadowDomContext: () => ShadowDomContext,
  getMaxAgeFromQueryParam: () => getMaxAgeFromQueryParam,
  reloadProfileIfNeeded: () => reloadProfileIfNeeded,
  useAcceptInvitationActions: () => useAcceptInvitationActions,
  useAcceptInvitationState: () => useAcceptInvitationState,
  useActivateAccountActions: () => useActivateAccountActions,
  useActivateAccountState: () => useActivateAccountState,
  useAllAccountsActions: () => useAllAccountsActions,
  useAllAccountsDialogsActions: () => useAllAccountsDialogsActions,
  useAllAccountsDialogsState: () => useAllAccountsDialogsState,
  useAllAccountsState: () => useAllAccountsState,
  useApiTokensActions: () => useApiTokensActions,
  useApiTokensState: () => useApiTokensState,
  useApplicationsActions: () => useApplicationsActions,
  useApplicationsState: () => useApplicationsState,
  useAuditLogsActions: () => useAuditLogsActions,
  useAuditLogsState: () => useAuditLogsState,
  useAuditsActions: () => useAuditsActions,
  useAuditsMetadataActions: () => useAuditsMetadataActions,
  useAuditsMetadataState: () => useAuditsMetadataState,
  useAuditsState: () => useAuditsState,
  useAuth: () => useAuth,
  useAuthActions: () => useAuthActions,
  useAuthRoutes: () => useAuthRoutes,
  useAuthState: () => useAuthState,
  useAuthTeamActions: () => useAuthTeamActions,
  useAuthTeamState: () => useAuthTeamState,
  useAuthUser: () => useAuthUser,
  useAuthUserOrNull: () => useAuthUserOrNull,
  useBillingInformation: () => useBillingInformation,
  useBillingInformationActions: () => useBillingInformationActions,
  useCheckout: () => useCheckout,
  useCheckoutActions: () => useCheckoutActions,
  useConnectivityActions: () => useConnectivityActions,
  useConnectivityState: () => useConnectivityState,
  useCustomLoginActions: () => useCustomLoginActions,
  useCustomLoginState: () => useCustomLoginState,
  useCustomLoginTheme: () => useCustomLoginTheme,
  useEmailDomainRestrictions: () => useEmailDomainRestrictions,
  useEntitlements: () => useEntitlements,
  useEntitlementsActions: () => useEntitlementsActions,
  useEntitlementsOptions: () => useEntitlementsOptions,
  useFeatureEntitlements: () => useFeatureEntitlements,
  useFeatureFlags: () => useFeatureFlags,
  useFeatureFlagsChecker: () => useFeatureFlagsChecker,
  useForgotPasswordActions: () => useForgotPasswordActions,
  useForgotPasswordState: () => useForgotPasswordState,
  useGroupsActions: () => useGroupsActions,
  useGroupsDialogsActions: () => useGroupsDialogsActions,
  useGroupsDialogsState: () => useGroupsDialogsState,
  useGroupsState: () => useGroupsState,
  useImpersonateActions: () => useImpersonateActions,
  useImpersonateState: () => useImpersonateState,
  useInvoices: () => useInvoices,
  useInvoicesActions: () => useInvoicesActions,
  useIpRestrictions: () => useIpRestrictions,
  useIsAuthenticated: () => useIsAuthenticated,
  useIsSteppedUp: () => useIsSteppedUp,
  useLoginActions: () => useLoginActions,
  useLoginState: () => useLoginState,
  useLoginWithRedirect: () => useLoginWithRedirect,
  useLoginWithRedirectV2: () => useLoginWithRedirectV2,
  useMfaActions: () => useMfaActions,
  useMfaState: () => useMfaState,
  useOnRedirectTo: () => useOnRedirectTo,
  usePasskeysActions: () => usePasskeysActions,
  usePasskeysState: () => usePasskeysState,
  usePasswordRotationActions: () => usePasswordRotationActions,
  usePasswordRotationState: () => usePasswordRotationState,
  usePaymentMethod: () => usePaymentMethod,
  usePaymentMethodActions: () => usePaymentMethodActions,
  usePaymentProvider: () => usePaymentProvider,
  usePaymentProviderActions: () => usePaymentProviderActions,
  usePermissionEntitlements: () => usePermissionEntitlements,
  usePlans: () => usePlans,
  usePlansActions: () => usePlansActions,
  useProfileActions: () => useProfileActions,
  useProfileState: () => useProfileState,
  useProvisioningActions: () => useProvisioningActions,
  useProvisioningState: () => useProvisioningState,
  usePublicAuthStrategiesPolicySettings: () => usePublicAuthStrategiesPolicySettings,
  usePublicPolicySettings: () => usePublicPolicySettings,
  useResetPhoneNumberActions: () => useResetPhoneNumberActions,
  useResetPhoneNumberState: () => useResetPhoneNumberState,
  useRestrictionsActions: () => useRestrictionsActions,
  useRestrictionsState: () => useRestrictionsState,
  useRolesActions: () => useRolesActions,
  useRolesState: () => useRolesState,
  useRootState: () => useRootState,
  useSSOActions: () => useSSOActions,
  useSSOState: () => useSSOState,
  useSecurityCenterActions: () => useSecurityCenterActions,
  useSecurityCenterState: () => useSecurityCenterState,
  useSecurityPolicyActions: () => useSecurityPolicyActions,
  useSecurityPolicyState: () => useSecurityPolicyState,
  useSessionsActions: () => useSessionsActions,
  useSessionsPolicyActions: () => useSessionsPolicyActions,
  useSessionsPolicyState: () => useSessionsPolicyState,
  useSessionsState: () => useSessionsState,
  useShadowDom: () => useShadowDom,
  useSignUpActions: () => useSignUpActions,
  useSignUpState: () => useSignUpState,
  useSmsActions: () => useSmsActions,
  useSmsState: () => useSmsState,
  useSnapshot: () => useSnapshot,
  useSocialLoginActions: () => useSocialLoginActions,
  useSocialLoginState: () => useSocialLoginState,
  useStepUp: () => useStepUp,
  useStepUpActions: () => useStepUpActions,
  useStepUpState: () => useStepUpState,
  useStore: () => useStore,
  useStoreActions: () => useStoreActions,
  useStripeActions: () => useStripeActions,
  useStripeState: () => useStripeState,
  useSubscription: () => useSubscription,
  useSubscriptionActions: () => useSubscriptionActions,
  useSubscriptionCancellation: () => useSubscriptionCancellation,
  useSubscriptionRenewal: () => useSubscriptionRenewal,
  useTeamActions: () => useTeamActions,
  useTeamState: () => useTeamState,
  useTenantsActions: () => useTenantsActions,
  useTenantsState: () => useTenantsState,
  useUnlockAccountActions: () => useUnlockAccountActions,
  useUnlockAccountState: () => useUnlockAccountState,
  useVendorActions: () => useVendorActions,
  useVendorPublicConfig: () => useVendorPublicConfig,
  useVendorPublicConfigActions: () => useVendorPublicConfigActions,
  useVendorState: () => useVendorState
});
var init_react_hooks = __esm({
  "node_modules/@frontegg/react-hooks/index.js"() {
    init_auth3();
    init_audits3();
    init_connectivity3();
    init_subscriptions5();
    init_vendor3();
    init_common2();
    init_flags();
    init_useSnapshot();
    init_FronteggProvider2();
    init_FronteggStoreContext2();
  }
});

// node_modules/react-router/node_modules/cookie/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/react-router/node_modules/cookie/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = parse2;
    exports.serialize = serialize;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var __toString = Object.prototype.toString;
    var NullObject = (() => {
      const C = function() {
      };
      C.prototype = /* @__PURE__ */ Object.create(null);
      return C;
    })();
    function parse2(str, options) {
      const obj = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj;
      const dec = (options == null ? void 0 : options.decode) || decode;
      let index = 0;
      do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1)
          break;
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        if (obj[key] === void 0) {
          let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
          let valEndIdx = endIndex(str, endIdx, valStartIdx);
          const value = dec(str.slice(valStartIdx, valEndIdx));
          obj[key] = value;
        }
        index = endIdx + 1;
      } while (index < len);
      return obj;
    }
    function startIndex(str, index, max) {
      do {
        const code = str.charCodeAt(index);
        if (code !== 32 && code !== 9)
          return index;
      } while (++index < max);
      return max;
    }
    function endIndex(str, index, min) {
      while (index > min) {
        const code = str.charCodeAt(--index);
        if (code !== 32 && code !== 9)
          return index + 1;
      }
      return min;
    }
    function serialize(name, val, options) {
      const enc = (options == null ? void 0 : options.encode) || encodeURIComponent;
      if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
      }
      const value = enc(val);
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
      }
      let str = name + "=" + value;
      if (!options)
        return str;
      if (options.maxAge !== void 0) {
        if (!Number.isInteger(options.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
      }
      if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
          throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
      }
      if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
          throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
      }
      if (options.expires) {
        if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
      }
      if (options.httpOnly) {
        str += "; HttpOnly";
      }
      if (options.secure) {
        str += "; Secure";
      }
      if (options.partitioned) {
        str += "; Partitioned";
      }
      if (options.priority) {
        const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
      }
      if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
      }
      return str;
    }
    function decode(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]";
    }
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else if (key === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse2(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse2;
    module.exports.parse = parse2;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString;
  }
});

// node_modules/react-router/dist/development/index.js
var require_development = __commonJS({
  "node_modules/react-router/dist/development/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __typeError = (msg) => {
      throw TypeError(msg);
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
    var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
    var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    var react_router_exports = {};
    __export2(react_router_exports, {
      Await: () => Await,
      BrowserRouter: () => BrowserRouter,
      Form: () => Form,
      HashRouter: () => HashRouter,
      IDLE_BLOCKER: () => IDLE_BLOCKER,
      IDLE_FETCHER: () => IDLE_FETCHER,
      IDLE_NAVIGATION: () => IDLE_NAVIGATION,
      Link: () => Link,
      Links: () => Links,
      MemoryRouter: () => MemoryRouter,
      Meta: () => Meta,
      NavLink: () => NavLink,
      Navigate: () => Navigate,
      NavigationType: () => Action,
      Outlet: () => Outlet,
      PrefetchPageLinks: () => PrefetchPageLinks,
      Route: () => Route,
      Router: () => Router,
      RouterProvider: () => RouterProvider2,
      Routes: () => Routes,
      Scripts: () => Scripts,
      ScrollRestoration: () => ScrollRestoration,
      ServerRouter: () => ServerRouter,
      StaticRouter: () => StaticRouter,
      StaticRouterProvider: () => StaticRouterProvider,
      UNSAFE_DataRouterContext: () => DataRouterContext,
      UNSAFE_DataRouterStateContext: () => DataRouterStateContext,
      UNSAFE_ErrorResponseImpl: () => ErrorResponseImpl,
      UNSAFE_FetchersContext: () => FetchersContext,
      UNSAFE_FrameworkContext: () => FrameworkContext,
      UNSAFE_LocationContext: () => LocationContext,
      UNSAFE_NavigationContext: () => NavigationContext,
      UNSAFE_RemixErrorBoundary: () => RemixErrorBoundary,
      UNSAFE_RouteContext: () => RouteContext,
      UNSAFE_ServerMode: () => ServerMode,
      UNSAFE_SingleFetchRedirectSymbol: () => SingleFetchRedirectSymbol,
      UNSAFE_ViewTransitionContext: () => ViewTransitionContext,
      UNSAFE_createBrowserHistory: () => createBrowserHistory,
      UNSAFE_createClientRoutes: () => createClientRoutes,
      UNSAFE_createClientRoutesWithHMRRevalidationOptOut: () => createClientRoutesWithHMRRevalidationOptOut,
      UNSAFE_createRouter: () => createRouter,
      UNSAFE_decodeViaTurboStream: () => decodeViaTurboStream,
      UNSAFE_deserializeErrors: () => deserializeErrors2,
      UNSAFE_getHydrationData: () => getHydrationData,
      UNSAFE_getPatchRoutesOnNavigationFunction: () => getPatchRoutesOnNavigationFunction,
      UNSAFE_getTurboStreamSingleFetchDataStrategy: () => getTurboStreamSingleFetchDataStrategy,
      UNSAFE_hydrationRouteProperties: () => hydrationRouteProperties,
      UNSAFE_invariant: () => invariant,
      UNSAFE_mapRouteProperties: () => mapRouteProperties,
      UNSAFE_shouldHydrateRouteLoader: () => shouldHydrateRouteLoader,
      UNSAFE_useFogOFWarDiscovery: () => useFogOFWarDiscovery,
      UNSAFE_useScrollRestoration: () => useScrollRestoration,
      createBrowserRouter: () => createBrowserRouter,
      createCookie: () => createCookie,
      createCookieSessionStorage: () => createCookieSessionStorage,
      createHashRouter: () => createHashRouter,
      createMemoryRouter: () => createMemoryRouter,
      createMemorySessionStorage: () => createMemorySessionStorage,
      createPath: () => createPath,
      createRequestHandler: () => createRequestHandler,
      createRoutesFromChildren: () => createRoutesFromChildren,
      createRoutesFromElements: () => createRoutesFromElements,
      createRoutesStub: () => createRoutesStub,
      createSearchParams: () => createSearchParams,
      createSession: () => createSession,
      createSessionStorage: () => createSessionStorage,
      createStaticHandler: () => createStaticHandler2,
      createStaticRouter: () => createStaticRouter,
      data: () => data,
      generatePath: () => generatePath,
      href: () => href,
      isCookie: () => isCookie,
      isRouteErrorResponse: () => isRouteErrorResponse,
      isSession: () => isSession,
      matchPath: () => matchPath,
      matchRoutes: () => matchRoutes,
      parsePath: () => parsePath,
      redirect: () => redirect,
      redirectDocument: () => redirectDocument,
      renderMatches: () => renderMatches,
      replace: () => replace,
      resolvePath: () => resolvePath,
      unstable_HistoryRouter: () => HistoryRouter,
      unstable_RouterContextProvider: () => unstable_RouterContextProvider,
      unstable_createContext: () => unstable_createContext,
      unstable_setDevServerHooks: () => setDevServerHooks,
      unstable_usePrompt: () => usePrompt,
      useActionData: () => useActionData,
      useAsyncError: () => useAsyncError,
      useAsyncValue: () => useAsyncValue,
      useBeforeUnload: () => useBeforeUnload,
      useBlocker: () => useBlocker,
      useFetcher: () => useFetcher,
      useFetchers: () => useFetchers,
      useFormAction: () => useFormAction,
      useHref: () => useHref,
      useInRouterContext: () => useInRouterContext,
      useLinkClickHandler: () => useLinkClickHandler,
      useLoaderData: () => useLoaderData,
      useLocation: () => useLocation,
      useMatch: () => useMatch,
      useMatches: () => useMatches,
      useNavigate: () => useNavigate,
      useNavigation: () => useNavigation,
      useNavigationType: () => useNavigationType,
      useOutlet: () => useOutlet,
      useOutletContext: () => useOutletContext,
      useParams: () => useParams,
      useResolvedPath: () => useResolvedPath,
      useRevalidator: () => useRevalidator,
      useRouteError: () => useRouteError,
      useRouteLoaderData: () => useRouteLoaderData,
      useRoutes: () => useRoutes,
      useSearchParams: () => useSearchParams,
      useSubmit: () => useSubmit,
      useViewTransitionState: () => useViewTransitionState
    });
    module.exports = __toCommonJS2(react_router_exports);
    var Action = ((Action2) => {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
      return Action2;
    })(Action || {});
    var PopStateEventType = "popstate";
    function createMemoryHistory(options = {}) {
      let { initialEntries = ["/"], initialIndex, v5Compat = false } = options;
      let entries;
      entries = initialEntries.map(
        (entry, index2) => createMemoryLocation(
          entry,
          typeof entry === "string" ? null : entry.state,
          index2 === 0 ? "default" : void 0
        )
      );
      let index = clampIndex(
        initialIndex == null ? entries.length - 1 : initialIndex
      );
      let action = "POP";
      let listener = null;
      function clampIndex(n) {
        return Math.min(Math.max(n, 0), entries.length - 1);
      }
      function getCurrentLocation() {
        return entries[index];
      }
      function createMemoryLocation(to, state = null, key) {
        let location = createLocation(
          entries ? getCurrentLocation().pathname : "/",
          to,
          state,
          key
        );
        warning(
          location.pathname.charAt(0) === "/",
          `relative pathnames are not supported in memory history: ${JSON.stringify(
            to
          )}`
        );
        return location;
      }
      function createHref2(to) {
        return typeof to === "string" ? to : createPath(to);
      }
      let history = {
        get index() {
          return index;
        },
        get action() {
          return action;
        },
        get location() {
          return getCurrentLocation();
        },
        createHref: createHref2,
        createURL(to) {
          return new URL(createHref2(to), "http://localhost");
        },
        encodeLocation(to) {
          let path = typeof to === "string" ? parsePath(to) : to;
          return {
            pathname: path.pathname || "",
            search: path.search || "",
            hash: path.hash || ""
          };
        },
        push(to, state) {
          action = "PUSH";
          let nextLocation = createMemoryLocation(to, state);
          index += 1;
          entries.splice(index, entries.length, nextLocation);
          if (v5Compat && listener) {
            listener({ action, location: nextLocation, delta: 1 });
          }
        },
        replace(to, state) {
          action = "REPLACE";
          let nextLocation = createMemoryLocation(to, state);
          entries[index] = nextLocation;
          if (v5Compat && listener) {
            listener({ action, location: nextLocation, delta: 0 });
          }
        },
        go(delta) {
          action = "POP";
          let nextIndex = clampIndex(index + delta);
          let nextLocation = entries[nextIndex];
          index = nextIndex;
          if (listener) {
            listener({ action, location: nextLocation, delta });
          }
        },
        listen(fn) {
          listener = fn;
          return () => {
            listener = null;
          };
        }
      };
      return history;
    }
    function createBrowserHistory(options = {}) {
      function createBrowserLocation(window2, globalHistory) {
        let { pathname, search, hash } = window2.location;
        return createLocation(
          "",
          { pathname, search, hash },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to) {
        return typeof to === "string" ? to : createPath(to);
      }
      return getUrlBasedHistory(
        createBrowserLocation,
        createBrowserHref,
        null,
        options
      );
    }
    function createHashHistory(options = {}) {
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search = "",
          hash = ""
        } = parsePath(window2.location.hash.substring(1));
        if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
          pathname = "/" + pathname;
        }
        return createLocation(
          "",
          { pathname, search, hash },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to) {
        let base = window2.document.querySelector("base");
        let href2 = "";
        if (base && base.getAttribute("href")) {
          let url = window2.location.href;
          let hashIndex = url.indexOf("#");
          href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href2 + "#" + (typeof to === "string" ? to : createPath(to));
      }
      function validateHashLocation(location, to) {
        warning(
          location.pathname.charAt(0) === "/",
          `relative pathnames are not supported in hash history.push(${JSON.stringify(
            to
          )})`
        );
      }
      return getUrlBasedHistory(
        createHashLocation,
        createHashHref,
        validateHashLocation,
        options
      );
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
          throw new Error(message);
        } catch (e) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substring(2, 10);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current, to, state = null, key) {
      let location = {
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: "",
        ...typeof to === "string" ? parsePath(to) : to,
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      };
      return location;
    }
    function createPath({
      pathname = "/",
      search = "",
      hash = ""
    }) {
      if (search && search !== "?")
        pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash && hash !== "#")
        pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substring(hashIndex);
          path = path.substring(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substring(searchIndex);
          path = path.substring(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
      let { window: window2 = document.defaultView, v5Compat = false } = options;
      let globalHistory = window2.history;
      let action = "POP";
      let listener = null;
      let index = getIndex();
      if (index == null) {
        index = 0;
        globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
      }
      function getIndex() {
        let state = globalHistory.state || { idx: null };
        return state.idx;
      }
      function handlePop() {
        action = "POP";
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex;
        if (listener) {
          listener({ action, location: history.location, delta });
        }
      }
      function push(to, state) {
        action = "PUSH";
        let location = createLocation(history.location, to, state);
        if (validateLocation) validateLocation(location, to);
        index = getIndex() + 1;
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({ action, location: history.location, delta: 1 });
        }
      }
      function replace2(to, state) {
        action = "REPLACE";
        let location = createLocation(history.location, to, state);
        if (validateLocation) validateLocation(location, to);
        index = getIndex();
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({ action, location: history.location, delta: 0 });
        }
      }
      function createURL(to) {
        return createBrowserURLImpl(to);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to) {
          return createHref2(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace: replace2,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history;
    }
    function createBrowserURLImpl(to, isAbsolute = false) {
      let base = "http://localhost";
      if (typeof window !== "undefined") {
        base = window.location.origin !== "null" ? window.location.origin : window.location.href;
      }
      invariant(base, "No window.location.(origin|href) available to create URL");
      let href2 = typeof to === "string" ? to : createPath(to);
      href2 = href2.replace(/ $/, "%20");
      if (!isAbsolute && href2.startsWith("//")) {
        href2 = base + href2;
      }
      return new URL(href2, base);
    }
    function unstable_createContext(defaultValue) {
      return { defaultValue };
    }
    var _map;
    var unstable_RouterContextProvider = class {
      constructor(init) {
        __privateAdd(this, _map, /* @__PURE__ */ new Map());
        if (init) {
          for (let [context, value] of init) {
            this.set(context, value);
          }
        }
      }
      get(context) {
        if (__privateGet(this, _map).has(context)) {
          return __privateGet(this, _map).get(context);
        }
        if (context.defaultValue !== void 0) {
          return context.defaultValue;
        }
        throw new Error("No value found for context");
      }
      set(context, value) {
        __privateGet(this, _map).set(context, value);
      }
    };
    _map = /* @__PURE__ */ new WeakMap();
    var unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([
      "lazy",
      "caseSensitive",
      "path",
      "id",
      "index",
      "children"
    ]);
    function isUnsupportedLazyRouteObjectKey(key) {
      return unsupportedLazyRouteObjectKeys.has(
        key
      );
    }
    var unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([
      "lazy",
      "caseSensitive",
      "path",
      "id",
      "index",
      "unstable_middleware",
      "children"
    ]);
    function isUnsupportedLazyRouteFunctionKey(key) {
      return unsupportedLazyRouteFunctionKeys.has(
        key
      );
    }
    function isIndexRoute(route) {
      return route.index === true;
    }
    function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {
      return routes.map((route, index) => {
        let treePath = [...parentPath, String(index)];
        let id = typeof route.id === "string" ? route.id : treePath.join("-");
        invariant(
          route.index !== true || !route.children,
          `Cannot specify children on an index route`
        );
        invariant(
          !manifest[id],
          `Found a route id collision on id "${id}".  Route id's must be globally unique within Data Router usages`
        );
        if (isIndexRoute(route)) {
          let indexRoute = {
            ...route,
            ...mapRouteProperties2(route),
            id
          };
          manifest[id] = indexRoute;
          return indexRoute;
        } else {
          let pathOrLayoutRoute = {
            ...route,
            ...mapRouteProperties2(route),
            id,
            children: void 0
          };
          manifest[id] = pathOrLayoutRoute;
          if (route.children) {
            pathOrLayoutRoute.children = convertRoutesToDataRoutes(
              route.children,
              mapRouteProperties2,
              treePath,
              manifest
            );
          }
          return pathOrLayoutRoute;
        }
      });
    }
    function matchRoutes(routes, locationArg, basename = "/") {
      return matchRoutesImpl(routes, locationArg, basename, false);
    }
    function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i) {
        let decoded = decodePath(pathname);
        matches = matchRouteBranch(
          branches[i],
          decoded,
          allowPartial
        );
      }
      return matches;
    }
    function convertRouteMatchToUiMatch(match, loaderData) {
      let { route, pathname, params } = match;
      return {
        id: route.id,
        pathname,
        params,
        data: loaderData[route.id],
        handle: route.handle
      };
    }
    function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
      let flattenRoute = (route, index, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant(
            meta.relativePath.startsWith(parentPath),
            `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
          );
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
          );
          flattenRoutes(route.children, branches, routesMeta, path);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index) => {
        var _a;
        if (route.path === "" || !((_a = route.path) == null ? void 0 : _a.includes("?"))) {
          flattenRoute(route, index);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0) return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(
        ...restExploded.map(
          (subpath) => subpath === "" ? required : [required, subpath].join("/")
        )
      );
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map(
        (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
      );
    }
    function rankRouteBranches(branches) {
      branches.sort(
        (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
          a.routesMeta.map((meta) => meta.childrenIndex),
          b.routesMeta.map((meta) => meta.childrenIndex)
        )
      );
    }
    var paramRe = /^:[\w-]+$/;
    var dynamicSegmentValue = 3;
    var indexRouteValue = 2;
    var emptySegmentValue = 1;
    var staticSegmentValue = 10;
    var splatPenalty = -2;
    var isSplat = (s) => s === "*";
    function computeScore(path, index) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce(
        (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
        initialScore
      );
    }
    function compareIndexes(a, b) {
      let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname, allowPartial = false) {
      let { routesMeta } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match = matchPath(
          { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
          remainingPathname
        );
        let route = meta.route;
        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
          match = matchPath(
            {
              path: meta.relativePath,
              caseSensitive: meta.caseSensitive,
              end: false
            },
            remainingPathname
          );
        }
        if (!match) {
          return null;
        }
        Object.assign(matchedParams, match.params);
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(
            joinPaths([matchedPathname, match.pathnameBase])
          ),
          route
        });
        if (match.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
        }
      }
      return matches;
    }
    function generatePath(originalPath, params = {}) {
      let path = originalPath;
      if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
        warning(
          false,
          `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
        );
        path = path.replace(/\*$/, "/*");
      }
      const prefix = path.startsWith("/") ? "/" : "";
      const stringify2 = (p) => p == null ? "" : typeof p === "string" ? p : String(p);
      const segments = path.split(/\/+/).map((segment, index, array) => {
        const isLastSegment = index === array.length - 1;
        if (isLastSegment && segment === "*") {
          const star = "*";
          return stringify2(params[star]);
        }
        const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
        if (keyMatch) {
          const [, key, optional] = keyMatch;
          let param = params[key];
          invariant(optional === "?" || param != null, `Missing ":${key}" param`);
          return stringify2(param);
        }
        return segment.replace(/\?$/g, "");
      }).filter((segment) => !!segment);
      return prefix + segments.join("/");
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = { path: pattern, caseSensitive: false, end: true };
      }
      let [matcher, compiledParams] = compilePath(
        pattern.path,
        pattern.caseSensitive,
        pattern.end
      );
      let match = pathname.match(matcher);
      if (!match) return null;
      let matchedPathname = match[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match.slice(1);
      let params = compiledParams.reduce(
        (memo2, { paramName, isOptional }, index) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          const value = captureGroups[index];
          if (isOptional && !value) {
            memo2[paramName] = void 0;
          } else {
            memo2[paramName] = (value || "").replace(/%2F/g, "/");
          }
          return memo2;
        },
        {}
      );
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive = false, end = true) {
      warning(
        path === "*" || !path.endsWith("*") || path.endsWith("/*"),
        `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
      );
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
        /\/:([\w-]+)(\?)?/g,
        (_, paramName, isOptional) => {
          params.push({ paramName, isOptional: isOptional != null });
          return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
        }
      );
      if (path.endsWith("*")) {
        params.push({ paramName: "*" });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else {
      }
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function decodePath(value) {
      try {
        return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
      } catch (error) {
        warning(
          false,
          `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
        );
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/") return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname = "/") {
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1) segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
        path
      )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
    }
    function getPathContributingMatches(matches) {
      return matches.filter(
        (match, index) => index === 0 || match.route.path && match.route.path.length > 0
      );
    }
    function getResolveToMatches(matches) {
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches.map(
        (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
      );
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
      let to;
      if (typeof toArg === "string") {
        to = parsePath(toArg);
      } else {
        to = { ...toArg };
        invariant(
          !to.pathname || !to.pathname.includes("?"),
          getInvalidPathError("?", "pathname", "search", to)
        );
        invariant(
          !to.pathname || !to.pathname.includes("#"),
          getInvalidPathError("#", "pathname", "hash", to)
        );
        invariant(
          !to.search || !to.search.includes("#"),
          getInvalidPathError("#", "search", "hash", to)
        );
      }
      let isEmptyPath = toArg === "" || to.pathname === "";
      let toPathname = isEmptyPath ? "/" : to.pathname;
      let from;
      if (toPathname == null) {
        from = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    var DataWithResponseInit = class {
      constructor(data2, init) {
        this.type = "DataWithResponseInit";
        this.data = data2;
        this.init = init || null;
      }
    };
    function data(data2, init) {
      return new DataWithResponseInit(
        data2,
        typeof init === "number" ? { status: init } : init
      );
    }
    var redirect = (url, init = 302) => {
      let responseInit = init;
      if (typeof responseInit === "number") {
        responseInit = { status: responseInit };
      } else if (typeof responseInit.status === "undefined") {
        responseInit.status = 302;
      }
      let headers = new Headers(responseInit.headers);
      headers.set("Location", url);
      return new Response(null, { ...responseInit, headers });
    };
    var redirectDocument = (url, init) => {
      let response = redirect(url, init);
      response.headers.set("X-Remix-Reload-Document", "true");
      return response;
    };
    var replace = (url, init) => {
      let response = redirect(url, init);
      response.headers.set("X-Remix-Replace", "true");
      return response;
    };
    var ErrorResponseImpl = class {
      constructor(status, statusText, data2, internal = false) {
        this.status = status;
        this.statusText = statusText || "";
        this.internal = internal;
        if (data2 instanceof Error) {
          this.data = data2.toString();
          this.error = data2;
        } else {
          this.data = data2;
        }
      }
    };
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    var validMutationMethodsArr = [
      "POST",
      "PUT",
      "PATCH",
      "DELETE"
    ];
    var validMutationMethods = new Set(
      validMutationMethodsArr
    );
    var validRequestMethodsArr = [
      "GET",
      ...validMutationMethodsArr
    ];
    var validRequestMethods = new Set(validRequestMethodsArr);
    var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    var redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
    var IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    var IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    var IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    };
    var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var defaultMapRouteProperties = (route) => ({
      hasErrorBoundary: Boolean(route.hasErrorBoundary)
    });
    var TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
    var ResetLoaderDataSymbol = Symbol("ResetLoaderData");
    function createRouter(init) {
      const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
      const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
      invariant(
        init.routes.length > 0,
        "You must provide a non-empty routes array to createRouter"
      );
      let hydrationRouteProperties2 = init.hydrationRouteProperties || [];
      let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;
      let manifest = {};
      let dataRoutes = convertRoutesToDataRoutes(
        init.routes,
        mapRouteProperties2,
        void 0,
        manifest
      );
      let inFlightDataRoutes;
      let basename = init.basename || "/";
      let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;
      let future = {
        unstable_middleware: false,
        ...init.future
      };
      let unlistenHistory = null;
      let subscribers = /* @__PURE__ */ new Set();
      let savedScrollPositions2 = null;
      let getScrollRestorationKey2 = null;
      let getScrollPosition = null;
      let initialScrollRestored = init.hydrationData != null;
      let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
      let initialMatchesIsFOW = false;
      let initialErrors = null;
      let initialized;
      if (initialMatches == null && !init.patchRoutesOnNavigation) {
        let error = getInternalRouterError(404, {
          pathname: init.history.location.pathname
        });
        let { matches, route } = getShortCircuitMatches(dataRoutes);
        initialized = true;
        initialMatches = matches;
        initialErrors = { [route.id]: error };
      } else {
        if (initialMatches && !init.hydrationData) {
          let fogOfWar = checkFogOfWar(
            initialMatches,
            dataRoutes,
            init.history.location.pathname
          );
          if (fogOfWar.active) {
            initialMatches = null;
          }
        }
        if (!initialMatches) {
          initialized = false;
          initialMatches = [];
          let fogOfWar = checkFogOfWar(
            null,
            dataRoutes,
            init.history.location.pathname
          );
          if (fogOfWar.active && fogOfWar.matches) {
            initialMatchesIsFOW = true;
            initialMatches = fogOfWar.matches;
          }
        } else if (initialMatches.some((m) => m.route.lazy)) {
          initialized = false;
        } else if (!initialMatches.some((m) => m.route.loader)) {
          initialized = true;
        } else {
          let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
          let errors = init.hydrationData ? init.hydrationData.errors : null;
          if (errors) {
            let idx = initialMatches.findIndex(
              (m) => errors[m.route.id] !== void 0
            );
            initialized = initialMatches.slice(0, idx + 1).every(
              (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)
            );
          } else {
            initialized = initialMatches.every(
              (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)
            );
          }
        }
      }
      let router;
      let state = {
        historyAction: init.history.action,
        location: init.history.location,
        matches: initialMatches,
        initialized,
        navigation: IDLE_NAVIGATION,
        // Don't restore on initial updateState() if we were SSR'd
        restoreScrollPosition: init.hydrationData != null ? false : null,
        preventScrollReset: false,
        revalidation: "idle",
        loaderData: init.hydrationData && init.hydrationData.loaderData || {},
        actionData: init.hydrationData && init.hydrationData.actionData || null,
        errors: init.hydrationData && init.hydrationData.errors || initialErrors,
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      };
      let pendingAction = "POP";
      let pendingPreventScrollReset = false;
      let pendingNavigationController;
      let pendingViewTransitionEnabled = false;
      let appliedViewTransitions = /* @__PURE__ */ new Map();
      let removePageHideEventListener = null;
      let isUninterruptedRevalidation = false;
      let isRevalidationRequired = false;
      let cancelledFetcherLoads = /* @__PURE__ */ new Set();
      let fetchControllers = /* @__PURE__ */ new Map();
      let incrementingLoadId = 0;
      let pendingNavigationLoadId = -1;
      let fetchReloadIds = /* @__PURE__ */ new Map();
      let fetchRedirectIds = /* @__PURE__ */ new Set();
      let fetchLoadMatches = /* @__PURE__ */ new Map();
      let activeFetchers = /* @__PURE__ */ new Map();
      let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();
      let blockerFunctions = /* @__PURE__ */ new Map();
      let unblockBlockerHistoryUpdate = void 0;
      let pendingRevalidationDfd = null;
      function initialize3() {
        unlistenHistory = init.history.listen(
          ({ action: historyAction, location, delta }) => {
            if (unblockBlockerHistoryUpdate) {
              unblockBlockerHistoryUpdate();
              unblockBlockerHistoryUpdate = void 0;
              return;
            }
            warning(
              blockerFunctions.size === 0 || delta != null,
              "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
            );
            let blockerKey = shouldBlockNavigation({
              currentLocation: state.location,
              nextLocation: location,
              historyAction
            });
            if (blockerKey && delta != null) {
              let nextHistoryUpdatePromise = new Promise((resolve) => {
                unblockBlockerHistoryUpdate = resolve;
              });
              init.history.go(delta * -1);
              updateBlocker(blockerKey, {
                state: "blocked",
                location,
                proceed() {
                  updateBlocker(blockerKey, {
                    state: "proceeding",
                    proceed: void 0,
                    reset: void 0,
                    location
                  });
                  nextHistoryUpdatePromise.then(() => init.history.go(delta));
                },
                reset() {
                  let blockers = new Map(state.blockers);
                  blockers.set(blockerKey, IDLE_BLOCKER);
                  updateState({ blockers });
                }
              });
              return;
            }
            return startNavigation(historyAction, location);
          }
        );
        if (isBrowser2) {
          restoreAppliedTransitions(routerWindow, appliedViewTransitions);
          let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
          routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
          removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
        }
        if (!state.initialized) {
          startNavigation("POP", state.location, {
            initialHydration: true
          });
        }
        return router;
      }
      function dispose() {
        if (unlistenHistory) {
          unlistenHistory();
        }
        if (removePageHideEventListener) {
          removePageHideEventListener();
        }
        subscribers.clear();
        pendingNavigationController && pendingNavigationController.abort();
        state.fetchers.forEach((_, key) => deleteFetcher(key));
        state.blockers.forEach((_, key) => deleteBlocker(key));
      }
      function subscribe2(fn) {
        subscribers.add(fn);
        return () => subscribers.delete(fn);
      }
      function updateState(newState, opts = {}) {
        state = {
          ...state,
          ...newState
        };
        let unmountedFetchers = [];
        let mountedFetchers = [];
        state.fetchers.forEach((fetcher, key) => {
          if (fetcher.state === "idle") {
            if (fetchersQueuedForDeletion.has(key)) {
              unmountedFetchers.push(key);
            } else {
              mountedFetchers.push(key);
            }
          }
        });
        fetchersQueuedForDeletion.forEach((key) => {
          if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
            unmountedFetchers.push(key);
          }
        });
        [...subscribers].forEach(
          (subscriber) => subscriber(state, {
            deletedFetchers: unmountedFetchers,
            viewTransitionOpts: opts.viewTransitionOpts,
            flushSync: opts.flushSync === true
          })
        );
        unmountedFetchers.forEach((key) => deleteFetcher(key));
        mountedFetchers.forEach((key) => state.fetchers.delete(key));
      }
      function completeNavigation(location, newState, { flushSync } = {}) {
        var _a, _b;
        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_a = location.state) == null ? void 0 : _a._isRedirect) !== true;
        let actionData;
        if (newState.actionData) {
          if (Object.keys(newState.actionData).length > 0) {
            actionData = newState.actionData;
          } else {
            actionData = null;
          }
        } else if (isActionReload) {
          actionData = state.actionData;
        } else {
          actionData = null;
        }
        let loaderData = newState.loaderData ? mergeLoaderData(
          state.loaderData,
          newState.loaderData,
          newState.matches || [],
          newState.errors
        ) : state.loaderData;
        let blockers = state.blockers;
        if (blockers.size > 0) {
          blockers = new Map(blockers);
          blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
        }
        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_b = location.state) == null ? void 0 : _b._isRedirect) !== true;
        if (inFlightDataRoutes) {
          dataRoutes = inFlightDataRoutes;
          inFlightDataRoutes = void 0;
        }
        if (isUninterruptedRevalidation) {
        } else if (pendingAction === "POP") {
        } else if (pendingAction === "PUSH") {
          init.history.push(location, location.state);
        } else if (pendingAction === "REPLACE") {
          init.history.replace(location, location.state);
        }
        let viewTransitionOpts;
        if (pendingAction === "POP") {
          let priorPaths = appliedViewTransitions.get(state.location.pathname);
          if (priorPaths && priorPaths.has(location.pathname)) {
            viewTransitionOpts = {
              currentLocation: state.location,
              nextLocation: location
            };
          } else if (appliedViewTransitions.has(location.pathname)) {
            viewTransitionOpts = {
              currentLocation: location,
              nextLocation: state.location
            };
          }
        } else if (pendingViewTransitionEnabled) {
          let toPaths = appliedViewTransitions.get(state.location.pathname);
          if (toPaths) {
            toPaths.add(location.pathname);
          } else {
            toPaths = /* @__PURE__ */ new Set([location.pathname]);
            appliedViewTransitions.set(state.location.pathname, toPaths);
          }
          viewTransitionOpts = {
            currentLocation: state.location,
            nextLocation: location
          };
        }
        updateState(
          {
            ...newState,
            // matches, errors, fetchers go through as-is
            actionData,
            loaderData,
            historyAction: pendingAction,
            location,
            initialized: true,
            navigation: IDLE_NAVIGATION,
            revalidation: "idle",
            restoreScrollPosition: getSavedScrollPosition(
              location,
              newState.matches || state.matches
            ),
            preventScrollReset,
            blockers
          },
          {
            viewTransitionOpts,
            flushSync: flushSync === true
          }
        );
        pendingAction = "POP";
        pendingPreventScrollReset = false;
        pendingViewTransitionEnabled = false;
        isUninterruptedRevalidation = false;
        isRevalidationRequired = false;
        pendingRevalidationDfd == null ? void 0 : pendingRevalidationDfd.resolve();
        pendingRevalidationDfd = null;
      }
      async function navigate(to, opts) {
        if (typeof to === "number") {
          init.history.go(to);
          return;
        }
        let normalizedPath = normalizeTo(
          state.location,
          state.matches,
          basename,
          to,
          opts == null ? void 0 : opts.fromRouteId,
          opts == null ? void 0 : opts.relative
        );
        let { path, submission, error } = normalizeNavigateOptions(
          false,
          normalizedPath,
          opts
        );
        let currentLocation = state.location;
        let nextLocation = createLocation(state.location, path, opts && opts.state);
        nextLocation = {
          ...nextLocation,
          ...init.history.encodeLocation(nextLocation)
        };
        let userReplace = opts && opts.replace != null ? opts.replace : void 0;
        let historyAction = "PUSH";
        if (userReplace === true) {
          historyAction = "REPLACE";
        } else if (userReplace === false) {
        } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
          historyAction = "REPLACE";
        }
        let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
        let flushSync = (opts && opts.flushSync) === true;
        let blockerKey = shouldBlockNavigation({
          currentLocation,
          nextLocation,
          historyAction
        });
        if (blockerKey) {
          updateBlocker(blockerKey, {
            state: "blocked",
            location: nextLocation,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: nextLocation
              });
              navigate(to, opts);
            },
            reset() {
              let blockers = new Map(state.blockers);
              blockers.set(blockerKey, IDLE_BLOCKER);
              updateState({ blockers });
            }
          });
          return;
        }
        await startNavigation(historyAction, nextLocation, {
          submission,
          // Send through the formData serialization error if we have one so we can
          // render at the right error boundary after we match routes
          pendingError: error,
          preventScrollReset,
          replace: opts && opts.replace,
          enableViewTransition: opts && opts.viewTransition,
          flushSync
        });
      }
      function revalidate() {
        if (!pendingRevalidationDfd) {
          pendingRevalidationDfd = createDeferred();
        }
        interruptActiveLoads();
        updateState({ revalidation: "loading" });
        let promise = pendingRevalidationDfd.promise;
        if (state.navigation.state === "submitting") {
          return promise;
        }
        if (state.navigation.state === "idle") {
          startNavigation(state.historyAction, state.location, {
            startUninterruptedRevalidation: true
          });
          return promise;
        }
        startNavigation(
          pendingAction || state.historyAction,
          state.navigation.location,
          {
            overrideNavigation: state.navigation,
            // Proxy through any rending view transition
            enableViewTransition: pendingViewTransitionEnabled === true
          }
        );
        return promise;
      }
      async function startNavigation(historyAction, location, opts) {
        pendingNavigationController && pendingNavigationController.abort();
        pendingNavigationController = null;
        pendingAction = historyAction;
        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
        saveScrollPosition(state.location, state.matches);
        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let loadingNavigation = opts && opts.overrideNavigation;
        let matches = (opts == null ? void 0 : opts.initialHydration) && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
          // `matchRoutes()` has already been called if we're in here via `router.initialize()`
          state.matches
        ) : matchRoutes(routesToUse, location, basename);
        let flushSync = (opts && opts.flushSync) === true;
        if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
          completeNavigation(location, { matches }, { flushSync });
          return;
        }
        let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);
        if (fogOfWar.active && fogOfWar.matches) {
          matches = fogOfWar.matches;
        }
        if (!matches) {
          let { error, notFoundMatches, route } = handleNavigational404(
            location.pathname
          );
          completeNavigation(
            location,
            {
              matches: notFoundMatches,
              loaderData: {},
              errors: {
                [route.id]: error
              }
            },
            { flushSync }
          );
          return;
        }
        pendingNavigationController = new AbortController();
        let request = createClientSideRequest(
          init.history,
          location,
          pendingNavigationController.signal,
          opts && opts.submission
        );
        let scopedContext = new unstable_RouterContextProvider(
          init.unstable_getContext ? await init.unstable_getContext() : void 0
        );
        let pendingActionResult;
        if (opts && opts.pendingError) {
          pendingActionResult = [
            findNearestBoundary(matches).route.id,
            { type: "error", error: opts.pendingError }
          ];
        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
          let actionResult = await handleAction(
            request,
            location,
            opts.submission,
            matches,
            scopedContext,
            fogOfWar.active,
            opts && opts.initialHydration === true,
            { replace: opts.replace, flushSync }
          );
          if (actionResult.shortCircuited) {
            return;
          }
          if (actionResult.pendingActionResult) {
            let [routeId, result] = actionResult.pendingActionResult;
            if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
              pendingNavigationController = null;
              completeNavigation(location, {
                matches: actionResult.matches,
                loaderData: {},
                errors: {
                  [routeId]: result.error
                }
              });
              return;
            }
          }
          matches = actionResult.matches || matches;
          pendingActionResult = actionResult.pendingActionResult;
          loadingNavigation = getLoadingNavigation(location, opts.submission);
          flushSync = false;
          fogOfWar.active = false;
          request = createClientSideRequest(
            init.history,
            request.url,
            request.signal
          );
        }
        let {
          shortCircuited,
          matches: updatedMatches,
          loaderData,
          errors
        } = await handleLoaders(
          request,
          location,
          matches,
          scopedContext,
          fogOfWar.active,
          loadingNavigation,
          opts && opts.submission,
          opts && opts.fetcherSubmission,
          opts && opts.replace,
          opts && opts.initialHydration === true,
          flushSync,
          pendingActionResult
        );
        if (shortCircuited) {
          return;
        }
        pendingNavigationController = null;
        completeNavigation(location, {
          matches: updatedMatches || matches,
          ...getActionDataForCommit(pendingActionResult),
          loaderData,
          errors
        });
      }
      async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {
        interruptActiveLoads();
        let navigation = getSubmittingNavigation(location, submission);
        updateState({ navigation }, { flushSync: opts.flushSync === true });
        if (isFogOfWar) {
          let discoverResult = await discoverRoutes(
            matches,
            location.pathname,
            request.signal
          );
          if (discoverResult.type === "aborted") {
            return { shortCircuited: true };
          } else if (discoverResult.type === "error") {
            let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
            return {
              matches: discoverResult.partialMatches,
              pendingActionResult: [
                boundaryId,
                {
                  type: "error",
                  error: discoverResult.error
                }
              ]
            };
          } else if (!discoverResult.matches) {
            let { notFoundMatches, error, route } = handleNavigational404(
              location.pathname
            );
            return {
              matches: notFoundMatches,
              pendingActionResult: [
                route.id,
                {
                  type: "error",
                  error
                }
              ]
            };
          } else {
            matches = discoverResult.matches;
          }
        }
        let result;
        let actionMatch = getTargetMatch(matches, location);
        if (!actionMatch.route.action && !actionMatch.route.lazy) {
          result = {
            type: "error",
            error: getInternalRouterError(405, {
              method: request.method,
              pathname: location.pathname,
              routeId: actionMatch.route.id
            })
          };
        } else {
          let dsMatches = getTargetedDataStrategyMatches(
            mapRouteProperties2,
            manifest,
            request,
            matches,
            actionMatch,
            initialHydration ? [] : hydrationRouteProperties2,
            scopedContext
          );
          let results = await callDataStrategy(
            request,
            dsMatches,
            scopedContext,
            null
          );
          result = results[actionMatch.route.id];
          if (!result) {
            for (let match of matches) {
              if (results[match.route.id]) {
                result = results[match.route.id];
                break;
              }
            }
          }
          if (request.signal.aborted) {
            return { shortCircuited: true };
          }
        }
        if (isRedirectResult(result)) {
          let replace2;
          if (opts && opts.replace != null) {
            replace2 = opts.replace;
          } else {
            let location2 = normalizeRedirectLocation(
              result.response.headers.get("Location"),
              new URL(request.url),
              basename
            );
            replace2 = location2 === state.location.pathname + state.location.search;
          }
          await startRedirectNavigation(request, result, true, {
            submission,
            replace: replace2
          });
          return { shortCircuited: true };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
          if ((opts && opts.replace) !== true) {
            pendingAction = "PUSH";
          }
          return {
            matches,
            pendingActionResult: [
              boundaryMatch.route.id,
              result,
              actionMatch.route.id
            ]
          };
        }
        return {
          matches,
          pendingActionResult: [actionMatch.route.id, result]
        };
      }
      async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {
        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
        let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;
        if (isFogOfWar) {
          if (shouldUpdateNavigationState) {
            let actionData = getUpdatedActionData(pendingActionResult);
            updateState(
              {
                navigation: loadingNavigation,
                ...actionData !== void 0 ? { actionData } : {}
              },
              {
                flushSync
              }
            );
          }
          let discoverResult = await discoverRoutes(
            matches,
            location.pathname,
            request.signal
          );
          if (discoverResult.type === "aborted") {
            return { shortCircuited: true };
          } else if (discoverResult.type === "error") {
            let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
            return {
              matches: discoverResult.partialMatches,
              loaderData: {},
              errors: {
                [boundaryId]: discoverResult.error
              }
            };
          } else if (!discoverResult.matches) {
            let { error, notFoundMatches, route } = handleNavigational404(
              location.pathname
            );
            return {
              matches: notFoundMatches,
              loaderData: {},
              errors: {
                [route.id]: error
              }
            };
          } else {
            matches = discoverResult.matches;
          }
        }
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let { dsMatches, revalidatingFetchers } = getMatchesToLoad(
          request,
          scopedContext,
          mapRouteProperties2,
          manifest,
          init.history,
          state,
          matches,
          activeSubmission,
          location,
          initialHydration ? [] : hydrationRouteProperties2,
          initialHydration === true,
          isRevalidationRequired,
          cancelledFetcherLoads,
          fetchersQueuedForDeletion,
          fetchLoadMatches,
          fetchRedirectIds,
          routesToUse,
          basename,
          pendingActionResult
        );
        pendingNavigationLoadId = ++incrementingLoadId;
        if (!init.dataStrategy && !dsMatches.some((m) => m.shouldLoad) && revalidatingFetchers.length === 0) {
          let updatedFetchers2 = markFetchRedirectsDone();
          completeNavigation(
            location,
            {
              matches,
              loaderData: {},
              // Commit pending error if we're short circuiting
              errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,
              ...getActionDataForCommit(pendingActionResult),
              ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}
            },
            { flushSync }
          );
          return { shortCircuited: true };
        }
        if (shouldUpdateNavigationState) {
          let updates = {};
          if (!isFogOfWar) {
            updates.navigation = loadingNavigation;
            let actionData = getUpdatedActionData(pendingActionResult);
            if (actionData !== void 0) {
              updates.actionData = actionData;
            }
          }
          if (revalidatingFetchers.length > 0) {
            updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
          }
          updateState(updates, { flushSync });
        }
        revalidatingFetchers.forEach((rf) => {
          abortFetcher(rf.key);
          if (rf.controller) {
            fetchControllers.set(rf.key, rf.controller);
          }
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f2) => abortFetcher(f2.key));
        if (pendingNavigationController) {
          pendingNavigationController.signal.addEventListener(
            "abort",
            abortPendingFetchRevalidations
          );
        }
        let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
          dsMatches,
          revalidatingFetchers,
          request,
          scopedContext
        );
        if (request.signal.aborted) {
          return { shortCircuited: true };
        }
        if (pendingNavigationController) {
          pendingNavigationController.signal.removeEventListener(
            "abort",
            abortPendingFetchRevalidations
          );
        }
        revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
        let redirect2 = findRedirect(loaderResults);
        if (redirect2) {
          await startRedirectNavigation(request, redirect2.result, true, {
            replace: replace2
          });
          return { shortCircuited: true };
        }
        redirect2 = findRedirect(fetcherResults);
        if (redirect2) {
          fetchRedirectIds.add(redirect2.key);
          await startRedirectNavigation(request, redirect2.result, true, {
            replace: replace2
          });
          return { shortCircuited: true };
        }
        let { loaderData, errors } = processLoaderData(
          state,
          matches,
          loaderResults,
          pendingActionResult,
          revalidatingFetchers,
          fetcherResults
        );
        if (initialHydration && state.errors) {
          errors = { ...state.errors, ...errors };
        }
        let updatedFetchers = markFetchRedirectsDone();
        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
        return {
          matches,
          loaderData,
          errors,
          ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}
        };
      }
      function getUpdatedActionData(pendingActionResult) {
        if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
          return {
            [pendingActionResult[0]]: pendingActionResult[1].data
          };
        } else if (state.actionData) {
          if (Object.keys(state.actionData).length === 0) {
            return null;
          } else {
            return state.actionData;
          }
        }
      }
      function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
        revalidatingFetchers.forEach((rf) => {
          let fetcher = state.fetchers.get(rf.key);
          let revalidatingFetcher = getLoadingFetcher(
            void 0,
            fetcher ? fetcher.data : void 0
          );
          state.fetchers.set(rf.key, revalidatingFetcher);
        });
        return new Map(state.fetchers);
      }
      async function fetch2(key, routeId, href2, opts) {
        abortFetcher(key);
        let flushSync = (opts && opts.flushSync) === true;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let normalizedPath = normalizeTo(
          state.location,
          state.matches,
          basename,
          href2,
          routeId,
          opts == null ? void 0 : opts.relative
        );
        let matches = matchRoutes(routesToUse, normalizedPath, basename);
        let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
        if (fogOfWar.active && fogOfWar.matches) {
          matches = fogOfWar.matches;
        }
        if (!matches) {
          setFetcherError(
            key,
            routeId,
            getInternalRouterError(404, { pathname: normalizedPath }),
            { flushSync }
          );
          return;
        }
        let { path, submission, error } = normalizeNavigateOptions(
          true,
          normalizedPath,
          opts
        );
        if (error) {
          setFetcherError(key, routeId, error, { flushSync });
          return;
        }
        let match = getTargetMatch(matches, path);
        let scopedContext = new unstable_RouterContextProvider(
          init.unstable_getContext ? await init.unstable_getContext() : void 0
        );
        let preventScrollReset = (opts && opts.preventScrollReset) === true;
        if (submission && isMutationMethod(submission.formMethod)) {
          await handleFetcherAction(
            key,
            routeId,
            path,
            match,
            matches,
            scopedContext,
            fogOfWar.active,
            flushSync,
            preventScrollReset,
            submission
          );
          return;
        }
        fetchLoadMatches.set(key, { routeId, path });
        await handleFetcherLoader(
          key,
          routeId,
          path,
          match,
          matches,
          scopedContext,
          fogOfWar.active,
          flushSync,
          preventScrollReset,
          submission
        );
      }
      async function handleFetcherAction(key, routeId, path, match, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
        interruptActiveLoads();
        fetchLoadMatches.delete(key);
        function detectAndHandle405Error(m) {
          if (!m.route.action && !m.route.lazy) {
            let error = getInternalRouterError(405, {
              method: submission.formMethod,
              pathname: path,
              routeId
            });
            setFetcherError(key, routeId, error, { flushSync });
            return true;
          }
          return false;
        }
        if (!isFogOfWar && detectAndHandle405Error(match)) {
          return;
        }
        let existingFetcher = state.fetchers.get(key);
        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
          flushSync
        });
        let abortController = new AbortController();
        let fetchRequest = createClientSideRequest(
          init.history,
          path,
          abortController.signal,
          submission
        );
        if (isFogOfWar) {
          let discoverResult = await discoverRoutes(
            requestMatches,
            path,
            fetchRequest.signal,
            key
          );
          if (discoverResult.type === "aborted") {
            return;
          } else if (discoverResult.type === "error") {
            setFetcherError(key, routeId, discoverResult.error, { flushSync });
            return;
          } else if (!discoverResult.matches) {
            setFetcherError(
              key,
              routeId,
              getInternalRouterError(404, { pathname: path }),
              { flushSync }
            );
            return;
          } else {
            requestMatches = discoverResult.matches;
            match = getTargetMatch(requestMatches, path);
            if (detectAndHandle405Error(match)) {
              return;
            }
          }
        }
        fetchControllers.set(key, abortController);
        let originatingLoadId = incrementingLoadId;
        let fetchMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          fetchRequest,
          requestMatches,
          match,
          hydrationRouteProperties2,
          scopedContext
        );
        let actionResults = await callDataStrategy(
          fetchRequest,
          fetchMatches,
          scopedContext,
          key
        );
        let actionResult = actionResults[match.route.id];
        if (fetchRequest.signal.aborted) {
          if (fetchControllers.get(key) === abortController) {
            fetchControllers.delete(key);
          }
          return;
        }
        if (fetchersQueuedForDeletion.has(key)) {
          if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          }
        } else {
          if (isRedirectResult(actionResult)) {
            fetchControllers.delete(key);
            if (pendingNavigationLoadId > originatingLoadId) {
              updateFetcherState(key, getDoneFetcher(void 0));
              return;
            } else {
              fetchRedirectIds.add(key);
              updateFetcherState(key, getLoadingFetcher(submission));
              return startRedirectNavigation(fetchRequest, actionResult, false, {
                fetcherSubmission: submission,
                preventScrollReset
              });
            }
          }
          if (isErrorResult(actionResult)) {
            setFetcherError(key, routeId, actionResult.error);
            return;
          }
        }
        let nextLocation = state.navigation.location || state.location;
        let revalidationRequest = createClientSideRequest(
          init.history,
          nextLocation,
          abortController.signal
        );
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
        invariant(matches, "Didn't find any matches after fetcher action");
        let loadId = ++incrementingLoadId;
        fetchReloadIds.set(key, loadId);
        let loadFetcher = getLoadingFetcher(submission, actionResult.data);
        state.fetchers.set(key, loadFetcher);
        let { dsMatches, revalidatingFetchers } = getMatchesToLoad(
          revalidationRequest,
          scopedContext,
          mapRouteProperties2,
          manifest,
          init.history,
          state,
          matches,
          submission,
          nextLocation,
          hydrationRouteProperties2,
          false,
          isRevalidationRequired,
          cancelledFetcherLoads,
          fetchersQueuedForDeletion,
          fetchLoadMatches,
          fetchRedirectIds,
          routesToUse,
          basename,
          [match.route.id, actionResult]
        );
        revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
          let staleKey = rf.key;
          let existingFetcher2 = state.fetchers.get(staleKey);
          let revalidatingFetcher = getLoadingFetcher(
            void 0,
            existingFetcher2 ? existingFetcher2.data : void 0
          );
          state.fetchers.set(staleKey, revalidatingFetcher);
          abortFetcher(staleKey);
          if (rf.controller) {
            fetchControllers.set(staleKey, rf.controller);
          }
        });
        updateState({ fetchers: new Map(state.fetchers) });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
        abortController.signal.addEventListener(
          "abort",
          abortPendingFetchRevalidations
        );
        let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
          dsMatches,
          revalidatingFetchers,
          revalidationRequest,
          scopedContext
        );
        if (abortController.signal.aborted) {
          return;
        }
        abortController.signal.removeEventListener(
          "abort",
          abortPendingFetchRevalidations
        );
        fetchReloadIds.delete(key);
        fetchControllers.delete(key);
        revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));
        if (state.fetchers.has(key)) {
          let doneFetcher = getDoneFetcher(actionResult.data);
          state.fetchers.set(key, doneFetcher);
        }
        let redirect2 = findRedirect(loaderResults);
        if (redirect2) {
          return startRedirectNavigation(
            revalidationRequest,
            redirect2.result,
            false,
            { preventScrollReset }
          );
        }
        redirect2 = findRedirect(fetcherResults);
        if (redirect2) {
          fetchRedirectIds.add(redirect2.key);
          return startRedirectNavigation(
            revalidationRequest,
            redirect2.result,
            false,
            { preventScrollReset }
          );
        }
        let { loaderData, errors } = processLoaderData(
          state,
          matches,
          loaderResults,
          void 0,
          revalidatingFetchers,
          fetcherResults
        );
        abortStaleFetchLoads(loadId);
        if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
          invariant(pendingAction, "Expected pending action");
          pendingNavigationController && pendingNavigationController.abort();
          completeNavigation(state.navigation.location, {
            matches,
            loaderData,
            errors,
            fetchers: new Map(state.fetchers)
          });
        } else {
          updateState({
            errors,
            loaderData: mergeLoaderData(
              state.loaderData,
              loaderData,
              matches,
              errors
            ),
            fetchers: new Map(state.fetchers)
          });
          isRevalidationRequired = false;
        }
      }
      async function handleFetcherLoader(key, routeId, path, match, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
        let existingFetcher = state.fetchers.get(key);
        updateFetcherState(
          key,
          getLoadingFetcher(
            submission,
            existingFetcher ? existingFetcher.data : void 0
          ),
          { flushSync }
        );
        let abortController = new AbortController();
        let fetchRequest = createClientSideRequest(
          init.history,
          path,
          abortController.signal
        );
        if (isFogOfWar) {
          let discoverResult = await discoverRoutes(
            matches,
            path,
            fetchRequest.signal,
            key
          );
          if (discoverResult.type === "aborted") {
            return;
          } else if (discoverResult.type === "error") {
            setFetcherError(key, routeId, discoverResult.error, { flushSync });
            return;
          } else if (!discoverResult.matches) {
            setFetcherError(
              key,
              routeId,
              getInternalRouterError(404, { pathname: path }),
              { flushSync }
            );
            return;
          } else {
            matches = discoverResult.matches;
            match = getTargetMatch(matches, path);
          }
        }
        fetchControllers.set(key, abortController);
        let originatingLoadId = incrementingLoadId;
        let dsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          fetchRequest,
          matches,
          match,
          hydrationRouteProperties2,
          scopedContext
        );
        let results = await callDataStrategy(
          fetchRequest,
          dsMatches,
          scopedContext,
          key
        );
        let result = results[match.route.id];
        if (fetchControllers.get(key) === abortController) {
          fetchControllers.delete(key);
        }
        if (fetchRequest.signal.aborted) {
          return;
        }
        if (fetchersQueuedForDeletion.has(key)) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        }
        if (isRedirectResult(result)) {
          if (pendingNavigationLoadId > originatingLoadId) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          } else {
            fetchRedirectIds.add(key);
            await startRedirectNavigation(fetchRequest, result, false, {
              preventScrollReset
            });
            return;
          }
        }
        if (isErrorResult(result)) {
          setFetcherError(key, routeId, result.error);
          return;
        }
        updateFetcherState(key, getDoneFetcher(result.data));
      }
      async function startRedirectNavigation(request, redirect2, isNavigation, {
        submission,
        fetcherSubmission,
        preventScrollReset,
        replace: replace2
      } = {}) {
        if (redirect2.response.headers.has("X-Remix-Revalidate")) {
          isRevalidationRequired = true;
        }
        let location = redirect2.response.headers.get("Location");
        invariant(location, "Expected a Location header on the redirect Response");
        location = normalizeRedirectLocation(
          location,
          new URL(request.url),
          basename
        );
        let redirectLocation = createLocation(state.location, location, {
          _isRedirect: true
        });
        if (isBrowser2) {
          let isDocumentReload = false;
          if (redirect2.response.headers.has("X-Remix-Reload-Document")) {
            isDocumentReload = true;
          } else if (ABSOLUTE_URL_REGEX.test(location)) {
            const url = createBrowserURLImpl(location, true);
            isDocumentReload = // Hard reload if it's an absolute URL to a new origin
            url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
            stripBasename(url.pathname, basename) == null;
          }
          if (isDocumentReload) {
            if (replace2) {
              routerWindow.location.replace(location);
            } else {
              routerWindow.location.assign(location);
            }
            return;
          }
        }
        pendingNavigationController = null;
        let redirectNavigationType = replace2 === true || redirect2.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH";
        let { formMethod, formAction, formEncType } = state.navigation;
        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
          submission = getSubmissionFromNavigation(state.navigation);
        }
        let activeSubmission = submission || fetcherSubmission;
        if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
          await startNavigation(redirectNavigationType, redirectLocation, {
            submission: {
              ...activeSubmission,
              formAction: location
            },
            // Preserve these flags across redirects
            preventScrollReset: preventScrollReset || pendingPreventScrollReset,
            enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
          });
        } else {
          let overrideNavigation = getLoadingNavigation(
            redirectLocation,
            submission
          );
          await startNavigation(redirectNavigationType, redirectLocation, {
            overrideNavigation,
            // Send fetcher submissions through for shouldRevalidate
            fetcherSubmission,
            // Preserve these flags across redirects
            preventScrollReset: preventScrollReset || pendingPreventScrollReset,
            enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
          });
        }
      }
      async function callDataStrategy(request, matches, scopedContext, fetcherKey) {
        let results;
        let dataResults = {};
        try {
          results = await callDataStrategyImpl(
            dataStrategyImpl,
            request,
            matches,
            fetcherKey,
            scopedContext,
            false
          );
        } catch (e) {
          matches.filter((m) => m.shouldLoad).forEach((m) => {
            dataResults[m.route.id] = {
              type: "error",
              error: e
            };
          });
          return dataResults;
        }
        if (request.signal.aborted) {
          return dataResults;
        }
        for (let [routeId, result] of Object.entries(results)) {
          if (isRedirectDataStrategyResult(result)) {
            let response = result.result;
            dataResults[routeId] = {
              type: "redirect",
              response: normalizeRelativeRoutingRedirectResponse(
                response,
                request,
                routeId,
                matches,
                basename
              )
            };
          } else {
            dataResults[routeId] = await convertDataStrategyResultToDataResult(
              result
            );
          }
        }
        return dataResults;
      }
      async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {
        let loaderResultsPromise = callDataStrategy(
          request,
          matches,
          scopedContext,
          null
        );
        let fetcherResultsPromise = Promise.all(
          fetchersToLoad.map(async (f2) => {
            if (f2.matches && f2.match && f2.request && f2.controller) {
              let results = await callDataStrategy(
                f2.request,
                f2.matches,
                scopedContext,
                f2.key
              );
              let result = results[f2.match.route.id];
              return { [f2.key]: result };
            } else {
              return Promise.resolve({
                [f2.key]: {
                  type: "error",
                  error: getInternalRouterError(404, {
                    pathname: f2.path
                  })
                }
              });
            }
          })
        );
        let loaderResults = await loaderResultsPromise;
        let fetcherResults = (await fetcherResultsPromise).reduce(
          (acc, r) => Object.assign(acc, r),
          {}
        );
        return {
          loaderResults,
          fetcherResults
        };
      }
      function interruptActiveLoads() {
        isRevalidationRequired = true;
        fetchLoadMatches.forEach((_, key) => {
          if (fetchControllers.has(key)) {
            cancelledFetcherLoads.add(key);
          }
          abortFetcher(key);
        });
      }
      function updateFetcherState(key, fetcher, opts = {}) {
        state.fetchers.set(key, fetcher);
        updateState(
          { fetchers: new Map(state.fetchers) },
          { flushSync: (opts && opts.flushSync) === true }
        );
      }
      function setFetcherError(key, routeId, error, opts = {}) {
        let boundaryMatch = findNearestBoundary(state.matches, routeId);
        deleteFetcher(key);
        updateState(
          {
            errors: {
              [boundaryMatch.route.id]: error
            },
            fetchers: new Map(state.fetchers)
          },
          { flushSync: (opts && opts.flushSync) === true }
        );
      }
      function getFetcher(key) {
        activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
        if (fetchersQueuedForDeletion.has(key)) {
          fetchersQueuedForDeletion.delete(key);
        }
        return state.fetchers.get(key) || IDLE_FETCHER;
      }
      function deleteFetcher(key) {
        let fetcher = state.fetchers.get(key);
        if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
          abortFetcher(key);
        }
        fetchLoadMatches.delete(key);
        fetchReloadIds.delete(key);
        fetchRedirectIds.delete(key);
        fetchersQueuedForDeletion.delete(key);
        cancelledFetcherLoads.delete(key);
        state.fetchers.delete(key);
      }
      function queueFetcherForDeletion(key) {
        let count = (activeFetchers.get(key) || 0) - 1;
        if (count <= 0) {
          activeFetchers.delete(key);
          fetchersQueuedForDeletion.add(key);
        } else {
          activeFetchers.set(key, count);
        }
        updateState({ fetchers: new Map(state.fetchers) });
      }
      function abortFetcher(key) {
        let controller = fetchControllers.get(key);
        if (controller) {
          controller.abort();
          fetchControllers.delete(key);
        }
      }
      function markFetchersDone(keys) {
        for (let key of keys) {
          let fetcher = getFetcher(key);
          let doneFetcher = getDoneFetcher(fetcher.data);
          state.fetchers.set(key, doneFetcher);
        }
      }
      function markFetchRedirectsDone() {
        let doneKeys = [];
        let updatedFetchers = false;
        for (let key of fetchRedirectIds) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, `Expected fetcher: ${key}`);
          if (fetcher.state === "loading") {
            fetchRedirectIds.delete(key);
            doneKeys.push(key);
            updatedFetchers = true;
          }
        }
        markFetchersDone(doneKeys);
        return updatedFetchers;
      }
      function abortStaleFetchLoads(landedId) {
        let yeetedKeys = [];
        for (let [key, id] of fetchReloadIds) {
          if (id < landedId) {
            let fetcher = state.fetchers.get(key);
            invariant(fetcher, `Expected fetcher: ${key}`);
            if (fetcher.state === "loading") {
              abortFetcher(key);
              fetchReloadIds.delete(key);
              yeetedKeys.push(key);
            }
          }
        }
        markFetchersDone(yeetedKeys);
        return yeetedKeys.length > 0;
      }
      function getBlocker(key, fn) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        if (blockerFunctions.get(key) !== fn) {
          blockerFunctions.set(key, fn);
        }
        return blocker;
      }
      function deleteBlocker(key) {
        state.blockers.delete(key);
        blockerFunctions.delete(key);
      }
      function updateBlocker(key, newBlocker) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        invariant(
          blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked",
          `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`
        );
        let blockers = new Map(state.blockers);
        blockers.set(key, newBlocker);
        updateState({ blockers });
      }
      function shouldBlockNavigation({
        currentLocation,
        nextLocation,
        historyAction
      }) {
        if (blockerFunctions.size === 0) {
          return;
        }
        if (blockerFunctions.size > 1) {
          warning(false, "A router only supports one blocker at a time");
        }
        let entries = Array.from(blockerFunctions.entries());
        let [blockerKey, blockerFunction] = entries[entries.length - 1];
        let blocker = state.blockers.get(blockerKey);
        if (blocker && blocker.state === "proceeding") {
          return;
        }
        if (blockerFunction({ currentLocation, nextLocation, historyAction })) {
          return blockerKey;
        }
      }
      function handleNavigational404(pathname) {
        let error = getInternalRouterError(404, { pathname });
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let { matches, route } = getShortCircuitMatches(routesToUse);
        return { notFoundMatches: matches, route, error };
      }
      function enableScrollRestoration(positions, getPosition, getKey) {
        savedScrollPositions2 = positions;
        getScrollPosition = getPosition;
        getScrollRestorationKey2 = getKey || null;
        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
          initialScrollRestored = true;
          let y = getSavedScrollPosition(state.location, state.matches);
          if (y != null) {
            updateState({ restoreScrollPosition: y });
          }
        }
        return () => {
          savedScrollPositions2 = null;
          getScrollPosition = null;
          getScrollRestorationKey2 = null;
        };
      }
      function getScrollKey(location, matches) {
        if (getScrollRestorationKey2) {
          let key = getScrollRestorationKey2(
            location,
            matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))
          );
          return key || location.key;
        }
        return location.key;
      }
      function saveScrollPosition(location, matches) {
        if (savedScrollPositions2 && getScrollPosition) {
          let key = getScrollKey(location, matches);
          savedScrollPositions2[key] = getScrollPosition();
        }
      }
      function getSavedScrollPosition(location, matches) {
        if (savedScrollPositions2) {
          let key = getScrollKey(location, matches);
          let y = savedScrollPositions2[key];
          if (typeof y === "number") {
            return y;
          }
        }
        return null;
      }
      function checkFogOfWar(matches, routesToUse, pathname) {
        if (init.patchRoutesOnNavigation) {
          if (!matches) {
            let fogMatches = matchRoutesImpl(
              routesToUse,
              pathname,
              basename,
              true
            );
            return { active: true, matches: fogMatches || [] };
          } else {
            if (Object.keys(matches[0].params).length > 0) {
              let partialMatches = matchRoutesImpl(
                routesToUse,
                pathname,
                basename,
                true
              );
              return { active: true, matches: partialMatches };
            }
          }
        }
        return { active: false, matches: null };
      }
      async function discoverRoutes(matches, pathname, signal, fetcherKey) {
        if (!init.patchRoutesOnNavigation) {
          return { type: "success", matches };
        }
        let partialMatches = matches;
        while (true) {
          let isNonHMR = inFlightDataRoutes == null;
          let routesToUse = inFlightDataRoutes || dataRoutes;
          let localManifest = manifest;
          try {
            await init.patchRoutesOnNavigation({
              signal,
              path: pathname,
              matches: partialMatches,
              fetcherKey,
              patch: (routeId, children) => {
                if (signal.aborted) return;
                patchRoutesImpl(
                  routeId,
                  children,
                  routesToUse,
                  localManifest,
                  mapRouteProperties2
                );
              }
            });
          } catch (e) {
            return { type: "error", error: e, partialMatches };
          } finally {
            if (isNonHMR && !signal.aborted) {
              dataRoutes = [...dataRoutes];
            }
          }
          if (signal.aborted) {
            return { type: "aborted" };
          }
          let newMatches = matchRoutes(routesToUse, pathname, basename);
          if (newMatches) {
            return { type: "success", matches: newMatches };
          }
          let newPartialMatches = matchRoutesImpl(
            routesToUse,
            pathname,
            basename,
            true
          );
          if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(
            (m, i) => m.route.id === newPartialMatches[i].route.id
          )) {
            return { type: "success", matches: null };
          }
          partialMatches = newPartialMatches;
        }
      }
      function _internalSetRoutes(newRoutes) {
        manifest = {};
        inFlightDataRoutes = convertRoutesToDataRoutes(
          newRoutes,
          mapRouteProperties2,
          void 0,
          manifest
        );
      }
      function patchRoutes(routeId, children) {
        let isNonHMR = inFlightDataRoutes == null;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        patchRoutesImpl(
          routeId,
          children,
          routesToUse,
          manifest,
          mapRouteProperties2
        );
        if (isNonHMR) {
          dataRoutes = [...dataRoutes];
          updateState({});
        }
      }
      router = {
        get basename() {
          return basename;
        },
        get future() {
          return future;
        },
        get state() {
          return state;
        },
        get routes() {
          return dataRoutes;
        },
        get window() {
          return routerWindow;
        },
        initialize: initialize3,
        subscribe: subscribe2,
        enableScrollRestoration,
        navigate,
        fetch: fetch2,
        revalidate,
        // Passthrough to history-aware createHref used by useHref so we get proper
        // hash-aware URLs in DOM paths
        createHref: (to) => init.history.createHref(to),
        encodeLocation: (to) => init.history.encodeLocation(to),
        getFetcher,
        deleteFetcher: queueFetcherForDeletion,
        dispose,
        getBlocker,
        deleteBlocker,
        patchRoutes,
        _internalFetchControllers: fetchControllers,
        // TODO: Remove setRoutes, it's temporary to avoid dealing with
        // updating the tree while validating the update algorithm.
        _internalSetRoutes
      };
      return router;
    }
    function createStaticHandler(routes, opts) {
      invariant(
        routes.length > 0,
        "You must provide a non-empty routes array to createStaticHandler"
      );
      let manifest = {};
      let basename = (opts ? opts.basename : null) || "/";
      let mapRouteProperties2 = (opts == null ? void 0 : opts.mapRouteProperties) || defaultMapRouteProperties;
      let dataRoutes = convertRoutesToDataRoutes(
        routes,
        mapRouteProperties2,
        void 0,
        manifest
      );
      async function query(request, {
        requestContext,
        filterMatchesToLoad,
        skipLoaderErrorBubbling,
        skipRevalidation,
        dataStrategy,
        unstable_respond: respond
      } = {}) {
        let url = new URL(request.url);
        let method = request.method;
        let location = createLocation("", createPath(url), null, "default");
        let matches = matchRoutes(dataRoutes, location, basename);
        requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();
        if (!isValidMethod(method) && method !== "HEAD") {
          let error = getInternalRouterError(405, { method });
          let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);
          let staticContext = {
            basename,
            location,
            matches: methodNotAllowedMatches,
            loaderData: {},
            actionData: null,
            errors: {
              [route.id]: error
            },
            statusCode: error.status,
            loaderHeaders: {},
            actionHeaders: {}
          };
          return respond ? respond(staticContext) : staticContext;
        } else if (!matches) {
          let error = getInternalRouterError(404, { pathname: location.pathname });
          let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);
          let staticContext = {
            basename,
            location,
            matches: notFoundMatches,
            loaderData: {},
            actionData: null,
            errors: {
              [route.id]: error
            },
            statusCode: error.status,
            loaderHeaders: {},
            actionHeaders: {}
          };
          return respond ? respond(staticContext) : staticContext;
        }
        if (respond && matches.some(
          (m) => m.route.unstable_middleware || typeof m.route.lazy === "object" && m.route.lazy.unstable_middleware
        )) {
          invariant(
            requestContext instanceof unstable_RouterContextProvider,
            "When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`"
          );
          try {
            await loadLazyMiddlewareForMatches(
              matches,
              manifest,
              mapRouteProperties2
            );
            let renderedStaticContext;
            let response = await runMiddlewarePipeline(
              {
                request,
                matches,
                params: matches[0].params,
                // If we're calling middleware then it must be enabled so we can cast
                // this to the proper type knowing it's not an `AppLoadContext`
                context: requestContext
              },
              true,
              async () => {
                let result2 = await queryImpl(
                  request,
                  location,
                  matches,
                  requestContext,
                  dataStrategy || null,
                  skipLoaderErrorBubbling === true,
                  null,
                  filterMatchesToLoad || null,
                  skipRevalidation === true
                );
                if (isResponse(result2)) {
                  return result2;
                }
                renderedStaticContext = { location, basename, ...result2 };
                let res = await respond(renderedStaticContext);
                return res;
              },
              async (error, routeId) => {
                var _a;
                if (isResponse(error)) {
                  return error;
                }
                if (renderedStaticContext) {
                  if (routeId in renderedStaticContext.loaderData) {
                    renderedStaticContext.loaderData[routeId] = void 0;
                  }
                  return respond(
                    getStaticContextFromError(
                      dataRoutes,
                      renderedStaticContext,
                      error,
                      skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, routeId).route.id
                    )
                  );
                } else {
                  let boundaryRouteId = skipLoaderErrorBubbling ? routeId : findNearestBoundary(
                    matches,
                    ((_a = matches.find(
                      (m) => m.route.id === routeId || m.route.loader
                    )) == null ? void 0 : _a.route.id) || routeId
                  ).route.id;
                  return respond({
                    matches,
                    location,
                    basename,
                    loaderData: {},
                    actionData: null,
                    errors: {
                      [boundaryRouteId]: error
                    },
                    statusCode: isRouteErrorResponse(error) ? error.status : 500,
                    actionHeaders: {},
                    loaderHeaders: {}
                  });
                }
              }
            );
            invariant(isResponse(response), "Expected a response in query()");
            return response;
          } catch (e) {
            if (isResponse(e)) {
              return e;
            }
            throw e;
          }
        }
        let result = await queryImpl(
          request,
          location,
          matches,
          requestContext,
          dataStrategy || null,
          skipLoaderErrorBubbling === true,
          null,
          filterMatchesToLoad || null,
          skipRevalidation === true
        );
        if (isResponse(result)) {
          return result;
        }
        return { location, basename, ...result };
      }
      async function queryRoute(request, {
        routeId,
        requestContext,
        dataStrategy,
        unstable_respond: respond
      } = {}) {
        let url = new URL(request.url);
        let method = request.method;
        let location = createLocation("", createPath(url), null, "default");
        let matches = matchRoutes(dataRoutes, location, basename);
        requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();
        if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
          throw getInternalRouterError(405, { method });
        } else if (!matches) {
          throw getInternalRouterError(404, { pathname: location.pathname });
        }
        let match = routeId ? matches.find((m) => m.route.id === routeId) : getTargetMatch(matches, location);
        if (routeId && !match) {
          throw getInternalRouterError(403, {
            pathname: location.pathname,
            routeId
          });
        } else if (!match) {
          throw getInternalRouterError(404, { pathname: location.pathname });
        }
        if (respond && matches.some(
          (m) => m.route.unstable_middleware || typeof m.route.lazy === "object" && m.route.lazy.unstable_middleware
        )) {
          invariant(
            requestContext instanceof unstable_RouterContextProvider,
            "When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`"
          );
          await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);
          let response = await runMiddlewarePipeline(
            {
              request,
              matches,
              params: matches[0].params,
              // If we're calling middleware then it must be enabled so we can cast
              // this to the proper type knowing it's not an `AppLoadContext`
              context: requestContext
            },
            true,
            async () => {
              let result2 = await queryImpl(
                request,
                location,
                matches,
                requestContext,
                dataStrategy || null,
                false,
                match,
                null,
                false
              );
              if (isResponse(result2)) {
                return respond(result2);
              }
              let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;
              if (error2 !== void 0) {
                throw error2;
              }
              let value = result2.actionData ? Object.values(result2.actionData)[0] : Object.values(result2.loaderData)[0];
              return typeof value === "string" ? new Response(value) : Response.json(value);
            },
            (error2) => {
              if (isResponse(error2)) {
                return respond(error2);
              }
              return new Response(String(error2), {
                status: 500,
                statusText: "Unexpected Server Error"
              });
            }
          );
          return response;
        }
        let result = await queryImpl(
          request,
          location,
          matches,
          requestContext,
          dataStrategy || null,
          false,
          match,
          null,
          false
        );
        if (isResponse(result)) {
          return result;
        }
        let error = result.errors ? Object.values(result.errors)[0] : void 0;
        if (error !== void 0) {
          throw error;
        }
        if (result.actionData) {
          return Object.values(result.actionData)[0];
        }
        if (result.loaderData) {
          return Object.values(result.loaderData)[0];
        }
        return void 0;
      }
      async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {
        invariant(
          request.signal,
          "query()/queryRoute() requests must contain an AbortController signal"
        );
        try {
          if (isMutationMethod(request.method)) {
            let result2 = await submit(
              request,
              matches,
              routeMatch || getTargetMatch(matches, location),
              requestContext,
              dataStrategy,
              skipLoaderErrorBubbling,
              routeMatch != null,
              filterMatchesToLoad,
              skipRevalidation
            );
            return result2;
          }
          let result = await loadRouteData(
            request,
            matches,
            requestContext,
            dataStrategy,
            skipLoaderErrorBubbling,
            routeMatch,
            filterMatchesToLoad
          );
          return isResponse(result) ? result : {
            ...result,
            actionData: null,
            actionHeaders: {}
          };
        } catch (e) {
          if (isDataStrategyResult(e) && isResponse(e.result)) {
            if (e.type === "error") {
              throw e.result;
            }
            return e.result;
          }
          if (isRedirectResponse(e)) {
            return e;
          }
          throw e;
        }
      }
      async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {
        let result;
        if (!actionMatch.route.action && !actionMatch.route.lazy) {
          let error = getInternalRouterError(405, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: actionMatch.route.id
          });
          if (isRouteRequest) {
            throw error;
          }
          result = {
            type: "error",
            error
          };
        } else {
          let dsMatches = getTargetedDataStrategyMatches(
            mapRouteProperties2,
            manifest,
            request,
            matches,
            actionMatch,
            [],
            requestContext
          );
          let results = await callDataStrategy(
            request,
            dsMatches,
            isRouteRequest,
            requestContext,
            dataStrategy
          );
          result = results[actionMatch.route.id];
          if (request.signal.aborted) {
            throwStaticHandlerAbortedError(request, isRouteRequest);
          }
        }
        if (isRedirectResult(result)) {
          throw new Response(null, {
            status: result.response.status,
            headers: {
              Location: result.response.headers.get("Location")
            }
          });
        }
        if (isRouteRequest) {
          if (isErrorResult(result)) {
            throw result.error;
          }
          return {
            matches: [actionMatch],
            loaderData: {},
            actionData: { [actionMatch.route.id]: result.data },
            errors: null,
            // Note: statusCode + headers are unused here since queryRoute will
            // return the raw Response or value
            statusCode: 200,
            loaderHeaders: {},
            actionHeaders: {}
          };
        }
        if (skipRevalidation) {
          if (isErrorResult(result)) {
            let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);
            return {
              statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
              actionData: null,
              actionHeaders: {
                ...result.headers ? { [actionMatch.route.id]: result.headers } : {}
              },
              matches,
              loaderData: {},
              errors: {
                [boundaryMatch.route.id]: result.error
              },
              loaderHeaders: {}
            };
          } else {
            return {
              actionData: {
                [actionMatch.route.id]: result.data
              },
              actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {},
              matches,
              loaderData: {},
              errors: null,
              statusCode: result.statusCode || 200,
              loaderHeaders: {}
            };
          }
        }
        let loaderRequest = new Request(request.url, {
          headers: request.headers,
          redirect: request.redirect,
          signal: request.signal
        });
        if (isErrorResult(result)) {
          let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);
          let handlerContext2 = await loadRouteData(
            loaderRequest,
            matches,
            requestContext,
            dataStrategy,
            skipLoaderErrorBubbling,
            null,
            filterMatchesToLoad,
            [boundaryMatch.route.id, result]
          );
          return {
            ...handlerContext2,
            statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
            actionData: null,
            actionHeaders: {
              ...result.headers ? { [actionMatch.route.id]: result.headers } : {}
            }
          };
        }
        let handlerContext = await loadRouteData(
          loaderRequest,
          matches,
          requestContext,
          dataStrategy,
          skipLoaderErrorBubbling,
          null,
          filterMatchesToLoad
        );
        return {
          ...handlerContext,
          actionData: {
            [actionMatch.route.id]: result.data
          },
          // action status codes take precedence over loader status codes
          ...result.statusCode ? { statusCode: result.statusCode } : {},
          actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {}
        };
      }
      async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {
        let isRouteRequest = routeMatch != null;
        if (isRouteRequest && !(routeMatch == null ? void 0 : routeMatch.route.loader) && !(routeMatch == null ? void 0 : routeMatch.route.lazy)) {
          throw getInternalRouterError(400, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: routeMatch == null ? void 0 : routeMatch.route.id
          });
        }
        let dsMatches;
        if (routeMatch) {
          dsMatches = getTargetedDataStrategyMatches(
            mapRouteProperties2,
            manifest,
            request,
            matches,
            routeMatch,
            [],
            requestContext
          );
        } else {
          let maxIdx = pendingActionResult && isErrorResult(pendingActionResult[1]) ? (
            // Up to but not including the boundary
            matches.findIndex((m) => m.route.id === pendingActionResult[0]) - 1
          ) : void 0;
          dsMatches = matches.map((match, index) => {
            if (maxIdx != null && index > maxIdx) {
              return getDataStrategyMatch(
                mapRouteProperties2,
                manifest,
                request,
                match,
                [],
                requestContext,
                false
              );
            }
            return getDataStrategyMatch(
              mapRouteProperties2,
              manifest,
              request,
              match,
              [],
              requestContext,
              (match.route.loader || match.route.lazy) != null && (!filterMatchesToLoad || filterMatchesToLoad(match))
            );
          });
        }
        if (!dataStrategy && !dsMatches.some((m) => m.shouldLoad)) {
          return {
            matches,
            loaderData: {},
            errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
              [pendingActionResult[0]]: pendingActionResult[1].error
            } : null,
            statusCode: 200,
            loaderHeaders: {}
          };
        }
        let results = await callDataStrategy(
          request,
          dsMatches,
          isRouteRequest,
          requestContext,
          dataStrategy
        );
        if (request.signal.aborted) {
          throwStaticHandlerAbortedError(request, isRouteRequest);
        }
        let handlerContext = processRouteLoaderData(
          matches,
          results,
          pendingActionResult,
          true,
          skipLoaderErrorBubbling
        );
        return {
          ...handlerContext,
          matches
        };
      }
      async function callDataStrategy(request, matches, isRouteRequest, requestContext, dataStrategy) {
        let results = await callDataStrategyImpl(
          dataStrategy || defaultDataStrategy,
          request,
          matches,
          null,
          requestContext,
          true
        );
        let dataResults = {};
        await Promise.all(
          matches.map(async (match) => {
            if (!(match.route.id in results)) {
              return;
            }
            let result = results[match.route.id];
            if (isRedirectDataStrategyResult(result)) {
              let response = result.result;
              throw normalizeRelativeRoutingRedirectResponse(
                response,
                request,
                match.route.id,
                matches,
                basename
              );
            }
            if (isResponse(result.result) && isRouteRequest) {
              throw result;
            }
            dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);
          })
        );
        return dataResults;
      }
      return {
        dataRoutes,
        query,
        queryRoute
      };
    }
    function getStaticContextFromError(routes, handlerContext, error, boundaryId) {
      let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;
      return {
        ...handlerContext,
        statusCode: isRouteErrorResponse(error) ? error.status : 500,
        errors: {
          [errorBoundaryId]: error
        }
      };
    }
    function throwStaticHandlerAbortedError(request, isRouteRequest) {
      if (request.signal.reason !== void 0) {
        throw request.signal.reason;
      }
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(
        `${method}() call aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`
      );
    }
    function isSubmissionNavigation(opts) {
      return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
    }
    function normalizeTo(location, matches, basename, to, fromRouteId, relative) {
      let contextualMatches;
      let activeRouteMatch;
      if (fromRouteId) {
        contextualMatches = [];
        for (let match of matches) {
          contextualMatches.push(match);
          if (match.route.id === fromRouteId) {
            activeRouteMatch = match;
            break;
          }
        }
      } else {
        contextualMatches = matches;
        activeRouteMatch = matches[matches.length - 1];
      }
      let path = resolveTo(
        to ? to : ".",
        getResolveToMatches(contextualMatches),
        stripBasename(location.pathname, basename) || location.pathname,
        relative === "path"
      );
      if (to == null) {
        path.search = location.search;
        path.hash = location.hash;
      }
      if ((to == null || to === "" || to === ".") && activeRouteMatch) {
        let nakedIndex = hasNakedIndexQuery(path.search);
        if (activeRouteMatch.route.index && !nakedIndex) {
          path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
        } else if (!activeRouteMatch.route.index && nakedIndex) {
          let params = new URLSearchParams(path.search);
          let indexValues = params.getAll("index");
          params.delete("index");
          indexValues.filter((v) => v).forEach((v) => params.append("index", v));
          let qs = params.toString();
          path.search = qs ? `?${qs}` : "";
        }
      }
      if (basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      return createPath(path);
    }
    function normalizeNavigateOptions(isFetcher, path, opts) {
      if (!opts || !isSubmissionNavigation(opts)) {
        return { path };
      }
      if (opts.formMethod && !isValidMethod(opts.formMethod)) {
        return {
          path,
          error: getInternalRouterError(405, { method: opts.formMethod })
        };
      }
      let getInvalidBodyError = () => ({
        path,
        error: getInternalRouterError(400, { type: "invalid-body" })
      });
      let rawFormMethod = opts.formMethod || "get";
      let formMethod = rawFormMethod.toUpperCase();
      let formAction = stripHashFromPath(path);
      if (opts.body !== void 0) {
        if (opts.formEncType === "text/plain") {
          if (!isMutationMethod(formMethod)) {
            return getInvalidBodyError();
          }
          let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
            // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
            Array.from(opts.body.entries()).reduce(
              (acc, [name, value]) => `${acc}${name}=${value}
`,
              ""
            )
          ) : String(opts.body);
          return {
            path,
            submission: {
              formMethod,
              formAction,
              formEncType: opts.formEncType,
              formData: void 0,
              json: void 0,
              text
            }
          };
        } else if (opts.formEncType === "application/json") {
          if (!isMutationMethod(formMethod)) {
            return getInvalidBodyError();
          }
          try {
            let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
            return {
              path,
              submission: {
                formMethod,
                formAction,
                formEncType: opts.formEncType,
                formData: void 0,
                json,
                text: void 0
              }
            };
          } catch (e) {
            return getInvalidBodyError();
          }
        }
      }
      invariant(
        typeof FormData === "function",
        "FormData is not available in this environment"
      );
      let searchParams;
      let formData;
      if (opts.formData) {
        searchParams = convertFormDataToSearchParams(opts.formData);
        formData = opts.formData;
      } else if (opts.body instanceof FormData) {
        searchParams = convertFormDataToSearchParams(opts.body);
        formData = opts.body;
      } else if (opts.body instanceof URLSearchParams) {
        searchParams = opts.body;
        formData = convertSearchParamsToFormData(searchParams);
      } else if (opts.body == null) {
        searchParams = new URLSearchParams();
        formData = new FormData();
      } else {
        try {
          searchParams = new URLSearchParams(opts.body);
          formData = convertSearchParamsToFormData(searchParams);
        } catch (e) {
          return getInvalidBodyError();
        }
      }
      let submission = {
        formMethod,
        formAction,
        formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
        formData,
        json: void 0,
        text: void 0
      };
      if (isMutationMethod(submission.formMethod)) {
        return { path, submission };
      }
      let parsedPath = parsePath(path);
      if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
        searchParams.append("index", "");
      }
      parsedPath.search = `?${searchParams}`;
      return { path: createPath(parsedPath), submission };
    }
    function getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
      var _a;
      let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
      let currentUrl = history.createURL(state.location);
      let nextUrl = history.createURL(location);
      let maxIdx;
      if (initialHydration && state.errors) {
        let boundaryId = Object.keys(state.errors)[0];
        maxIdx = matches.findIndex((m) => m.route.id === boundaryId);
      } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
        let boundaryId = pendingActionResult[0];
        maxIdx = matches.findIndex((m) => m.route.id === boundaryId) - 1;
      }
      let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
      let shouldSkipRevalidation = actionStatus && actionStatus >= 400;
      let baseShouldRevalidateArgs = {
        currentUrl,
        currentParams: ((_a = state.matches[0]) == null ? void 0 : _a.params) || {},
        nextUrl,
        nextParams: matches[0].params,
        ...submission,
        actionResult,
        actionStatus
      };
      let dsMatches = matches.map((match, index) => {
        let { route } = match;
        let forceShouldLoad = null;
        if (maxIdx != null && index > maxIdx) {
          forceShouldLoad = false;
        } else if (route.lazy) {
          forceShouldLoad = true;
        } else if (route.loader == null) {
          forceShouldLoad = false;
        } else if (initialHydration) {
          forceShouldLoad = shouldLoadRouteOnHydration(
            route,
            state.loaderData,
            state.errors
          );
        } else if (isNewLoader(state.loaderData, state.matches[index], match)) {
          forceShouldLoad = true;
        }
        if (forceShouldLoad !== null) {
          return getDataStrategyMatch(
            mapRouteProperties2,
            manifest,
            request,
            match,
            lazyRoutePropertiesToSkip,
            scopedContext,
            forceShouldLoad
          );
        }
        let defaultShouldRevalidate = shouldSkipRevalidation ? false : (
          // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
          isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
          currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match)
        );
        let shouldRevalidateArgs = {
          ...baseShouldRevalidateArgs,
          defaultShouldRevalidate
        };
        let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);
        return getDataStrategyMatch(
          mapRouteProperties2,
          manifest,
          request,
          match,
          lazyRoutePropertiesToSkip,
          scopedContext,
          shouldLoad,
          shouldRevalidateArgs
        );
      });
      let revalidatingFetchers = [];
      fetchLoadMatches.forEach((f2, key) => {
        if (initialHydration || !matches.some((m) => m.route.id === f2.routeId) || fetchersQueuedForDeletion.has(key)) {
          return;
        }
        let fetcherMatches = matchRoutes(routesToUse, f2.path, basename);
        if (!fetcherMatches) {
          revalidatingFetchers.push({
            key,
            routeId: f2.routeId,
            path: f2.path,
            matches: null,
            match: null,
            request: null,
            controller: null
          });
          return;
        }
        if (fetchRedirectIds.has(key)) {
          return;
        }
        let fetcher = state.fetchers.get(key);
        let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
        let fetchController = new AbortController();
        let fetchRequest = createClientSideRequest(
          history,
          f2.path,
          fetchController.signal
        );
        let fetcherDsMatches = null;
        if (cancelledFetcherLoads.has(key)) {
          cancelledFetcherLoads.delete(key);
          fetcherDsMatches = getTargetedDataStrategyMatches(
            mapRouteProperties2,
            manifest,
            fetchRequest,
            fetcherMatches,
            fetcherMatch,
            lazyRoutePropertiesToSkip,
            scopedContext
          );
        } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
          if (isRevalidationRequired) {
            fetcherDsMatches = getTargetedDataStrategyMatches(
              mapRouteProperties2,
              manifest,
              fetchRequest,
              fetcherMatches,
              fetcherMatch,
              lazyRoutePropertiesToSkip,
              scopedContext
            );
          }
        } else {
          let shouldRevalidateArgs = {
            ...baseShouldRevalidateArgs,
            defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
          };
          if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {
            fetcherDsMatches = getTargetedDataStrategyMatches(
              mapRouteProperties2,
              manifest,
              fetchRequest,
              fetcherMatches,
              fetcherMatch,
              lazyRoutePropertiesToSkip,
              scopedContext,
              shouldRevalidateArgs
            );
          }
        }
        if (fetcherDsMatches) {
          revalidatingFetchers.push({
            key,
            routeId: f2.routeId,
            path: f2.path,
            matches: fetcherDsMatches,
            match: fetcherMatch,
            request: fetchRequest,
            controller: fetchController
          });
        }
      });
      return { dsMatches, revalidatingFetchers };
    }
    function shouldLoadRouteOnHydration(route, loaderData, errors) {
      if (route.lazy) {
        return true;
      }
      if (!route.loader) {
        return false;
      }
      let hasData = loaderData != null && route.id in loaderData;
      let hasError = errors != null && errors[route.id] !== void 0;
      if (!hasData && hasError) {
        return false;
      }
      if (typeof route.loader === "function" && route.loader.hydrate === true) {
        return true;
      }
      return !hasData && !hasError;
    }
    function isNewLoader(currentLoaderData, currentMatch, match) {
      let isNew = (
        // [a] -> [a, b]
        !currentMatch || // [a, b] -> [a, c]
        match.route.id !== currentMatch.route.id
      );
      let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);
      return isNew || isMissingData;
    }
    function isNewRouteInstance(currentMatch, match) {
      let currentPath = currentMatch.route.path;
      return (
        // param change for this match, /users/123 -> /users/456
        currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
      );
    }
    function shouldRevalidateLoader(loaderMatch, arg) {
      if (loaderMatch.route.shouldRevalidate) {
        let routeChoice = loaderMatch.route.shouldRevalidate(arg);
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return arg.defaultShouldRevalidate;
    }
    function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
      let childrenToPatch;
      if (routeId) {
        let route = manifest[routeId];
        invariant(
          route,
          `No route found to patch children into: routeId = ${routeId}`
        );
        if (!route.children) {
          route.children = [];
        }
        childrenToPatch = route.children;
      } else {
        childrenToPatch = routesToUse;
      }
      let uniqueChildren = children.filter(
        (newRoute) => !childrenToPatch.some(
          (existingRoute) => isSameRoute(newRoute, existingRoute)
        )
      );
      let newRoutes = convertRoutesToDataRoutes(
        uniqueChildren,
        mapRouteProperties2,
        [routeId || "_", "patch", String((childrenToPatch == null ? void 0 : childrenToPatch.length) || "0")],
        manifest
      );
      childrenToPatch.push(...newRoutes);
    }
    function isSameRoute(newRoute, existingRoute) {
      if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
        return true;
      }
      if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
        return false;
      }
      if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
        return true;
      }
      return newRoute.children.every(
        (aChild, i) => {
          var _a;
          return (_a = existingRoute.children) == null ? void 0 : _a.some((bChild) => isSameRoute(aChild, bChild));
        }
      );
    }
    var lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();
    var loadLazyRouteProperty = ({
      key,
      route,
      manifest,
      mapRouteProperties: mapRouteProperties2
    }) => {
      let routeToUpdate = manifest[route.id];
      invariant(routeToUpdate, "No route found in manifest");
      if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== "object") {
        return;
      }
      let lazyFn = routeToUpdate.lazy[key];
      if (!lazyFn) {
        return;
      }
      let cache = lazyRoutePropertyCache.get(routeToUpdate);
      if (!cache) {
        cache = {};
        lazyRoutePropertyCache.set(routeToUpdate, cache);
      }
      let cachedPromise = cache[key];
      if (cachedPromise) {
        return cachedPromise;
      }
      let propertyPromise = (async () => {
        let isUnsupported = isUnsupportedLazyRouteObjectKey(key);
        let staticRouteValue = routeToUpdate[key];
        let isStaticallyDefined = staticRouteValue !== void 0 && key !== "hasErrorBoundary";
        if (isUnsupported) {
          warning(
            !isUnsupported,
            "Route property " + key + " is not a supported lazy route property. This property will be ignored."
          );
          cache[key] = Promise.resolve();
        } else if (isStaticallyDefined) {
          warning(
            false,
            `Route "${routeToUpdate.id}" has a static property "${key}" defined. The lazy property will be ignored.`
          );
        } else {
          let value = await lazyFn();
          if (value != null) {
            Object.assign(routeToUpdate, { [key]: value });
            Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));
          }
        }
        if (typeof routeToUpdate.lazy === "object") {
          routeToUpdate.lazy[key] = void 0;
          if (Object.values(routeToUpdate.lazy).every((value) => value === void 0)) {
            routeToUpdate.lazy = void 0;
          }
        }
      })();
      cache[key] = propertyPromise;
      return propertyPromise;
    };
    var lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();
    function loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {
      let routeToUpdate = manifest[route.id];
      invariant(routeToUpdate, "No route found in manifest");
      if (!route.lazy) {
        return {
          lazyRoutePromise: void 0,
          lazyHandlerPromise: void 0
        };
      }
      if (typeof route.lazy === "function") {
        let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);
        if (cachedPromise) {
          return {
            lazyRoutePromise: cachedPromise,
            lazyHandlerPromise: cachedPromise
          };
        }
        let lazyRoutePromise2 = (async () => {
          invariant(
            typeof route.lazy === "function",
            "No lazy route function found"
          );
          let lazyRoute = await route.lazy();
          let routeUpdates = {};
          for (let lazyRouteProperty in lazyRoute) {
            let lazyValue = lazyRoute[lazyRouteProperty];
            if (lazyValue === void 0) {
              continue;
            }
            let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);
            let staticRouteValue = routeToUpdate[lazyRouteProperty];
            let isStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
            // on the route updates
            lazyRouteProperty !== "hasErrorBoundary";
            if (isUnsupported) {
              warning(
                !isUnsupported,
                "Route property " + lazyRouteProperty + " is not a supported property to be returned from a lazy route function. This property will be ignored."
              );
            } else if (isStaticallyDefined) {
              warning(
                !isStaticallyDefined,
                `Route "${routeToUpdate.id}" has a static property "${lazyRouteProperty}" defined but its lazy function is also returning a value for this property. The lazy route property "${lazyRouteProperty}" will be ignored.`
              );
            } else {
              routeUpdates[lazyRouteProperty] = lazyValue;
            }
          }
          Object.assign(routeToUpdate, routeUpdates);
          Object.assign(routeToUpdate, {
            // To keep things framework agnostic, we use the provided `mapRouteProperties`
            // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
            // since the logic will differ between frameworks.
            ...mapRouteProperties2(routeToUpdate),
            lazy: void 0
          });
        })();
        lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);
        lazyRoutePromise2.catch(() => {
        });
        return {
          lazyRoutePromise: lazyRoutePromise2,
          lazyHandlerPromise: lazyRoutePromise2
        };
      }
      let lazyKeys = Object.keys(route.lazy);
      let lazyPropertyPromises = [];
      let lazyHandlerPromise = void 0;
      for (let key of lazyKeys) {
        if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key)) {
          continue;
        }
        let promise = loadLazyRouteProperty({
          key,
          route,
          manifest,
          mapRouteProperties: mapRouteProperties2
        });
        if (promise) {
          lazyPropertyPromises.push(promise);
          if (key === type) {
            lazyHandlerPromise = promise;
          }
        }
      }
      let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(() => {
      }) : void 0;
      lazyRoutePromise == null ? void 0 : lazyRoutePromise.catch(() => {
      });
      lazyHandlerPromise == null ? void 0 : lazyHandlerPromise.catch(() => {
      });
      return {
        lazyRoutePromise,
        lazyHandlerPromise
      };
    }
    function isNonNullable(value) {
      return value !== void 0;
    }
    function loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2) {
      let promises = matches.map(({ route }) => {
        if (typeof route.lazy !== "object" || !route.lazy.unstable_middleware) {
          return void 0;
        }
        return loadLazyRouteProperty({
          key: "unstable_middleware",
          route,
          manifest,
          mapRouteProperties: mapRouteProperties2
        });
      }).filter(isNonNullable);
      return promises.length > 0 ? Promise.all(promises) : void 0;
    }
    async function defaultDataStrategy(args) {
      let matchesToLoad = args.matches.filter((m) => m.shouldLoad);
      let keyedResults = {};
      let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));
      results.forEach((result, i) => {
        keyedResults[matchesToLoad[i].route.id] = result;
      });
      return keyedResults;
    }
    async function defaultDataStrategyWithMiddleware(args) {
      if (!args.matches.some((m) => m.route.unstable_middleware)) {
        return defaultDataStrategy(args);
      }
      return runMiddlewarePipeline(
        args,
        false,
        () => defaultDataStrategy(args),
        (error, routeId) => ({ [routeId]: { type: "error", result: error } })
      );
    }
    async function runMiddlewarePipeline(args, propagateResult, handler, errorHandler2) {
      let { matches, request, params, context } = args;
      let middlewareState = {
        handlerResult: void 0
      };
      try {
        let tuples = matches.flatMap(
          (m) => m.route.unstable_middleware ? m.route.unstable_middleware.map((fn) => [m.route.id, fn]) : []
        );
        let result = await callRouteMiddleware(
          { request, params, context },
          tuples,
          propagateResult,
          middlewareState,
          handler
        );
        return propagateResult ? result : middlewareState.handlerResult;
      } catch (e) {
        if (!middlewareState.middlewareError) {
          throw e;
        }
        let result = await errorHandler2(
          middlewareState.middlewareError.error,
          middlewareState.middlewareError.routeId
        );
        if (propagateResult || !middlewareState.handlerResult) {
          return result;
        }
        return Object.assign(middlewareState.handlerResult, result);
      }
    }
    async function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {
      let { request } = args;
      if (request.signal.aborted) {
        if (request.signal.reason) {
          throw request.signal.reason;
        }
        throw new Error(
          `Request aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`
        );
      }
      let tuple = middlewares[idx];
      if (!tuple) {
        middlewareState.handlerResult = await handler();
        return middlewareState.handlerResult;
      }
      let [routeId, middleware] = tuple;
      let nextCalled = false;
      let nextResult = void 0;
      let next = async () => {
        if (nextCalled) {
          throw new Error("You may only call `next()` once per middleware");
        }
        nextCalled = true;
        let result = await callRouteMiddleware(
          args,
          middlewares,
          propagateResult,
          middlewareState,
          handler,
          idx + 1
        );
        if (propagateResult) {
          nextResult = result;
          return nextResult;
        }
      };
      try {
        let result = await middleware(
          {
            request: args.request,
            params: args.params,
            context: args.context
          },
          next
        );
        if (nextCalled) {
          if (result === void 0) {
            return nextResult;
          } else {
            return result;
          }
        } else {
          return next();
        }
      } catch (error) {
        if (!middlewareState.middlewareError) {
          middlewareState.middlewareError = { routeId, error };
        } else if (middlewareState.middlewareError.error !== error) {
          middlewareState.middlewareError = { routeId, error };
        }
        throw error;
      }
    }
    function getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {
      let lazyMiddlewarePromise = loadLazyRouteProperty({
        key: "unstable_middleware",
        route: match.route,
        manifest,
        mapRouteProperties: mapRouteProperties2
      });
      let lazyRoutePromises = loadLazyRoute(
        match.route,
        isMutationMethod(request.method) ? "action" : "loader",
        manifest,
        mapRouteProperties2,
        lazyRoutePropertiesToSkip
      );
      return {
        middleware: lazyMiddlewarePromise,
        route: lazyRoutePromises.lazyRoutePromise,
        handler: lazyRoutePromises.lazyHandlerPromise
      };
    }
    function getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {
      let isUsingNewApi = false;
      let _lazyPromises = getDataStrategyMatchLazyPromises(
        mapRouteProperties2,
        manifest,
        request,
        match,
        lazyRoutePropertiesToSkip
      );
      return {
        ...match,
        _lazyPromises,
        shouldLoad,
        unstable_shouldRevalidateArgs,
        unstable_shouldCallHandler(defaultShouldRevalidate) {
          isUsingNewApi = true;
          if (!unstable_shouldRevalidateArgs) {
            return shouldLoad;
          }
          if (typeof defaultShouldRevalidate === "boolean") {
            return shouldRevalidateLoader(match, {
              ...unstable_shouldRevalidateArgs,
              defaultShouldRevalidate
            });
          }
          return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);
        },
        resolve(handlerOverride) {
          if (isUsingNewApi || shouldLoad || handlerOverride && request.method === "GET" && (match.route.lazy || match.route.loader)) {
            return callLoaderOrAction({
              request,
              match,
              lazyHandlerPromise: _lazyPromises == null ? void 0 : _lazyPromises.handler,
              lazyRoutePromise: _lazyPromises == null ? void 0 : _lazyPromises.route,
              handlerOverride,
              scopedContext
            });
          }
          return Promise.resolve({ type: "data", result: void 0 });
        }
      };
    }
    function getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {
      return matches.map((match) => {
        if (match.route.id !== targetMatch.route.id) {
          return {
            ...match,
            shouldLoad: false,
            unstable_shouldRevalidateArgs: shouldRevalidateArgs,
            unstable_shouldCallHandler: () => false,
            _lazyPromises: getDataStrategyMatchLazyPromises(
              mapRouteProperties2,
              manifest,
              request,
              match,
              lazyRoutePropertiesToSkip
            ),
            resolve: () => Promise.resolve({ type: "data", result: void 0 })
          };
        }
        return getDataStrategyMatch(
          mapRouteProperties2,
          manifest,
          request,
          match,
          lazyRoutePropertiesToSkip,
          scopedContext,
          true,
          shouldRevalidateArgs
        );
      });
    }
    async function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {
      if (matches.some((m) => {
        var _a;
        return (_a = m._lazyPromises) == null ? void 0 : _a.middleware;
      })) {
        await Promise.all(matches.map((m) => {
          var _a;
          return (_a = m._lazyPromises) == null ? void 0 : _a.middleware;
        }));
      }
      let dataStrategyArgs = {
        request,
        params: matches[0].params,
        context: scopedContext,
        matches
      };
      let unstable_runClientMiddleware = isStaticHandler ? () => {
        throw new Error(
          "You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`"
        );
      } : (cb) => {
        let typedDataStrategyArgs = dataStrategyArgs;
        return runMiddlewarePipeline(
          typedDataStrategyArgs,
          false,
          () => cb({
            ...typedDataStrategyArgs,
            fetcherKey,
            unstable_runClientMiddleware: () => {
              throw new Error(
                "Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler"
              );
            }
          }),
          (error, routeId) => ({
            [routeId]: { type: "error", result: error }
          })
        );
      };
      let results = await dataStrategyImpl({
        ...dataStrategyArgs,
        fetcherKey,
        unstable_runClientMiddleware
      });
      try {
        await Promise.all(
          matches.flatMap((m) => {
            var _a, _b;
            return [(_a = m._lazyPromises) == null ? void 0 : _a.handler, (_b = m._lazyPromises) == null ? void 0 : _b.route];
          })
        );
      } catch (e) {
      }
      return results;
    }
    async function callLoaderOrAction({
      request,
      match,
      lazyHandlerPromise,
      lazyRoutePromise,
      handlerOverride,
      scopedContext
    }) {
      let result;
      let onReject;
      let isAction = isMutationMethod(request.method);
      let type = isAction ? "action" : "loader";
      let runHandler = (handler) => {
        let reject;
        let abortPromise = new Promise((_, r) => reject = r);
        onReject = () => reject();
        request.signal.addEventListener("abort", onReject);
        let actualHandler = (ctx) => {
          if (typeof handler !== "function") {
            return Promise.reject(
              new Error(
                `You cannot call the handler for a route which defines a boolean "${type}" [routeId: ${match.route.id}]`
              )
            );
          }
          return handler(
            {
              request,
              params: match.params,
              context: scopedContext
            },
            ...ctx !== void 0 ? [ctx] : []
          );
        };
        let handlerPromise = (async () => {
          try {
            let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
            return { type: "data", result: val };
          } catch (e) {
            return { type: "error", result: e };
          }
        })();
        return Promise.race([handlerPromise, abortPromise]);
      };
      try {
        let handler = isAction ? match.route.action : match.route.loader;
        if (lazyHandlerPromise || lazyRoutePromise) {
          if (handler) {
            let handlerError;
            let [value] = await Promise.all([
              // If the handler throws, don't let it immediately bubble out,
              // since we need to let the lazy() execution finish so we know if this
              // route has a boundary that can handle the error
              runHandler(handler).catch((e) => {
                handlerError = e;
              }),
              // Ensure all lazy route promises are resolved before continuing
              lazyHandlerPromise,
              lazyRoutePromise
            ]);
            if (handlerError !== void 0) {
              throw handlerError;
            }
            result = value;
          } else {
            await lazyHandlerPromise;
            let handler2 = isAction ? match.route.action : match.route.loader;
            if (handler2) {
              [result] = await Promise.all([runHandler(handler2), lazyRoutePromise]);
            } else if (type === "action") {
              let url = new URL(request.url);
              let pathname = url.pathname + url.search;
              throw getInternalRouterError(405, {
                method: request.method,
                pathname,
                routeId: match.route.id
              });
            } else {
              return { type: "data", result: void 0 };
            }
          }
        } else if (!handler) {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(404, {
            pathname
          });
        } else {
          result = await runHandler(handler);
        }
      } catch (e) {
        return { type: "error", result: e };
      } finally {
        if (onReject) {
          request.signal.removeEventListener("abort", onReject);
        }
      }
      return result;
    }
    async function convertDataStrategyResultToDataResult(dataStrategyResult) {
      var _a, _b, _c, _d, _e, _f;
      let { result, type } = dataStrategyResult;
      if (isResponse(result)) {
        let data2;
        try {
          let contentType = result.headers.get("Content-Type");
          if (contentType && /\bapplication\/json\b/.test(contentType)) {
            if (result.body == null) {
              data2 = null;
            } else {
              data2 = await result.json();
            }
          } else {
            data2 = await result.text();
          }
        } catch (e) {
          return { type: "error", error: e };
        }
        if (type === "error") {
          return {
            type: "error",
            error: new ErrorResponseImpl(result.status, result.statusText, data2),
            statusCode: result.status,
            headers: result.headers
          };
        }
        return {
          type: "data",
          data: data2,
          statusCode: result.status,
          headers: result.headers
        };
      }
      if (type === "error") {
        if (isDataWithResponseInit(result)) {
          if (result.data instanceof Error) {
            return {
              type: "error",
              error: result.data,
              statusCode: (_a = result.init) == null ? void 0 : _a.status,
              headers: ((_b = result.init) == null ? void 0 : _b.headers) ? new Headers(result.init.headers) : void 0
            };
          }
          return {
            type: "error",
            error: new ErrorResponseImpl(
              ((_c = result.init) == null ? void 0 : _c.status) || 500,
              void 0,
              result.data
            ),
            statusCode: isRouteErrorResponse(result) ? result.status : void 0,
            headers: ((_d = result.init) == null ? void 0 : _d.headers) ? new Headers(result.init.headers) : void 0
          };
        }
        return {
          type: "error",
          error: result,
          statusCode: isRouteErrorResponse(result) ? result.status : void 0
        };
      }
      if (isDataWithResponseInit(result)) {
        return {
          type: "data",
          data: result.data,
          statusCode: (_e = result.init) == null ? void 0 : _e.status,
          headers: ((_f = result.init) == null ? void 0 : _f.headers) ? new Headers(result.init.headers) : void 0
        };
      }
      return { type: "data", data: result };
    }
    function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {
      let location = response.headers.get("Location");
      invariant(
        location,
        "Redirects returned/thrown from loaders/actions must have a Location header"
      );
      if (!ABSOLUTE_URL_REGEX.test(location)) {
        let trimmedMatches = matches.slice(
          0,
          matches.findIndex((m) => m.route.id === routeId) + 1
        );
        location = normalizeTo(
          new URL(request.url),
          trimmedMatches,
          basename,
          location
        );
        response.headers.set("Location", location);
      }
      return response;
    }
    function normalizeRedirectLocation(location, currentUrl, basename) {
      if (ABSOLUTE_URL_REGEX.test(location)) {
        let normalizedLocation = location;
        let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
        let isSameBasename = stripBasename(url.pathname, basename) != null;
        if (url.origin === currentUrl.origin && isSameBasename) {
          return url.pathname + url.search + url.hash;
        }
      }
      return location;
    }
    function createClientSideRequest(history, location, signal, submission) {
      let url = history.createURL(stripHashFromPath(location)).toString();
      let init = { signal };
      if (submission && isMutationMethod(submission.formMethod)) {
        let { formMethod, formEncType } = submission;
        init.method = formMethod.toUpperCase();
        if (formEncType === "application/json") {
          init.headers = new Headers({ "Content-Type": formEncType });
          init.body = JSON.stringify(submission.json);
        } else if (formEncType === "text/plain") {
          init.body = submission.text;
        } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
          init.body = convertFormDataToSearchParams(submission.formData);
        } else {
          init.body = submission.formData;
        }
      }
      return new Request(url, init);
    }
    function convertFormDataToSearchParams(formData) {
      let searchParams = new URLSearchParams();
      for (let [key, value] of formData.entries()) {
        searchParams.append(key, typeof value === "string" ? value : value.name);
      }
      return searchParams;
    }
    function convertSearchParamsToFormData(searchParams) {
      let formData = new FormData();
      for (let [key, value] of searchParams.entries()) {
        formData.append(key, value);
      }
      return formData;
    }
    function processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {
      let loaderData = {};
      let errors = null;
      let statusCode;
      let foundError = false;
      let loaderHeaders = {};
      let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
      matches.forEach((match) => {
        if (!(match.route.id in results)) {
          return;
        }
        let id = match.route.id;
        let result = results[id];
        invariant(
          !isRedirectResult(result),
          "Cannot handle redirect results in processLoaderData"
        );
        if (isErrorResult(result)) {
          let error = result.error;
          if (pendingError !== void 0) {
            error = pendingError;
            pendingError = void 0;
          }
          errors = errors || {};
          if (skipLoaderErrorBubbling) {
            errors[id] = error;
          } else {
            let boundaryMatch = findNearestBoundary(matches, id);
            if (errors[boundaryMatch.route.id] == null) {
              errors[boundaryMatch.route.id] = error;
            }
          }
          if (!isStaticHandler) {
            loaderData[id] = ResetLoaderDataSymbol;
          }
          if (!foundError) {
            foundError = true;
            statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
          }
          if (result.headers) {
            loaderHeaders[id] = result.headers;
          }
        } else {
          loaderData[id] = result.data;
          if (result.statusCode && result.statusCode !== 200 && !foundError) {
            statusCode = result.statusCode;
          }
          if (result.headers) {
            loaderHeaders[id] = result.headers;
          }
        }
      });
      if (pendingError !== void 0 && pendingActionResult) {
        errors = { [pendingActionResult[0]]: pendingError };
        if (pendingActionResult[2]) {
          loaderData[pendingActionResult[2]] = void 0;
        }
      }
      return {
        loaderData,
        errors,
        statusCode: statusCode || 200,
        loaderHeaders
      };
    }
    function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {
      let { loaderData, errors } = processRouteLoaderData(
        matches,
        results,
        pendingActionResult
      );
      revalidatingFetchers.filter((f2) => !f2.matches || f2.matches.some((m) => m.shouldLoad)).forEach((rf) => {
        let { key, match, controller } = rf;
        let result = fetcherResults[key];
        invariant(result, "Did not find corresponding fetcher result");
        if (controller && controller.signal.aborted) {
          return;
        } else if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
          if (!(errors && errors[boundaryMatch.route.id])) {
            errors = {
              ...errors,
              [boundaryMatch.route.id]: result.error
            };
          }
          state.fetchers.delete(key);
        } else if (isRedirectResult(result)) {
          invariant(false, "Unhandled fetcher revalidation redirect");
        } else {
          let doneFetcher = getDoneFetcher(result.data);
          state.fetchers.set(key, doneFetcher);
        }
      });
      return { loaderData, errors };
    }
    function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
      let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {
        merged[k] = v;
        return merged;
      }, {});
      for (let match of matches) {
        let id = match.route.id;
        if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {
          mergedLoaderData[id] = loaderData[id];
        }
        if (errors && errors.hasOwnProperty(id)) {
          break;
        }
      }
      return mergedLoaderData;
    }
    function getActionDataForCommit(pendingActionResult) {
      if (!pendingActionResult) {
        return {};
      }
      return isErrorResult(pendingActionResult[1]) ? {
        // Clear out prior actionData on errors
        actionData: {}
      } : {
        actionData: {
          [pendingActionResult[0]]: pendingActionResult[1].data
        }
      };
    }
    function findNearestBoundary(matches, routeId) {
      let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];
      return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];
    }
    function getShortCircuitMatches(routes) {
      let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === "/") || {
        id: `__shim-error-route__`
      };
      return {
        matches: [
          {
            params: {},
            pathname: "",
            pathnameBase: "",
            route
          }
        ],
        route
      };
    }
    function getInternalRouterError(status, {
      pathname,
      routeId,
      method,
      type,
      message
    } = {}) {
      let statusText = "Unknown Server Error";
      let errorMessage = "Unknown @remix-run/router error";
      if (status === 400) {
        statusText = "Bad Request";
        if (method && pathname && routeId) {
          errorMessage = `You made a ${method} request to "${pathname}" but did not provide a \`loader\` for route "${routeId}", so there is no way to handle the request.`;
        } else if (type === "invalid-body") {
          errorMessage = "Unable to encode submission body";
        }
      } else if (status === 403) {
        statusText = "Forbidden";
        errorMessage = `Route "${routeId}" does not match URL "${pathname}"`;
      } else if (status === 404) {
        statusText = "Not Found";
        errorMessage = `No route matches URL "${pathname}"`;
      } else if (status === 405) {
        statusText = "Method Not Allowed";
        if (method && pathname && routeId) {
          errorMessage = `You made a ${method.toUpperCase()} request to "${pathname}" but did not provide an \`action\` for route "${routeId}", so there is no way to handle the request.`;
        } else if (method) {
          errorMessage = `Invalid request method "${method.toUpperCase()}"`;
        }
      }
      return new ErrorResponseImpl(
        status || 500,
        statusText,
        new Error(errorMessage),
        true
      );
    }
    function findRedirect(results) {
      let entries = Object.entries(results);
      for (let i = entries.length - 1; i >= 0; i--) {
        let [key, result] = entries[i];
        if (isRedirectResult(result)) {
          return { key, result };
        }
      }
    }
    function stripHashFromPath(path) {
      let parsedPath = typeof path === "string" ? parsePath(path) : path;
      return createPath({ ...parsedPath, hash: "" });
    }
    function isHashChangeOnly(a, b) {
      if (a.pathname !== b.pathname || a.search !== b.search) {
        return false;
      }
      if (a.hash === "") {
        return b.hash !== "";
      } else if (a.hash === b.hash) {
        return true;
      } else if (b.hash !== "") {
        return true;
      }
      return false;
    }
    function isDataStrategyResult(result) {
      return result != null && typeof result === "object" && "type" in result && "result" in result && (result.type === "data" || result.type === "error");
    }
    function isRedirectDataStrategyResult(result) {
      return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
    }
    function isErrorResult(result) {
      return result.type === "error";
    }
    function isRedirectResult(result) {
      return (result && result.type) === "redirect";
    }
    function isDataWithResponseInit(value) {
      return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
    }
    function isResponse(value) {
      return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
    }
    function isRedirectStatusCode(statusCode) {
      return redirectStatusCodes.has(statusCode);
    }
    function isRedirectResponse(result) {
      return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has("Location");
    }
    function isValidMethod(method) {
      return validRequestMethods.has(method.toUpperCase());
    }
    function isMutationMethod(method) {
      return validMutationMethods.has(method.toUpperCase());
    }
    function hasNakedIndexQuery(search) {
      return new URLSearchParams(search).getAll("index").some((v) => v === "");
    }
    function getTargetMatch(matches, location) {
      let search = typeof location === "string" ? parsePath(location).search : location.search;
      if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
        return matches[matches.length - 1];
      }
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches[pathMatches.length - 1];
    }
    function getSubmissionFromNavigation(navigation) {
      let { formMethod, formAction, formEncType, text, formData, json } = navigation;
      if (!formMethod || !formAction || !formEncType) {
        return;
      }
      if (text != null) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData: void 0,
          json: void 0,
          text
        };
      } else if (formData != null) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData,
          json: void 0,
          text: void 0
        };
      } else if (json !== void 0) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData: void 0,
          json,
          text: void 0
        };
      }
    }
    function getLoadingNavigation(location, submission) {
      if (submission) {
        let navigation = {
          state: "loading",
          location,
          formMethod: submission.formMethod,
          formAction: submission.formAction,
          formEncType: submission.formEncType,
          formData: submission.formData,
          json: submission.json,
          text: submission.text
        };
        return navigation;
      } else {
        let navigation = {
          state: "loading",
          location,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          json: void 0,
          text: void 0
        };
        return navigation;
      }
    }
    function getSubmittingNavigation(location, submission) {
      let navigation = {
        state: "submitting",
        location,
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text
      };
      return navigation;
    }
    function getLoadingFetcher(submission, data2) {
      if (submission) {
        let fetcher = {
          state: "loading",
          formMethod: submission.formMethod,
          formAction: submission.formAction,
          formEncType: submission.formEncType,
          formData: submission.formData,
          json: submission.json,
          text: submission.text,
          data: data2
        };
        return fetcher;
      } else {
        let fetcher = {
          state: "loading",
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          json: void 0,
          text: void 0,
          data: data2
        };
        return fetcher;
      }
    }
    function getSubmittingFetcher(submission, existingFetcher) {
      let fetcher = {
        state: "submitting",
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text,
        data: existingFetcher ? existingFetcher.data : void 0
      };
      return fetcher;
    }
    function getDoneFetcher(data2) {
      let fetcher = {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: data2
      };
      return fetcher;
    }
    function restoreAppliedTransitions(_window, transitions) {
      try {
        let sessionPositions = _window.sessionStorage.getItem(
          TRANSITIONS_STORAGE_KEY
        );
        if (sessionPositions) {
          let json = JSON.parse(sessionPositions);
          for (let [k, v] of Object.entries(json || {})) {
            if (v && Array.isArray(v)) {
              transitions.set(k, new Set(v || []));
            }
          }
        }
      } catch (e) {
      }
    }
    function persistAppliedTransitions(_window, transitions) {
      if (transitions.size > 0) {
        let json = {};
        for (let [k, v] of transitions) {
          json[k] = [...v];
        }
        try {
          _window.sessionStorage.setItem(
            TRANSITIONS_STORAGE_KEY,
            JSON.stringify(json)
          );
        } catch (error) {
          warning(
            false,
            `Failed to save applied view transitions in sessionStorage (${error}).`
          );
        }
      }
    }
    function createDeferred() {
      let resolve;
      let reject;
      let promise = new Promise((res, rej) => {
        resolve = async (val) => {
          res(val);
          try {
            await promise;
          } catch (e) {
          }
        };
        reject = async (error) => {
          rej(error);
          try {
            await promise;
          } catch (e) {
          }
        };
      });
      return {
        promise,
        //@ts-ignore
        resolve,
        //@ts-ignore
        reject
      };
    }
    var React32 = __toESM2(require_react());
    var React5 = __toESM2(require_react());
    var DataRouterContext = React5.createContext(null);
    DataRouterContext.displayName = "DataRouter";
    var DataRouterStateContext = React5.createContext(null);
    DataRouterStateContext.displayName = "DataRouterState";
    var ViewTransitionContext = React5.createContext({
      isTransitioning: false
    });
    ViewTransitionContext.displayName = "ViewTransition";
    var FetchersContext = React5.createContext(
      /* @__PURE__ */ new Map()
    );
    FetchersContext.displayName = "Fetchers";
    var AwaitContext = React5.createContext(null);
    AwaitContext.displayName = "Await";
    var NavigationContext = React5.createContext(
      null
    );
    NavigationContext.displayName = "Navigation";
    var LocationContext = React5.createContext(
      null
    );
    LocationContext.displayName = "Location";
    var RouteContext = React5.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    RouteContext.displayName = "Route";
    var RouteErrorContext = React5.createContext(null);
    RouteErrorContext.displayName = "RouteError";
    var ENABLE_DEV_WARNINGS = true;
    var React22 = __toESM2(require_react());
    function useHref(to, { relative } = {}) {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useHref() may be used only in the context of a <Router> component.`
      );
      let { basename, navigator } = React22.useContext(NavigationContext);
      let { hash, pathname, search } = useResolvedPath(to, { relative });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator.createHref({ pathname: joinedPathname, search, hash });
    }
    function useInRouterContext() {
      return React22.useContext(LocationContext) != null;
    }
    function useLocation() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useLocation() may be used only in the context of a <Router> component.`
      );
      return React22.useContext(LocationContext).location;
    }
    function useNavigationType() {
      return React22.useContext(LocationContext).navigationType;
    }
    function useMatch(pattern) {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useMatch() may be used only in the context of a <Router> component.`
      );
      let { pathname } = useLocation();
      return React22.useMemo(
        () => matchPath(pattern, decodePath(pathname)),
        [pathname, pattern]
      );
    }
    var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
    function useIsomorphicLayoutEffect(cb) {
      let isStatic = React22.useContext(NavigationContext).static;
      if (!isStatic) {
        React22.useLayoutEffect(cb);
      }
    }
    function useNavigate() {
      let { isDataRoute } = React22.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useNavigate() may be used only in the context of a <Router> component.`
      );
      let dataRouterContext = React22.useContext(DataRouterContext);
      let { basename, navigator } = React22.useContext(NavigationContext);
      let { matches } = React22.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
      let activeRef = React22.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = React22.useCallback(
        (to, options = {}) => {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to === "number") {
            navigator.go(to);
            return;
          }
          let path = resolveTo(
            to,
            JSON.parse(routePathnamesJson),
            locationPathname,
            options.relative === "path"
          );
          if (dataRouterContext == null && basename !== "/") {
            path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
          }
          (!!options.replace ? navigator.replace : navigator.push)(
            path,
            options.state,
            options
          );
        },
        [
          basename,
          navigator,
          routePathnamesJson,
          locationPathname,
          dataRouterContext
        ]
      );
      return navigate;
    }
    var OutletContext = React22.createContext(null);
    function useOutletContext() {
      return React22.useContext(OutletContext);
    }
    function useOutlet(context) {
      let outlet = React22.useContext(RouteContext).outlet;
      if (outlet) {
        return React22.createElement(OutletContext.Provider, { value: context }, outlet);
      }
      return outlet;
    }
    function useParams() {
      let { matches } = React22.useContext(RouteContext);
      let routeMatch = matches[matches.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useResolvedPath(to, { relative } = {}) {
      let { matches } = React22.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
      return React22.useMemo(
        () => resolveTo(
          to,
          JSON.parse(routePathnamesJson),
          locationPathname,
          relative === "path"
        ),
        [to, routePathnamesJson, locationPathname, relative]
      );
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, future) {
      var _a;
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useRoutes() may be used only in the context of a <Router> component.`
      );
      let { navigator, static: isStatic } = React22.useContext(NavigationContext);
      let { matches: parentMatches } = React22.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      let parentPathname = routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      let parentRoute = routeMatch && routeMatch.route;
      if (ENABLE_DEV_WARNINGS) {
        let parentPath = parentRoute && parentRoute.path || "";
        warningOnce(
          parentPathname,
          !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
          `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
        );
      }
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        invariant(
          parentPathnameBase === "/" || ((_a = parsedLocationArg.pathname) == null ? void 0 : _a.startsWith(parentPathnameBase)),
          `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
        );
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = pathname;
      if (parentPathnameBase !== "/") {
        let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
        let segments = pathname.replace(/^\//, "").split("/");
        remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
      }
      let matches = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : matchRoutes(routes, { pathname: remainingPathname });
      if (ENABLE_DEV_WARNINGS) {
        warning(
          parentRoute || matches != null,
          `No routes matched location "${location.pathname}${location.search}${location.hash}" `
        );
        warning(
          matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
          `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
        );
      }
      let renderedMatches = _renderMatches(
        matches && matches.map(
          (match) => Object.assign({}, match, {
            params: Object.assign({}, parentParams, match.params),
            pathname: joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes
              navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname
            ]),
            pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes
              navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
            ])
          })
        ),
        parentMatches,
        dataRouterState,
        future
      );
      if (locationArg && renderedMatches) {
        return React22.createElement(
          LocationContext.Provider,
          {
            value: {
              location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...location
              },
              navigationType: "POP"
              /* Pop */
            }
          },
          renderedMatches
        );
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
      let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
      let devInfo = null;
      if (ENABLE_DEV_WARNINGS) {
        console.error(
          "Error handled by React Router default ErrorBoundary:",
          error
        );
        devInfo = React22.createElement(React22.Fragment, null, React22.createElement("p", null, "💿 Hey developer 👋"), React22.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", React22.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", React22.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
      }
      return React22.createElement(React22.Fragment, null, React22.createElement("h2", null, "Unexpected Application Error!"), React22.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? React22.createElement("pre", { style: preStyles }, stack) : null, devInfo);
    }
    var defaultErrorElement = React22.createElement(DefaultErrorComponent, null);
    var RenderErrorBoundary = class extends React22.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return { error };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error(
          "React Router caught the following error during render",
          error,
          errorInfo
        );
      }
      render() {
        return this.state.error !== void 0 ? React22.createElement(RouteContext.Provider, { value: this.props.routeContext }, React22.createElement(
          RouteErrorContext.Provider,
          {
            value: this.state.error,
            children: this.props.component
          }
        )) : this.props.children;
      }
    };
    function RenderedRoute({ routeContext, match, children }) {
      let dataRouterContext = React22.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
      }
      return React22.createElement(RouteContext.Provider, { value: routeContext }, children);
    }
    function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
      if (matches == null) {
        if (!dataRouterState) {
          return null;
        }
        if (dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex(
          (m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0
        );
        invariant(
          errorIndex >= 0,
          `Could not find a matching route for errors on route IDs: ${Object.keys(
            errors
          ).join(",")}`
        );
        renderedMatches = renderedMatches.slice(
          0,
          Math.min(renderedMatches.length, errorIndex + 1)
        );
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState) {
        for (let i = 0; i < renderedMatches.length; i++) {
          let match = renderedMatches[i];
          if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
            fallbackIndex = i;
          }
          if (match.route.id) {
            let { loaderData, errors: errors2 } = dataRouterState;
            let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
            if (match.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      return renderedMatches.reduceRight((outlet, match, index) => {
        let error;
        let shouldRenderHydrateFallback = false;
        let errorElement = null;
        let hydrateFallbackElement = null;
        if (dataRouterState) {
          error = errors && match.route.id ? errors[match.route.id] : void 0;
          errorElement = match.route.errorElement || defaultErrorElement;
          if (renderFallback) {
            if (fallbackIndex < 0 && index === 0) {
              warningOnce(
                "route-fallback",
                false,
                "No `HydrateFallback` element provided to render during initial hydration"
              );
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = null;
            } else if (fallbackIndex === index) {
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = match.route.hydrateFallbackElement || null;
            }
          }
        }
        let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
        let getChildren = () => {
          let children;
          if (error) {
            children = errorElement;
          } else if (shouldRenderHydrateFallback) {
            children = hydrateFallbackElement;
          } else if (match.route.Component) {
            children = React22.createElement(match.route.Component, null);
          } else if (match.route.element) {
            children = match.route.element;
          } else {
            children = outlet;
          }
          return React22.createElement(
            RenderedRoute,
            {
              match,
              routeContext: {
                outlet,
                matches: matches2,
                isDataRoute: dataRouterState != null
              },
              children
            }
          );
        };
        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? React22.createElement(
          RenderErrorBoundary,
          {
            location: dataRouterState.location,
            revalidation: dataRouterState.revalidation,
            component: errorElement,
            error,
            children: getChildren(),
            routeContext: { outlet: null, matches: matches2, isDataRoute: true }
          }
        ) : getChildren();
      }, null);
    }
    function getDataRouterConsoleError(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext(hookName) {
      let ctx = React22.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError(hookName));
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = React22.useContext(DataRouterStateContext);
      invariant(state, getDataRouterConsoleError(hookName));
      return state;
    }
    function useRouteContext(hookName) {
      let route = React22.useContext(RouteContext);
      invariant(route, getDataRouterConsoleError(hookName));
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext(hookName);
      let thisRoute = route.matches[route.matches.length - 1];
      invariant(
        thisRoute.route.id,
        `${hookName} can only be used on routes that contain a unique "id"`
      );
      return thisRoute.route.id;
    }
    function useRouteId() {
      return useCurrentRouteId(
        "useRouteId"
        /* UseRouteId */
      );
    }
    function useNavigation() {
      let state = useDataRouterState(
        "useNavigation"
        /* UseNavigation */
      );
      return state.navigation;
    }
    function useRevalidator() {
      let dataRouterContext = useDataRouterContext(
        "useRevalidator"
        /* UseRevalidator */
      );
      let state = useDataRouterState(
        "useRevalidator"
        /* UseRevalidator */
      );
      let revalidate = React22.useCallback(async () => {
        await dataRouterContext.router.revalidate();
      }, [dataRouterContext.router]);
      return React22.useMemo(
        () => ({ revalidate, state: state.revalidation }),
        [revalidate, state.revalidation]
      );
    }
    function useMatches() {
      let { matches, loaderData } = useDataRouterState(
        "useMatches"
        /* UseMatches */
      );
      return React22.useMemo(
        () => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)),
        [matches, loaderData]
      );
    }
    function useLoaderData() {
      let state = useDataRouterState(
        "useLoaderData"
        /* UseLoaderData */
      );
      let routeId = useCurrentRouteId(
        "useLoaderData"
        /* UseLoaderData */
      );
      return state.loaderData[routeId];
    }
    function useRouteLoaderData(routeId) {
      let state = useDataRouterState(
        "useRouteLoaderData"
        /* UseRouteLoaderData */
      );
      return state.loaderData[routeId];
    }
    function useActionData() {
      let state = useDataRouterState(
        "useActionData"
        /* UseActionData */
      );
      let routeId = useCurrentRouteId(
        "useLoaderData"
        /* UseLoaderData */
      );
      return state.actionData ? state.actionData[routeId] : void 0;
    }
    function useRouteError() {
      var _a;
      let error = React22.useContext(RouteErrorContext);
      let state = useDataRouterState(
        "useRouteError"
        /* UseRouteError */
      );
      let routeId = useCurrentRouteId(
        "useRouteError"
        /* UseRouteError */
      );
      if (error !== void 0) {
        return error;
      }
      return (_a = state.errors) == null ? void 0 : _a[routeId];
    }
    function useAsyncValue() {
      let value = React22.useContext(AwaitContext);
      return value == null ? void 0 : value._data;
    }
    function useAsyncError() {
      let value = React22.useContext(AwaitContext);
      return value == null ? void 0 : value._error;
    }
    var blockerId = 0;
    function useBlocker(shouldBlock) {
      let { router, basename } = useDataRouterContext(
        "useBlocker"
        /* UseBlocker */
      );
      let state = useDataRouterState(
        "useBlocker"
        /* UseBlocker */
      );
      let [blockerKey, setBlockerKey] = React22.useState("");
      let blockerFunction = React22.useCallback(
        (arg) => {
          if (typeof shouldBlock !== "function") {
            return !!shouldBlock;
          }
          if (basename === "/") {
            return shouldBlock(arg);
          }
          let { currentLocation, nextLocation, historyAction } = arg;
          return shouldBlock({
            currentLocation: {
              ...currentLocation,
              pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
            },
            nextLocation: {
              ...nextLocation,
              pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
            },
            historyAction
          });
        },
        [basename, shouldBlock]
      );
      React22.useEffect(() => {
        let key = String(++blockerId);
        setBlockerKey(key);
        return () => router.deleteBlocker(key);
      }, [router]);
      React22.useEffect(() => {
        if (blockerKey !== "") {
          router.getBlocker(blockerKey, blockerFunction);
        }
      }, [router, blockerKey, blockerFunction]);
      return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;
    }
    function useNavigateStable() {
      let { router } = useDataRouterContext(
        "useNavigate"
        /* UseNavigateStable */
      );
      let id = useCurrentRouteId(
        "useNavigate"
        /* UseNavigateStable */
      );
      let activeRef = React22.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = React22.useCallback(
        async (to, options = {}) => {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to === "number") {
            router.navigate(to);
          } else {
            await router.navigate(to, { fromRouteId: id, ...options });
          }
        },
        [router, id]
      );
      return navigate;
    }
    var alreadyWarned = {};
    function warningOnce(key, cond, message) {
      if (!cond && !alreadyWarned[key]) {
        alreadyWarned[key] = true;
        warning(false, message);
      }
    }
    var alreadyWarned2 = {};
    function warnOnce(condition, message) {
      if (!condition && !alreadyWarned2[message]) {
        alreadyWarned2[message] = true;
        console.warn(message);
      }
    }
    function mapRouteProperties(route) {
      let updates = {
        // Note: this check also occurs in createRoutesFromChildren so update
        // there if you change this -- please and thank you!
        hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null
      };
      if (route.Component) {
        if (ENABLE_DEV_WARNINGS) {
          if (route.element) {
            warning(
              false,
              "You should not include both `Component` and `element` on your route - `Component` will be used."
            );
          }
        }
        Object.assign(updates, {
          element: React32.createElement(route.Component),
          Component: void 0
        });
      }
      if (route.HydrateFallback) {
        if (ENABLE_DEV_WARNINGS) {
          if (route.hydrateFallbackElement) {
            warning(
              false,
              "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
            );
          }
        }
        Object.assign(updates, {
          hydrateFallbackElement: React32.createElement(route.HydrateFallback),
          HydrateFallback: void 0
        });
      }
      if (route.ErrorBoundary) {
        if (ENABLE_DEV_WARNINGS) {
          if (route.errorElement) {
            warning(
              false,
              "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
            );
          }
        }
        Object.assign(updates, {
          errorElement: React32.createElement(route.ErrorBoundary),
          ErrorBoundary: void 0
        });
      }
      return updates;
    }
    var hydrationRouteProperties = [
      "HydrateFallback",
      "hydrateFallbackElement"
    ];
    function createMemoryRouter(routes, opts) {
      return createRouter({
        basename: opts == null ? void 0 : opts.basename,
        unstable_getContext: opts == null ? void 0 : opts.unstable_getContext,
        future: opts == null ? void 0 : opts.future,
        history: createMemoryHistory({
          initialEntries: opts == null ? void 0 : opts.initialEntries,
          initialIndex: opts == null ? void 0 : opts.initialIndex
        }),
        hydrationData: opts == null ? void 0 : opts.hydrationData,
        routes,
        hydrationRouteProperties,
        mapRouteProperties,
        dataStrategy: opts == null ? void 0 : opts.dataStrategy,
        patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation
      }).initialize();
    }
    var Deferred = class {
      constructor() {
        this.status = "pending";
        this.promise = new Promise((resolve, reject) => {
          this.resolve = (value) => {
            if (this.status === "pending") {
              this.status = "resolved";
              resolve(value);
            }
          };
          this.reject = (reason) => {
            if (this.status === "pending") {
              this.status = "rejected";
              reject(reason);
            }
          };
        });
      }
    };
    function RouterProvider2({
      router,
      flushSync: reactDomFlushSyncImpl
    }) {
      let [state, setStateImpl] = React32.useState(router.state);
      let [pendingState, setPendingState] = React32.useState();
      let [vtContext, setVtContext] = React32.useState({
        isTransitioning: false
      });
      let [renderDfd, setRenderDfd] = React32.useState();
      let [transition, setTransition] = React32.useState();
      let [interruption, setInterruption] = React32.useState();
      let fetcherData = React32.useRef(/* @__PURE__ */ new Map());
      let setState = React32.useCallback(
        (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {
          newState.fetchers.forEach((fetcher, key) => {
            if (fetcher.data !== void 0) {
              fetcherData.current.set(key, fetcher.data);
            }
          });
          deletedFetchers.forEach((key) => fetcherData.current.delete(key));
          warnOnce(
            flushSync === false || reactDomFlushSyncImpl != null,
            'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
          );
          let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === "function";
          warnOnce(
            viewTransitionOpts == null || isViewTransitionAvailable,
            "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
          );
          if (!viewTransitionOpts || !isViewTransitionAvailable) {
            if (reactDomFlushSyncImpl && flushSync) {
              reactDomFlushSyncImpl(() => setStateImpl(newState));
            } else {
              React32.startTransition(() => setStateImpl(newState));
            }
            return;
          }
          if (reactDomFlushSyncImpl && flushSync) {
            reactDomFlushSyncImpl(() => {
              if (transition) {
                renderDfd && renderDfd.resolve();
                transition.skipTransition();
              }
              setVtContext({
                isTransitioning: true,
                flushSync: true,
                currentLocation: viewTransitionOpts.currentLocation,
                nextLocation: viewTransitionOpts.nextLocation
              });
            });
            let t = router.window.document.startViewTransition(() => {
              reactDomFlushSyncImpl(() => setStateImpl(newState));
            });
            t.finished.finally(() => {
              reactDomFlushSyncImpl(() => {
                setRenderDfd(void 0);
                setTransition(void 0);
                setPendingState(void 0);
                setVtContext({ isTransitioning: false });
              });
            });
            reactDomFlushSyncImpl(() => setTransition(t));
            return;
          }
          if (transition) {
            renderDfd && renderDfd.resolve();
            transition.skipTransition();
            setInterruption({
              state: newState,
              currentLocation: viewTransitionOpts.currentLocation,
              nextLocation: viewTransitionOpts.nextLocation
            });
          } else {
            setPendingState(newState);
            setVtContext({
              isTransitioning: true,
              flushSync: false,
              currentLocation: viewTransitionOpts.currentLocation,
              nextLocation: viewTransitionOpts.nextLocation
            });
          }
        },
        [router.window, reactDomFlushSyncImpl, transition, renderDfd]
      );
      React32.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
      React32.useEffect(() => {
        if (vtContext.isTransitioning && !vtContext.flushSync) {
          setRenderDfd(new Deferred());
        }
      }, [vtContext]);
      React32.useEffect(() => {
        if (renderDfd && pendingState && router.window) {
          let newState = pendingState;
          let renderPromise = renderDfd.promise;
          let transition2 = router.window.document.startViewTransition(async () => {
            React32.startTransition(() => setStateImpl(newState));
            await renderPromise;
          });
          transition2.finished.finally(() => {
            setRenderDfd(void 0);
            setTransition(void 0);
            setPendingState(void 0);
            setVtContext({ isTransitioning: false });
          });
          setTransition(transition2);
        }
      }, [pendingState, renderDfd, router.window]);
      React32.useEffect(() => {
        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
          renderDfd.resolve();
        }
      }, [renderDfd, transition, state.location, pendingState]);
      React32.useEffect(() => {
        if (!vtContext.isTransitioning && interruption) {
          setPendingState(interruption.state);
          setVtContext({
            isTransitioning: true,
            flushSync: false,
            currentLocation: interruption.currentLocation,
            nextLocation: interruption.nextLocation
          });
          setInterruption(void 0);
        }
      }, [vtContext.isTransitioning, interruption]);
      let navigator = React32.useMemo(() => {
        return {
          createHref: router.createHref,
          encodeLocation: router.encodeLocation,
          go: (n) => router.navigate(n),
          push: (to, state2, opts) => router.navigate(to, {
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          }),
          replace: (to, state2, opts) => router.navigate(to, {
            replace: true,
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          })
        };
      }, [router]);
      let basename = router.basename || "/";
      let dataRouterContext = React32.useMemo(
        () => ({
          router,
          navigator,
          static: false,
          basename
        }),
        [router, navigator, basename]
      );
      return React32.createElement(React32.Fragment, null, React32.createElement(DataRouterContext.Provider, { value: dataRouterContext }, React32.createElement(DataRouterStateContext.Provider, { value: state }, React32.createElement(FetchersContext.Provider, { value: fetcherData.current }, React32.createElement(ViewTransitionContext.Provider, { value: vtContext }, React32.createElement(
        Router,
        {
          basename,
          location: state.location,
          navigationType: state.historyAction,
          navigator
        },
        React32.createElement(
          MemoizedDataRoutes,
          {
            routes: router.routes,
            future: router.future,
            state
          }
        )
      ))))), null);
    }
    var MemoizedDataRoutes = React32.memo(DataRoutes);
    function DataRoutes({
      routes,
      future,
      state
    }) {
      return useRoutesImpl(routes, void 0, state, future);
    }
    function MemoryRouter({
      basename,
      children,
      initialEntries,
      initialIndex
    }) {
      let historyRef = React32.useRef();
      if (historyRef.current == null) {
        historyRef.current = createMemoryHistory({
          initialEntries,
          initialIndex,
          v5Compat: true
        });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = React32.useState({
        action: history.action,
        location: history.location
      });
      let setState = React32.useCallback(
        (newState) => {
          React32.startTransition(() => setStateImpl(newState));
        },
        [setStateImpl]
      );
      React32.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return React32.createElement(
        Router,
        {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        }
      );
    }
    function Navigate({
      to,
      replace: replace2,
      state,
      relative
    }) {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of
        // the router loaded. We can help them understand how to avoid that.
        `<Navigate> may be used only in the context of a <Router> component.`
      );
      let { static: isStatic } = React32.useContext(NavigationContext);
      warning(
        !isStatic,
        `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`
      );
      let { matches } = React32.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let navigate = useNavigate();
      let path = resolveTo(
        to,
        getResolveToMatches(matches),
        locationPathname,
        relative === "path"
      );
      let jsonPath = JSON.stringify(path);
      React32.useEffect(() => {
        navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });
      }, [navigate, jsonPath, relative, replace2, state]);
      return null;
    }
    function Outlet(props) {
      return useOutlet(props.context);
    }
    function Route(_props) {
      invariant(
        false,
        `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
      );
    }
    function Router({
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = "POP",
      navigator,
      static: staticProp = false
    }) {
      invariant(
        !useInRouterContext(),
        `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
      );
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = React32.useMemo(
        () => ({
          basename,
          navigator,
          static: staticProp,
          future: {}
        }),
        [basename, navigator, staticProp]
      );
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = React32.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash, state, key, navigationType]);
      warning(
        locationContext != null,
        `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
      );
      if (locationContext == null) {
        return null;
      }
      return React32.createElement(NavigationContext.Provider, { value: navigationContext }, React32.createElement(LocationContext.Provider, { children, value: locationContext }));
    }
    function Routes({
      children,
      location
    }) {
      return useRoutes(createRoutesFromChildren(children), location);
    }
    function Await({
      children,
      errorElement,
      resolve
    }) {
      return React32.createElement(AwaitErrorBoundary, { resolve, errorElement }, React32.createElement(ResolveAwait, null, children));
    }
    var AwaitErrorBoundary = class extends React32.Component {
      constructor(props) {
        super(props);
        this.state = { error: null };
      }
      static getDerivedStateFromError(error) {
        return { error };
      }
      componentDidCatch(error, errorInfo) {
        console.error(
          "<Await> caught the following error during render",
          error,
          errorInfo
        );
      }
      render() {
        let { children, errorElement, resolve } = this.props;
        let promise = null;
        let status = 0;
        if (!(resolve instanceof Promise)) {
          status = 1;
          promise = Promise.resolve();
          Object.defineProperty(promise, "_tracked", { get: () => true });
          Object.defineProperty(promise, "_data", { get: () => resolve });
        } else if (this.state.error) {
          status = 2;
          let renderError = this.state.error;
          promise = Promise.reject().catch(() => {
          });
          Object.defineProperty(promise, "_tracked", { get: () => true });
          Object.defineProperty(promise, "_error", { get: () => renderError });
        } else if (resolve._tracked) {
          promise = resolve;
          status = "_error" in promise ? 2 : "_data" in promise ? 1 : 0;
        } else {
          status = 0;
          Object.defineProperty(resolve, "_tracked", { get: () => true });
          promise = resolve.then(
            (data2) => Object.defineProperty(resolve, "_data", { get: () => data2 }),
            (error) => Object.defineProperty(resolve, "_error", { get: () => error })
          );
        }
        if (status === 2 && !errorElement) {
          throw promise._error;
        }
        if (status === 2) {
          return React32.createElement(AwaitContext.Provider, { value: promise, children: errorElement });
        }
        if (status === 1) {
          return React32.createElement(AwaitContext.Provider, { value: promise, children });
        }
        throw promise;
      }
    };
    function ResolveAwait({
      children
    }) {
      let data2 = useAsyncValue();
      let toRender = typeof children === "function" ? children(data2) : children;
      return React32.createElement(React32.Fragment, null, toRender);
    }
    function createRoutesFromChildren(children, parentPath = []) {
      let routes = [];
      React32.Children.forEach(children, (element, index) => {
        if (!React32.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index];
        if (element.type === React32.Fragment) {
          routes.push.apply(
            routes,
            createRoutesFromChildren(element.props.children, treePath)
          );
          return;
        }
        invariant(
          element.type === Route,
          `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
        );
        invariant(
          !element.props.index || !element.props.children,
          "An index route cannot have child routes."
        );
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          loader: element.props.loader,
          action: element.props.action,
          hydrateFallbackElement: element.props.hydrateFallbackElement,
          HydrateFallback: element.props.HydrateFallback,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(
            element.props.children,
            treePath
          );
        }
        routes.push(route);
      });
      return routes;
    }
    var createRoutesFromElements = createRoutesFromChildren;
    function renderMatches(matches) {
      return _renderMatches(matches);
    }
    var React10 = __toESM2(require_react());
    var defaultMethod = "get";
    var defaultEncType = "application/x-www-form-urlencoded";
    function isHtmlElement(object) {
      return object != null && typeof object.tagName === "string";
    }
    function isButtonElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
    }
    function isFormElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
    }
    function isInputElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    function createSearchParams(init = "") {
      return new URLSearchParams(
        typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {
          let value = init[key];
          return memo2.concat(
            Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]
          );
        }, [])
      );
    }
    function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
      let searchParams = createSearchParams(locationSearch);
      if (defaultSearchParams) {
        defaultSearchParams.forEach((_, key) => {
          if (!searchParams.has(key)) {
            defaultSearchParams.getAll(key).forEach((value) => {
              searchParams.append(key, value);
            });
          }
        });
      }
      return searchParams;
    }
    var _formDataSupportsSubmitter = null;
    function isFormDataSubmitterSupported() {
      if (_formDataSupportsSubmitter === null) {
        try {
          new FormData(
            document.createElement("form"),
            // @ts-expect-error if FormData supports the submitter parameter, this will throw
            0
          );
          _formDataSupportsSubmitter = false;
        } catch (e) {
          _formDataSupportsSubmitter = true;
        }
      }
      return _formDataSupportsSubmitter;
    }
    var supportedFormEncTypes = /* @__PURE__ */ new Set([
      "application/x-www-form-urlencoded",
      "multipart/form-data",
      "text/plain"
    ]);
    function getFormEncType(encType) {
      if (encType != null && !supportedFormEncTypes.has(encType)) {
        warning(
          false,
          `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
        );
        return null;
      }
      return encType;
    }
    function getFormSubmissionInfo(target, basename) {
      let method;
      let action;
      let encType;
      let formData;
      let body;
      if (isFormElement(target)) {
        let attr = target.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(target);
      } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
        let form = target.form;
        if (form == null) {
          throw new Error(
            `Cannot submit a <button> or <input type="submit"> without a <form>`
          );
        }
        let attr = target.getAttribute("formaction") || form.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(form, target);
        if (!isFormDataSubmitterSupported()) {
          let { name, type, value } = target;
          if (type === "image") {
            let prefix = name ? `${name}.` : "";
            formData.append(`${prefix}x`, "0");
            formData.append(`${prefix}y`, "0");
          } else if (name) {
            formData.append(name, value);
          }
        }
      } else if (isHtmlElement(target)) {
        throw new Error(
          `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
        );
      } else {
        method = defaultMethod;
        action = null;
        encType = defaultEncType;
        body = target;
      }
      if (formData && encType === "text/plain") {
        body = formData;
        formData = void 0;
      }
      return { action, method: method.toLowerCase(), encType, formData, body };
    }
    var React9 = __toESM2(require_react());
    function invariant2(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    async function loadRouteModule(route, routeModulesCache) {
      if (route.id in routeModulesCache) {
        return routeModulesCache[route.id];
      }
      try {
        let routeModule = await import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          route.module
        );
        routeModulesCache[route.id] = routeModule;
        return routeModule;
      } catch (error) {
        console.error(
          `Error loading route module \`${route.module}\`, reloading page...`
        );
        console.error(error);
        if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
        void 0) {
          throw error;
        }
        window.location.reload();
        return new Promise(() => {
        });
      }
    }
    function getKeyedLinksForMatches(matches, routeModules, manifest) {
      let descriptors = matches.map((match) => {
        var _a;
        let module2 = routeModules[match.route.id];
        let route = manifest.routes[match.route.id];
        return [
          route && route.css ? route.css.map((href2) => ({ rel: "stylesheet", href: href2 })) : [],
          ((_a = module2 == null ? void 0 : module2.links) == null ? void 0 : _a.call(module2)) || []
        ];
      }).flat(2);
      let preloads = getModuleLinkHrefs(matches, manifest);
      return dedupeLinkDescriptors(descriptors, preloads);
    }
    function getRouteCssDescriptors(route) {
      if (!route.css) return [];
      return route.css.map((href2) => ({ rel: "stylesheet", href: href2 }));
    }
    async function prefetchRouteCss(route) {
      if (!route.css) return;
      let descriptors = getRouteCssDescriptors(route);
      await Promise.all(descriptors.map(prefetchStyleLink));
    }
    async function prefetchStyleLinks(route, routeModule) {
      if (!route.css && !routeModule.links || !isPreloadSupported()) return;
      let descriptors = [];
      if (route.css) {
        descriptors.push(...getRouteCssDescriptors(route));
      }
      if (routeModule.links) {
        descriptors.push(...routeModule.links());
      }
      if (descriptors.length === 0) return;
      let styleLinks = [];
      for (let descriptor of descriptors) {
        if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
          styleLinks.push({
            ...descriptor,
            rel: "preload",
            as: "style"
          });
        }
      }
      await Promise.all(styleLinks.map(prefetchStyleLink));
    }
    async function prefetchStyleLink(descriptor) {
      return new Promise((resolve) => {
        if (descriptor.media && !window.matchMedia(descriptor.media).matches || document.querySelector(
          `link[rel="stylesheet"][href="${descriptor.href}"]`
        )) {
          return resolve();
        }
        let link = document.createElement("link");
        Object.assign(link, descriptor);
        function removeLink() {
          if (document.head.contains(link)) {
            document.head.removeChild(link);
          }
        }
        link.onload = () => {
          removeLink();
          resolve();
        };
        link.onerror = () => {
          removeLink();
          resolve();
        };
        document.head.appendChild(link);
      });
    }
    function isPageLinkDescriptor(object) {
      return object != null && typeof object.page === "string";
    }
    function isHtmlLinkDescriptor(object) {
      if (object == null) {
        return false;
      }
      if (object.href == null) {
        return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
      }
      return typeof object.rel === "string" && typeof object.href === "string";
    }
    async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
      let links = await Promise.all(
        matches.map(async (match) => {
          let route = manifest.routes[match.route.id];
          if (route) {
            let mod = await loadRouteModule(route, routeModules);
            return mod.links ? mod.links() : [];
          }
          return [];
        })
      );
      return dedupeLinkDescriptors(
        links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
          (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
        )
      );
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
      let isNew = (match, index) => {
        if (!currentMatches[index]) return true;
        return match.route.id !== currentMatches[index].route.id;
      };
      let matchPathChanged = (match, index) => {
        var _a;
        return (
          // param change, /users/123 -> /users/456
          currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
          // e.g. /files/images/avatar.jpg -> files/finances.xls
          ((_a = currentMatches[index].route.path) == null ? void 0 : _a.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
        );
      };
      if (mode === "assets") {
        return nextMatches.filter(
          (match, index) => isNew(match, index) || matchPathChanged(match, index)
        );
      }
      if (mode === "data") {
        return nextMatches.filter((match, index) => {
          var _a;
          let manifestRoute = manifest.routes[match.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return false;
          }
          if (isNew(match, index) || matchPathChanged(match, index)) {
            return true;
          }
          if (match.route.shouldRevalidate) {
            let routeChoice = match.route.shouldRevalidate({
              currentUrl: new URL(
                location.pathname + location.search + location.hash,
                window.origin
              ),
              currentParams: ((_a = currentMatches[0]) == null ? void 0 : _a.params) || {},
              nextUrl: new URL(page, window.origin),
              nextParams: match.params,
              defaultShouldRevalidate: true
            });
            if (typeof routeChoice === "boolean") {
              return routeChoice;
            }
          }
          return true;
        });
      }
      return [];
    }
    function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
      return dedupeHrefs(
        matches.map((match) => {
          let route = manifest.routes[match.route.id];
          if (!route) return [];
          let hrefs = [route.module];
          if (route.clientActionModule) {
            hrefs = hrefs.concat(route.clientActionModule);
          }
          if (route.clientLoaderModule) {
            hrefs = hrefs.concat(route.clientLoaderModule);
          }
          if (includeHydrateFallback && route.hydrateFallbackModule) {
            hrefs = hrefs.concat(route.hydrateFallbackModule);
          }
          if (route.imports) {
            hrefs = hrefs.concat(route.imports);
          }
          return hrefs;
        }).flat(1)
      );
    }
    function dedupeHrefs(hrefs) {
      return [...new Set(hrefs)];
    }
    function sortKeys(obj) {
      let sorted = {};
      let keys = Object.keys(obj).sort();
      for (let key of keys) {
        sorted[key] = obj[key];
      }
      return sorted;
    }
    function dedupeLinkDescriptors(descriptors, preloads) {
      let set = /* @__PURE__ */ new Set();
      let preloadsSet = new Set(preloads);
      return descriptors.reduce((deduped, descriptor) => {
        let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
        if (alreadyModulePreload) {
          return deduped;
        }
        let key = JSON.stringify(sortKeys(descriptor));
        if (!set.has(key)) {
          set.add(key);
          deduped.push({ key, link: descriptor });
        }
        return deduped;
      }, []);
    }
    var _isPreloadSupported;
    function isPreloadSupported() {
      if (_isPreloadSupported !== void 0) {
        return _isPreloadSupported;
      }
      let el = document.createElement("link");
      _isPreloadSupported = el.relList.supports("preload");
      el = null;
      return _isPreloadSupported;
    }
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    var ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function escapeHtml(html) {
      return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    function createHtml(html) {
      return { __html: html };
    }
    var React42 = __toESM2(require_react());
    var HOLE = -1;
    var NAN = -2;
    var NEGATIVE_INFINITY = -3;
    var NEGATIVE_ZERO = -4;
    var NULL = -5;
    var POSITIVE_INFINITY = -6;
    var UNDEFINED = -7;
    var TYPE_BIGINT = "B";
    var TYPE_DATE = "D";
    var TYPE_ERROR = "E";
    var TYPE_MAP = "M";
    var TYPE_NULL_OBJECT = "N";
    var TYPE_PROMISE = "P";
    var TYPE_REGEXP = "R";
    var TYPE_SET = "S";
    var TYPE_SYMBOL = "Y";
    var TYPE_URL = "U";
    var TYPE_PREVIOUS_RESOLVED = "Z";
    var Deferred2 = class {
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
    };
    function createLineSplittingTransform() {
      const decoder = new TextDecoder();
      let leftover = "";
      return new TransformStream({
        transform(chunk, controller) {
          const str = decoder.decode(chunk, { stream: true });
          const parts = (leftover + str).split("\n");
          leftover = parts.pop() || "";
          for (const part of parts) {
            controller.enqueue(part);
          }
        },
        flush(controller) {
          if (leftover) {
            controller.enqueue(leftover);
          }
        }
      });
    }
    function flatten(input) {
      const { indices } = this;
      const existing = indices.get(input);
      if (existing) return [existing];
      if (input === void 0) return UNDEFINED;
      if (input === null) return NULL;
      if (Number.isNaN(input)) return NAN;
      if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;
      if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;
      if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;
      const index = this.index++;
      indices.set(input, index);
      stringify.call(this, input, index);
      return index;
    }
    function stringify(input, index) {
      const { deferred, plugins, postPlugins } = this;
      const str = this.stringified;
      const stack = [[input, index]];
      while (stack.length > 0) {
        const [input2, index2] = stack.pop();
        const partsForObj = (obj) => Object.keys(obj).map((k) => `"_${flatten.call(this, k)}":${flatten.call(this, obj[k])}`).join(",");
        let error = null;
        switch (typeof input2) {
          case "boolean":
          case "number":
          case "string":
            str[index2] = JSON.stringify(input2);
            break;
          case "bigint":
            str[index2] = `["${TYPE_BIGINT}","${input2}"]`;
            break;
          case "symbol": {
            const keyFor = Symbol.keyFor(input2);
            if (!keyFor) {
              error = new Error(
                "Cannot encode symbol unless created with Symbol.for()"
              );
            } else {
              str[index2] = `["${TYPE_SYMBOL}",${JSON.stringify(keyFor)}]`;
            }
            break;
          }
          case "object": {
            if (!input2) {
              str[index2] = `${NULL}`;
              break;
            }
            const isArray = Array.isArray(input2);
            let pluginHandled = false;
            if (!isArray && plugins) {
              for (const plugin of plugins) {
                const pluginResult = plugin(input2);
                if (Array.isArray(pluginResult)) {
                  pluginHandled = true;
                  const [pluginIdentifier, ...rest] = pluginResult;
                  str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
                  if (rest.length > 0) {
                    str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
                  }
                  str[index2] += "]";
                  break;
                }
              }
            }
            if (!pluginHandled) {
              let result = isArray ? "[" : "{";
              if (isArray) {
                for (let i = 0; i < input2.length; i++)
                  result += (i ? "," : "") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);
                str[index2] = `${result}]`;
              } else if (input2 instanceof Date) {
                str[index2] = `["${TYPE_DATE}",${input2.getTime()}]`;
              } else if (input2 instanceof URL) {
                str[index2] = `["${TYPE_URL}",${JSON.stringify(input2.href)}]`;
              } else if (input2 instanceof RegExp) {
                str[index2] = `["${TYPE_REGEXP}",${JSON.stringify(
                  input2.source
                )},${JSON.stringify(input2.flags)}]`;
              } else if (input2 instanceof Set) {
                if (input2.size > 0) {
                  str[index2] = `["${TYPE_SET}",${[...input2].map((val) => flatten.call(this, val)).join(",")}]`;
                } else {
                  str[index2] = `["${TYPE_SET}"]`;
                }
              } else if (input2 instanceof Map) {
                if (input2.size > 0) {
                  str[index2] = `["${TYPE_MAP}",${[...input2].flatMap(([k, v]) => [
                    flatten.call(this, k),
                    flatten.call(this, v)
                  ]).join(",")}]`;
                } else {
                  str[index2] = `["${TYPE_MAP}"]`;
                }
              } else if (input2 instanceof Promise) {
                str[index2] = `["${TYPE_PROMISE}",${index2}]`;
                deferred[index2] = input2;
              } else if (input2 instanceof Error) {
                str[index2] = `["${TYPE_ERROR}",${JSON.stringify(input2.message)}`;
                if (input2.name !== "Error") {
                  str[index2] += `,${JSON.stringify(input2.name)}`;
                }
                str[index2] += "]";
              } else if (Object.getPrototypeOf(input2) === null) {
                str[index2] = `["${TYPE_NULL_OBJECT}",{${partsForObj(input2)}}]`;
              } else if (isPlainObject(input2)) {
                str[index2] = `{${partsForObj(input2)}}`;
              } else {
                error = new Error("Cannot encode object with prototype");
              }
            }
            break;
          }
          default: {
            const isArray = Array.isArray(input2);
            let pluginHandled = false;
            if (!isArray && plugins) {
              for (const plugin of plugins) {
                const pluginResult = plugin(input2);
                if (Array.isArray(pluginResult)) {
                  pluginHandled = true;
                  const [pluginIdentifier, ...rest] = pluginResult;
                  str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
                  if (rest.length > 0) {
                    str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
                  }
                  str[index2] += "]";
                  break;
                }
              }
            }
            if (!pluginHandled) {
              error = new Error("Cannot encode function or unexpected type");
            }
          }
        }
        if (error) {
          let pluginHandled = false;
          if (postPlugins) {
            for (const plugin of postPlugins) {
              const pluginResult = plugin(input2);
              if (Array.isArray(pluginResult)) {
                pluginHandled = true;
                const [pluginIdentifier, ...rest] = pluginResult;
                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
                if (rest.length > 0) {
                  str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
                }
                str[index2] += "]";
                break;
              }
            }
          }
          if (!pluginHandled) {
            throw error;
          }
        }
      }
    }
    var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    function isPlainObject(thing) {
      const proto = Object.getPrototypeOf(thing);
      return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === objectProtoNames;
    }
    var globalObj = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : void 0;
    function unflatten(parsed) {
      const { hydrated, values } = this;
      if (typeof parsed === "number") return hydrate.call(this, parsed);
      if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();
      const startIndex = values.length;
      for (const value of parsed) {
        values.push(value);
      }
      hydrated.length = values.length;
      return hydrate.call(this, startIndex);
    }
    function hydrate(index) {
      const { hydrated, values, deferred, plugins } = this;
      let result;
      const stack = [
        [
          index,
          (v) => {
            result = v;
          }
        ]
      ];
      let postRun = [];
      while (stack.length > 0) {
        const [index2, set] = stack.pop();
        switch (index2) {
          case UNDEFINED:
            set(void 0);
            continue;
          case NULL:
            set(null);
            continue;
          case NAN:
            set(NaN);
            continue;
          case POSITIVE_INFINITY:
            set(Infinity);
            continue;
          case NEGATIVE_INFINITY:
            set(-Infinity);
            continue;
          case NEGATIVE_ZERO:
            set(-0);
            continue;
        }
        if (hydrated[index2]) {
          set(hydrated[index2]);
          continue;
        }
        const value = values[index2];
        if (!value || typeof value !== "object") {
          hydrated[index2] = value;
          set(value);
          continue;
        }
        if (Array.isArray(value)) {
          if (typeof value[0] === "string") {
            const [type, b, c] = value;
            switch (type) {
              case TYPE_DATE:
                set(hydrated[index2] = new Date(b));
                continue;
              case TYPE_URL:
                set(hydrated[index2] = new URL(b));
                continue;
              case TYPE_BIGINT:
                set(hydrated[index2] = BigInt(b));
                continue;
              case TYPE_REGEXP:
                set(hydrated[index2] = new RegExp(b, c));
                continue;
              case TYPE_SYMBOL:
                set(hydrated[index2] = Symbol.for(b));
                continue;
              case TYPE_SET:
                const newSet = /* @__PURE__ */ new Set();
                hydrated[index2] = newSet;
                for (let i = value.length - 1; i > 0; i--)
                  stack.push([
                    value[i],
                    (v) => {
                      newSet.add(v);
                    }
                  ]);
                set(newSet);
                continue;
              case TYPE_MAP:
                const map = /* @__PURE__ */ new Map();
                hydrated[index2] = map;
                for (let i = value.length - 2; i > 0; i -= 2) {
                  const r = [];
                  stack.push([
                    value[i + 1],
                    (v) => {
                      r[1] = v;
                    }
                  ]);
                  stack.push([
                    value[i],
                    (k) => {
                      r[0] = k;
                    }
                  ]);
                  postRun.push(() => {
                    map.set(r[0], r[1]);
                  });
                }
                set(map);
                continue;
              case TYPE_NULL_OBJECT:
                const obj = /* @__PURE__ */ Object.create(null);
                hydrated[index2] = obj;
                for (const key of Object.keys(b).reverse()) {
                  const r = [];
                  stack.push([
                    b[key],
                    (v) => {
                      r[1] = v;
                    }
                  ]);
                  stack.push([
                    Number(key.slice(1)),
                    (k) => {
                      r[0] = k;
                    }
                  ]);
                  postRun.push(() => {
                    obj[r[0]] = r[1];
                  });
                }
                set(obj);
                continue;
              case TYPE_PROMISE:
                if (hydrated[b]) {
                  set(hydrated[index2] = hydrated[b]);
                } else {
                  const d = new Deferred2();
                  deferred[b] = d;
                  set(hydrated[index2] = d.promise);
                }
                continue;
              case TYPE_ERROR:
                const [, message, errorType] = value;
                let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);
                hydrated[index2] = error;
                set(error);
                continue;
              case TYPE_PREVIOUS_RESOLVED:
                set(hydrated[index2] = hydrated[b]);
                continue;
              default:
                if (Array.isArray(plugins)) {
                  const r = [];
                  const vals = value.slice(1);
                  for (let i = 0; i < vals.length; i++) {
                    const v = vals[i];
                    stack.push([
                      v,
                      (v2) => {
                        r[i] = v2;
                      }
                    ]);
                  }
                  postRun.push(() => {
                    for (const plugin of plugins) {
                      const result2 = plugin(value[0], ...r);
                      if (result2) {
                        set(hydrated[index2] = result2.value);
                        return;
                      }
                    }
                    throw new SyntaxError();
                  });
                  continue;
                }
                throw new SyntaxError();
            }
          } else {
            const array = [];
            hydrated[index2] = array;
            for (let i = 0; i < value.length; i++) {
              const n = value[i];
              if (n !== HOLE) {
                stack.push([
                  n,
                  (v) => {
                    array[i] = v;
                  }
                ]);
              }
            }
            set(array);
            continue;
          }
        } else {
          const object = {};
          hydrated[index2] = object;
          for (const key of Object.keys(value).reverse()) {
            const r = [];
            stack.push([
              value[key],
              (v) => {
                r[1] = v;
              }
            ]);
            stack.push([
              Number(key.slice(1)),
              (k) => {
                r[0] = k;
              }
            ]);
            postRun.push(() => {
              object[r[0]] = r[1];
            });
          }
          set(object);
          continue;
        }
      }
      while (postRun.length > 0) {
        postRun.pop()();
      }
      return result;
    }
    async function decode(readable, options) {
      const { plugins } = options ?? {};
      const done = new Deferred2();
      const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();
      const decoder = {
        values: [],
        hydrated: [],
        deferred: {},
        plugins
      };
      const decoded = await decodeInitial.call(decoder, reader);
      let donePromise = done.promise;
      if (decoded.done) {
        done.resolve();
      } else {
        donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {
          for (const deferred of Object.values(decoder.deferred)) {
            deferred.reject(reason);
          }
          done.reject(reason);
        });
      }
      return {
        done: donePromise.then(() => reader.closed),
        value: decoded.value
      };
    }
    async function decodeInitial(reader) {
      const read = await reader.read();
      if (!read.value) {
        throw new SyntaxError();
      }
      let line;
      try {
        line = JSON.parse(read.value);
      } catch (reason) {
        throw new SyntaxError();
      }
      return {
        done: read.done,
        value: unflatten.call(this, line)
      };
    }
    async function decodeDeferred(reader) {
      let read = await reader.read();
      while (!read.done) {
        if (!read.value) continue;
        const line = read.value;
        switch (line[0]) {
          case TYPE_PROMISE: {
            const colonIndex = line.indexOf(":");
            const deferredId = Number(line.slice(1, colonIndex));
            const deferred = this.deferred[deferredId];
            if (!deferred) {
              throw new Error(`Deferred ID ${deferredId} not found in stream`);
            }
            const lineData = line.slice(colonIndex + 1);
            let jsonLine;
            try {
              jsonLine = JSON.parse(lineData);
            } catch (reason) {
              throw new SyntaxError();
            }
            const value = unflatten.call(this, jsonLine);
            deferred.resolve(value);
            break;
          }
          case TYPE_ERROR: {
            const colonIndex = line.indexOf(":");
            const deferredId = Number(line.slice(1, colonIndex));
            const deferred = this.deferred[deferredId];
            if (!deferred) {
              throw new Error(`Deferred ID ${deferredId} not found in stream`);
            }
            const lineData = line.slice(colonIndex + 1);
            let jsonLine;
            try {
              jsonLine = JSON.parse(lineData);
            } catch (reason) {
              throw new SyntaxError();
            }
            const value = unflatten.call(this, jsonLine);
            deferred.reject(value);
            break;
          }
          default:
            throw new SyntaxError();
        }
        read = await reader.read();
      }
    }
    function encode(input, options) {
      const { plugins, postPlugins, signal } = options ?? {};
      const encoder2 = {
        deferred: {},
        index: 0,
        indices: /* @__PURE__ */ new Map(),
        stringified: [],
        plugins,
        postPlugins,
        signal
      };
      const textEncoder = new TextEncoder();
      let lastSentIndex = 0;
      const readable = new ReadableStream({
        async start(controller) {
          const id = flatten.call(encoder2, input);
          if (Array.isArray(id)) {
            throw new Error("This should never happen");
          }
          if (id < 0) {
            controller.enqueue(textEncoder.encode(`${id}
`));
          } else {
            controller.enqueue(
              textEncoder.encode(`[${encoder2.stringified.join(",")}]
`)
            );
            lastSentIndex = encoder2.stringified.length - 1;
          }
          const seenPromises = /* @__PURE__ */ new WeakSet();
          if (Object.keys(encoder2.deferred).length) {
            let raceDone;
            const racePromise = new Promise((resolve, reject) => {
              raceDone = resolve;
              if (signal) {
                const rejectPromise = () => reject(signal.reason || new Error("Signal was aborted."));
                if (signal.aborted) {
                  rejectPromise();
                } else {
                  signal.addEventListener("abort", (event) => {
                    rejectPromise();
                  });
                }
              }
            });
            while (Object.keys(encoder2.deferred).length > 0) {
              for (const [deferredId, deferred] of Object.entries(
                encoder2.deferred
              )) {
                if (seenPromises.has(deferred)) continue;
                seenPromises.add(
                  // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
                  encoder2.deferred[Number(deferredId)] = Promise.race([
                    racePromise,
                    deferred
                  ]).then(
                    (resolved) => {
                      const id2 = flatten.call(encoder2, resolved);
                      if (Array.isArray(id2)) {
                        controller.enqueue(
                          textEncoder.encode(
                            `${TYPE_PROMISE}${deferredId}:[["${TYPE_PREVIOUS_RESOLVED}",${id2[0]}]]
`
                          )
                        );
                        encoder2.index++;
                        lastSentIndex++;
                      } else if (id2 < 0) {
                        controller.enqueue(
                          textEncoder.encode(
                            `${TYPE_PROMISE}${deferredId}:${id2}
`
                          )
                        );
                      } else {
                        const values = encoder2.stringified.slice(lastSentIndex + 1).join(",");
                        controller.enqueue(
                          textEncoder.encode(
                            `${TYPE_PROMISE}${deferredId}:[${values}]
`
                          )
                        );
                        lastSentIndex = encoder2.stringified.length - 1;
                      }
                    },
                    (reason) => {
                      if (!reason || typeof reason !== "object" || !(reason instanceof Error)) {
                        reason = new Error("An unknown error occurred");
                      }
                      const id2 = flatten.call(encoder2, reason);
                      if (Array.isArray(id2)) {
                        controller.enqueue(
                          textEncoder.encode(
                            `${TYPE_ERROR}${deferredId}:[["${TYPE_PREVIOUS_RESOLVED}",${id2[0]}]]
`
                          )
                        );
                        encoder2.index++;
                        lastSentIndex++;
                      } else if (id2 < 0) {
                        controller.enqueue(
                          textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}
`)
                        );
                      } else {
                        const values = encoder2.stringified.slice(lastSentIndex + 1).join(",");
                        controller.enqueue(
                          textEncoder.encode(
                            `${TYPE_ERROR}${deferredId}:[${values}]
`
                          )
                        );
                        lastSentIndex = encoder2.stringified.length - 1;
                      }
                    }
                  ).finally(() => {
                    delete encoder2.deferred[Number(deferredId)];
                  })
                );
              }
              await Promise.race(Object.values(encoder2.deferred));
            }
            raceDone();
          }
          await Promise.all(Object.values(encoder2.deferred));
          controller.close();
        }
      });
      return readable;
    }
    async function createRequestInit(request) {
      let init = { signal: request.signal };
      if (request.method !== "GET") {
        init.method = request.method;
        let contentType = request.headers.get("Content-Type");
        if (contentType && /\bapplication\/json\b/.test(contentType)) {
          init.headers = { "Content-Type": contentType };
          init.body = JSON.stringify(await request.json());
        } else if (contentType && /\btext\/plain\b/.test(contentType)) {
          init.headers = { "Content-Type": contentType };
          init.body = await request.text();
        } else if (contentType && /\bapplication\/x-www-form-urlencoded\b/.test(contentType)) {
          init.body = new URLSearchParams(await request.text());
        } else {
          init.body = await request.formData();
        }
      }
      return init;
    }
    var SingleFetchRedirectSymbol = Symbol("SingleFetchRedirect");
    var SingleFetchNoResultError = class extends Error {
    };
    var SINGLE_FETCH_REDIRECT_STATUS = 202;
    var NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205]);
    function StreamTransfer({
      context,
      identifier,
      reader,
      textDecoder,
      nonce
    }) {
      if (!context.renderMeta || !context.renderMeta.didRenderScripts) {
        return null;
      }
      if (!context.renderMeta.streamCache) {
        context.renderMeta.streamCache = {};
      }
      let { streamCache } = context.renderMeta;
      let promise = streamCache[identifier];
      if (!promise) {
        promise = streamCache[identifier] = reader.read().then((result) => {
          streamCache[identifier].result = {
            done: result.done,
            value: textDecoder.decode(result.value, { stream: true })
          };
        }).catch((e) => {
          streamCache[identifier].error = e;
        });
      }
      if (promise.error) {
        throw promise.error;
      }
      if (promise.result === void 0) {
        throw promise;
      }
      let { done, value } = promise.result;
      let scriptTag = value ? React42.createElement(
        "script",
        {
          nonce,
          dangerouslySetInnerHTML: {
            __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(
              JSON.stringify(value)
            )});`
          }
        }
      ) : null;
      if (done) {
        return React42.createElement(React42.Fragment, null, scriptTag, React42.createElement(
          "script",
          {
            nonce,
            dangerouslySetInnerHTML: {
              __html: `window.__reactRouterContext.streamController.close();`
            }
          }
        ));
      } else {
        return React42.createElement(React42.Fragment, null, scriptTag, React42.createElement(React42.Suspense, null, React42.createElement(
          StreamTransfer,
          {
            context,
            identifier: identifier + 1,
            reader,
            textDecoder,
            nonce
          }
        )));
      }
    }
    function getTurboStreamSingleFetchDataStrategy(getRouter, manifest, routeModules, ssr, basename) {
      let dataStrategy = getSingleFetchDataStrategyImpl(
        getRouter,
        (match) => {
          let manifestRoute = manifest.routes[match.route.id];
          invariant2(manifestRoute, "Route not found in manifest");
          let routeModule = routeModules[match.route.id];
          return {
            hasLoader: manifestRoute.hasLoader,
            hasClientLoader: manifestRoute.hasClientLoader,
            hasShouldRevalidate: Boolean(routeModule == null ? void 0 : routeModule.shouldRevalidate)
          };
        },
        fetchAndDecodeViaTurboStream,
        ssr,
        basename
      );
      return async (args) => args.unstable_runClientMiddleware(dataStrategy);
    }
    function getSingleFetchDataStrategyImpl(getRouter, getRouteInfo, fetchAndDecode, ssr, basename) {
      return async (args) => {
        let { request, matches, fetcherKey } = args;
        let router = getRouter();
        if (request.method !== "GET") {
          return singleFetchActionStrategy(args, fetchAndDecode, basename);
        }
        let foundRevalidatingServerLoader = matches.some((m) => {
          let { hasLoader, hasClientLoader } = getRouteInfo(m);
          return m.unstable_shouldCallHandler() && hasLoader && !hasClientLoader;
        });
        if (!ssr && !foundRevalidatingServerLoader) {
          return nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename);
        }
        if (fetcherKey) {
          return singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename);
        }
        return singleFetchLoaderNavigationStrategy(
          args,
          router,
          getRouteInfo,
          fetchAndDecode,
          ssr,
          basename
        );
      };
    }
    async function singleFetchActionStrategy(args, fetchAndDecode, basename) {
      let actionMatch = args.matches.find((m) => m.unstable_shouldCallHandler());
      invariant2(actionMatch, "No action match found");
      let actionStatus = void 0;
      let result = await actionMatch.resolve(async (handler) => {
        let result2 = await handler(async () => {
          let { data: data2, status } = await fetchAndDecode(args, basename, [
            actionMatch.route.id
          ]);
          actionStatus = status;
          return unwrapSingleFetchResult(data2, actionMatch.route.id);
        });
        return result2;
      });
      if (isResponse(result.result) || isRouteErrorResponse(result.result) || isDataWithResponseInit(result.result)) {
        return { [actionMatch.route.id]: result };
      }
      return {
        [actionMatch.route.id]: {
          type: result.type,
          result: data(result.result, actionStatus)
        }
      };
    }
    async function nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename) {
      let matchesToLoad = args.matches.filter(
        (m) => m.unstable_shouldCallHandler()
      );
      let results = {};
      await Promise.all(
        matchesToLoad.map(
          (m) => m.resolve(async (handler) => {
            try {
              let { hasClientLoader } = getRouteInfo(m);
              let routeId = m.route.id;
              let result = hasClientLoader ? await handler(async () => {
                let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);
                return unwrapSingleFetchResult(data2, routeId);
              }) : await handler();
              results[m.route.id] = { type: "data", result };
            } catch (e) {
              results[m.route.id] = { type: "error", result: e };
            }
          })
        )
      );
      return results;
    }
    async function singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename) {
      let routesParams = /* @__PURE__ */ new Set();
      let foundOptOutRoute = false;
      let routeDfds = args.matches.map(() => createDeferred2());
      let singleFetchDfd = createDeferred2();
      let results = {};
      let resolvePromise = Promise.all(
        args.matches.map(
          async (m, i) => m.resolve(async (handler) => {
            routeDfds[i].resolve();
            let routeId = m.route.id;
            let { hasLoader, hasClientLoader, hasShouldRevalidate } = getRouteInfo(m);
            let defaultShouldRevalidate = !m.unstable_shouldRevalidateArgs || m.unstable_shouldRevalidateArgs.actionStatus == null || m.unstable_shouldRevalidateArgs.actionStatus < 400;
            let shouldCall = m.unstable_shouldCallHandler(defaultShouldRevalidate);
            if (!shouldCall) {
              foundOptOutRoute || (foundOptOutRoute = m.unstable_shouldRevalidateArgs != null && // This is a revalidation,
              hasLoader && // for a route with a server loader,
              hasShouldRevalidate === true);
              return;
            }
            if (hasClientLoader) {
              if (hasLoader) {
                foundOptOutRoute = true;
              }
              try {
                let result = await handler(async () => {
                  let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);
                  return unwrapSingleFetchResult(data2, routeId);
                });
                results[routeId] = { type: "data", result };
              } catch (e) {
                results[routeId] = { type: "error", result: e };
              }
              return;
            }
            if (hasLoader) {
              routesParams.add(routeId);
            }
            try {
              let result = await handler(async () => {
                let data2 = await singleFetchDfd.promise;
                return unwrapSingleFetchResult(data2, routeId);
              });
              results[routeId] = { type: "data", result };
            } catch (e) {
              results[routeId] = { type: "error", result: e };
            }
          })
        )
      );
      await Promise.all(routeDfds.map((d) => d.promise));
      let isInitialLoad = !router.state.initialized && router.state.navigation.state === "idle";
      if ((isInitialLoad || routesParams.size === 0) && !window.__reactRouterHdrActive) {
        singleFetchDfd.resolve({ routes: {} });
      } else {
        let targetRoutes = ssr && foundOptOutRoute && routesParams.size > 0 ? [...routesParams.keys()] : void 0;
        try {
          let data2 = await fetchAndDecode(args, basename, targetRoutes);
          singleFetchDfd.resolve(data2.data);
        } catch (e) {
          singleFetchDfd.reject(e);
        }
      }
      await resolvePromise;
      await bubbleMiddlewareErrors(
        singleFetchDfd.promise,
        args.matches,
        routesParams,
        results
      );
      return results;
    }
    async function bubbleMiddlewareErrors(singleFetchPromise, matches, routesParams, results) {
      try {
        let middlewareError;
        let fetchedData = await singleFetchPromise;
        if ("routes" in fetchedData) {
          for (let match of matches) {
            if (match.route.id in fetchedData.routes) {
              let routeResult = fetchedData.routes[match.route.id];
              if ("error" in routeResult) {
                middlewareError = routeResult.error;
                break;
              }
            }
          }
        }
        if (middlewareError !== void 0) {
          Array.from(routesParams.values()).forEach((routeId) => {
            if (results[routeId].result instanceof SingleFetchNoResultError) {
              results[routeId].result = middlewareError;
            }
          });
        }
      } catch (e) {
      }
    }
    async function singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename) {
      let fetcherMatch = args.matches.find((m) => m.unstable_shouldCallHandler());
      invariant2(fetcherMatch, "No fetcher match found");
      let routeId = fetcherMatch.route.id;
      let result = await fetcherMatch.resolve(
        async (handler) => handler(async () => {
          let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);
          return unwrapSingleFetchResult(data2, routeId);
        })
      );
      return { [fetcherMatch.route.id]: result };
    }
    function stripIndexParam(url) {
      let indexValues = url.searchParams.getAll("index");
      url.searchParams.delete("index");
      let indexValuesToKeep = [];
      for (let indexValue of indexValues) {
        if (indexValue) {
          indexValuesToKeep.push(indexValue);
        }
      }
      for (let toKeep of indexValuesToKeep) {
        url.searchParams.append("index", toKeep);
      }
      return url;
    }
    function singleFetchUrl(reqUrl, basename) {
      let url = typeof reqUrl === "string" ? new URL(
        reqUrl,
        // This can be called during the SSR flow via PrefetchPageLinksImpl so
        // don't assume window is available
        typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
      ) : reqUrl;
      if (url.pathname === "/") {
        url.pathname = "_root.data";
      } else if (basename && stripBasename(url.pathname, basename) === "/") {
        url.pathname = `${basename.replace(/\/$/, "")}/_root.data`;
      } else {
        url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
      }
      return url;
    }
    async function fetchAndDecodeViaTurboStream(args, basename, targetRoutes) {
      let { request } = args;
      let url = singleFetchUrl(request.url, basename);
      if (request.method === "GET") {
        url = stripIndexParam(url);
        if (targetRoutes) {
          url.searchParams.set("_routes", targetRoutes.join(","));
        }
      }
      let res = await fetch(url, await createRequestInit(request));
      if (res.status === 404 && !res.headers.has("X-Remix-Response")) {
        throw new ErrorResponseImpl(404, "Not Found", true);
      }
      if (res.status === 204 && res.headers.has("X-Remix-Redirect")) {
        return {
          status: SINGLE_FETCH_REDIRECT_STATUS,
          data: {
            redirect: {
              redirect: res.headers.get("X-Remix-Redirect"),
              status: Number(res.headers.get("X-Remix-Status") || "302"),
              revalidate: res.headers.get("X-Remix-Revalidate") === "true",
              reload: res.headers.get("X-Remix-Reload-Document") === "true",
              replace: res.headers.get("X-Remix-Replace") === "true"
            }
          }
        };
      }
      if (NO_BODY_STATUS_CODES.has(res.status)) {
        let routes = {};
        if (targetRoutes && request.method !== "GET") {
          routes[targetRoutes[0]] = { data: void 0 };
        }
        return {
          status: res.status,
          data: { routes }
        };
      }
      invariant2(res.body, "No response body to decode");
      try {
        let decoded = await decodeViaTurboStream(res.body, window);
        let data2;
        if (request.method === "GET") {
          let typed = decoded.value;
          if (SingleFetchRedirectSymbol in typed) {
            data2 = { redirect: typed[SingleFetchRedirectSymbol] };
          } else {
            data2 = { routes: typed };
          }
        } else {
          let typed = decoded.value;
          let routeId = targetRoutes == null ? void 0 : targetRoutes[0];
          invariant2(routeId, "No routeId found for single fetch call decoding");
          if ("redirect" in typed) {
            data2 = { redirect: typed };
          } else {
            data2 = { routes: { [routeId]: typed } };
          }
        }
        return { status: res.status, data: data2 };
      } catch (e) {
        throw new Error("Unable to decode turbo-stream response");
      }
    }
    function decodeViaTurboStream(body, global2) {
      return decode(body, {
        plugins: [
          (type, ...rest) => {
            if (type === "SanitizedError") {
              let [name, message, stack] = rest;
              let Constructor = Error;
              if (name && name in global2 && typeof global2[name] === "function") {
                Constructor = global2[name];
              }
              let error = new Constructor(message);
              error.stack = stack;
              return { value: error };
            }
            if (type === "ErrorResponse") {
              let [data2, status, statusText] = rest;
              return {
                value: new ErrorResponseImpl(status, statusText, data2)
              };
            }
            if (type === "SingleFetchRedirect") {
              return { value: { [SingleFetchRedirectSymbol]: rest[0] } };
            }
            if (type === "SingleFetchClassInstance") {
              return { value: rest[0] };
            }
            if (type === "SingleFetchFallback") {
              return { value: void 0 };
            }
          }
        ]
      });
    }
    function unwrapSingleFetchResult(result, routeId) {
      if ("redirect" in result) {
        let {
          redirect: location,
          revalidate,
          reload,
          replace: replace2,
          status
        } = result.redirect;
        throw redirect(location, {
          status,
          headers: {
            // Three R's of redirecting (lol Veep)
            ...revalidate ? { "X-Remix-Revalidate": "yes" } : null,
            ...reload ? { "X-Remix-Reload-Document": "yes" } : null,
            ...replace2 ? { "X-Remix-Replace": "yes" } : null
          }
        });
      }
      let routeResult = result.routes[routeId];
      if (routeResult == null) {
        throw new SingleFetchNoResultError(
          `No result found for routeId "${routeId}"`
        );
      } else if ("error" in routeResult) {
        throw routeResult.error;
      } else if ("data" in routeResult) {
        return routeResult.data;
      } else {
        throw new Error(`Invalid response found for routeId "${routeId}"`);
      }
    }
    function createDeferred2() {
      let resolve;
      let reject;
      let promise = new Promise((res, rej) => {
        resolve = async (val) => {
          res(val);
          try {
            await promise;
          } catch (e) {
          }
        };
        reject = async (error) => {
          rej(error);
          try {
            await promise;
          } catch (e) {
          }
        };
      });
      return {
        promise,
        //@ts-ignore
        resolve,
        //@ts-ignore
        reject
      };
    }
    var React8 = __toESM2(require_react());
    var React7 = __toESM2(require_react());
    var React52 = __toESM2(require_react());
    var RemixErrorBoundary = class extends React52.Component {
      constructor(props) {
        super(props);
        this.state = { error: props.error || null, location: props.location };
      }
      static getDerivedStateFromError(error) {
        return { error };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location) {
          return { error: props.error || null, location: props.location };
        }
        return { error: props.error || state.error, location: state.location };
      }
      render() {
        if (this.state.error) {
          return React52.createElement(
            RemixRootDefaultErrorBoundary,
            {
              error: this.state.error,
              isOutsideRemixApp: true
            }
          );
        } else {
          return this.props.children;
        }
      }
    };
    function RemixRootDefaultErrorBoundary({
      error,
      isOutsideRemixApp
    }) {
      console.error(error);
      let heyDeveloper = React52.createElement(
        "script",
        {
          dangerouslySetInnerHTML: {
            __html: `
        console.log(
          "💿 Hey developer 👋. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."
        );
      `
          }
        }
      );
      if (isRouteErrorResponse(error)) {
        return React52.createElement(BoundaryShell, { title: "Unhandled Thrown Response!" }, React52.createElement("h1", { style: { fontSize: "24px" } }, error.status, " ", error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);
      }
      let errorInstance;
      if (error instanceof Error) {
        errorInstance = error;
      } else {
        let errorString = error == null ? "Unknown Error" : typeof error === "object" && "toString" in error ? error.toString() : JSON.stringify(error);
        errorInstance = new Error(errorString);
      }
      return React52.createElement(
        BoundaryShell,
        {
          title: "Application Error!",
          isOutsideRemixApp
        },
        React52.createElement("h1", { style: { fontSize: "24px" } }, "Application Error"),
        React52.createElement(
          "pre",
          {
            style: {
              padding: "2rem",
              background: "hsla(10, 50%, 50%, 0.1)",
              color: "red",
              overflow: "auto"
            }
          },
          errorInstance.stack
        ),
        heyDeveloper
      );
    }
    function BoundaryShell({
      title,
      renderScripts,
      isOutsideRemixApp,
      children
    }) {
      var _a;
      let { routeModules } = useFrameworkContext();
      if (((_a = routeModules.root) == null ? void 0 : _a.Layout) && !isOutsideRemixApp) {
        return children;
      }
      return React52.createElement("html", { lang: "en" }, React52.createElement("head", null, React52.createElement("meta", { charSet: "utf-8" }), React52.createElement(
        "meta",
        {
          name: "viewport",
          content: "width=device-width,initial-scale=1,viewport-fit=cover"
        }
      ), React52.createElement("title", null, title)), React52.createElement("body", null, React52.createElement("main", { style: { fontFamily: "system-ui, sans-serif", padding: "2rem" } }, children, renderScripts ? React52.createElement(Scripts, null) : null)));
    }
    var React6 = __toESM2(require_react());
    function RemixRootDefaultHydrateFallback() {
      return React6.createElement(BoundaryShell, { title: "Loading...", renderScripts: true }, ENABLE_DEV_WARNINGS ? React6.createElement(
        "script",
        {
          dangerouslySetInnerHTML: {
            __html: `
              console.log(
                "💿 Hey developer 👋. You can provide a way better UX than this " +
                "when your app is loading JS modules and/or running \`clientLoader\` " +
                "functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback " +
                "for more information."
              );
            `
          }
        }
      ) : null);
    }
    function groupRoutesByParentId(manifest) {
      let routes = {};
      Object.values(manifest).forEach((route) => {
        if (route) {
          let parentId = route.parentId || "";
          if (!routes[parentId]) {
            routes[parentId] = [];
          }
          routes[parentId].push(route);
        }
      });
      return routes;
    }
    function getRouteComponents(route, routeModule, isSpaMode) {
      let Component4 = getRouteModuleComponent(routeModule);
      let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === "root") ? routeModule.HydrateFallback : route.id === "root" ? RemixRootDefaultHydrateFallback : void 0;
      let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === "root" ? () => React7.createElement(RemixRootDefaultErrorBoundary, { error: useRouteError() }) : void 0;
      if (route.id === "root" && routeModule.Layout) {
        return {
          ...Component4 ? {
            element: React7.createElement(routeModule.Layout, null, React7.createElement(Component4, null))
          } : { Component: Component4 },
          ...ErrorBoundary ? {
            errorElement: React7.createElement(routeModule.Layout, null, React7.createElement(ErrorBoundary, null))
          } : { ErrorBoundary },
          ...HydrateFallback ? {
            hydrateFallbackElement: React7.createElement(routeModule.Layout, null, React7.createElement(HydrateFallback, null))
          } : { HydrateFallback }
        };
      }
      return { Component: Component4, ErrorBoundary, HydrateFallback };
    }
    function createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({ Component: () => null })) {
      return (routesByParentId[parentId] || []).map((route) => {
        let routeModule = routeModules[route.id];
        invariant2(
          routeModule,
          "No `routeModule` available to create server routes"
        );
        let dataRoute = {
          ...getRouteComponents(route, routeModule, isSpaMode),
          caseSensitive: route.caseSensitive,
          id: route.id,
          index: route.index,
          path: route.path,
          handle: routeModule.handle,
          // For SPA Mode, all routes are lazy except root.  However we tell the
          // router root is also lazy here too since we don't need a full
          // implementation - we just need a `lazy` prop to tell the RR rendering
          // where to stop which is always at the root route in SPA mode
          lazy: isSpaMode ? () => spaModeLazyPromise : void 0,
          // For partial hydration rendering, we need to indicate when the route
          // has a loader/clientLoader, but it won't ever be called during the static
          // render, so just give it a no-op function so we can render down to the
          // proper fallback
          loader: route.hasLoader || route.hasClientLoader ? () => null : void 0
          // We don't need middleware/action/shouldRevalidate on these routes since
          // they're for a static render
        };
        let children = createServerRoutes(
          manifest,
          routeModules,
          future,
          isSpaMode,
          route.id,
          routesByParentId,
          spaModeLazyPromise
        );
        if (children.length > 0) dataRoute.children = children;
        return dataRoute;
      });
    }
    function createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState48, ssr, isSpaMode) {
      return createClientRoutes(
        manifest,
        routeModulesCache,
        initialState48,
        ssr,
        isSpaMode,
        "",
        groupRoutesByParentId(manifest),
        needsRevalidation
      );
    }
    function preventInvalidServerHandlerCall(type, route) {
      if (type === "loader" && !route.hasLoader || type === "action" && !route.hasAction) {
        let fn = type === "action" ? "serverAction()" : "serverLoader()";
        let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: "${route.id}")`;
        console.error(msg);
        throw new ErrorResponseImpl(400, "Bad Request", new Error(msg), true);
      }
    }
    function noActionDefinedError(type, routeId) {
      let article = type === "clientAction" ? "a" : "an";
      let msg = `Route "${routeId}" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \`${type}\` function to the route`;
      console.error(msg);
      throw new ErrorResponseImpl(405, "Method Not Allowed", new Error(msg), true);
    }
    function createClientRoutes(manifest, routeModulesCache, initialState48, ssr, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {
      return (routesByParentId[parentId] || []).map((route) => {
        var _a, _b, _c;
        let routeModule = routeModulesCache[route.id];
        function fetchServerHandler(singleFetch) {
          invariant2(
            typeof singleFetch === "function",
            "No single fetch function available for route handler"
          );
          return singleFetch();
        }
        function fetchServerLoader(singleFetch) {
          if (!route.hasLoader) return Promise.resolve(null);
          return fetchServerHandler(singleFetch);
        }
        function fetchServerAction(singleFetch) {
          if (!route.hasAction) {
            throw noActionDefinedError("action", route.id);
          }
          return fetchServerHandler(singleFetch);
        }
        function prefetchModule(modulePath) {
          import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            modulePath
          );
        }
        function prefetchRouteModuleChunks(route2) {
          if (route2.clientActionModule) {
            prefetchModule(route2.clientActionModule);
          }
          if (route2.clientLoaderModule) {
            prefetchModule(route2.clientLoaderModule);
          }
        }
        async function prefetchStylesAndCallHandler(handler) {
          let cachedModule = routeModulesCache[route.id];
          let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();
          try {
            return handler();
          } finally {
            await linkPrefetchPromise;
          }
        }
        let dataRoute = {
          id: route.id,
          index: route.index,
          path: route.path
        };
        if (routeModule) {
          Object.assign(dataRoute, {
            ...dataRoute,
            ...getRouteComponents(route, routeModule, isSpaMode),
            unstable_middleware: routeModule.unstable_clientMiddleware,
            handle: routeModule.handle,
            shouldRevalidate: getShouldRevalidateFunction(
              dataRoute.path,
              routeModule,
              route,
              ssr,
              needsRevalidation
            )
          });
          let hasInitialData = initialState48 && initialState48.loaderData && route.id in initialState48.loaderData;
          let initialData = hasInitialData ? (_a = initialState48 == null ? void 0 : initialState48.loaderData) == null ? void 0 : _a[route.id] : void 0;
          let hasInitialError = initialState48 && initialState48.errors && route.id in initialState48.errors;
          let initialError = hasInitialError ? (_b = initialState48 == null ? void 0 : initialState48.errors) == null ? void 0 : _b[route.id] : void 0;
          let isHydrationRequest = needsRevalidation == null && (((_c = routeModule.clientLoader) == null ? void 0 : _c.hydrate) === true || !route.hasLoader);
          dataRoute.loader = async ({ request, params, context }, singleFetch) => {
            try {
              let result = await prefetchStylesAndCallHandler(async () => {
                invariant2(
                  routeModule,
                  "No `routeModule` available for critical-route loader"
                );
                if (!routeModule.clientLoader) {
                  return fetchServerLoader(singleFetch);
                }
                return routeModule.clientLoader({
                  request,
                  params,
                  context,
                  async serverLoader() {
                    preventInvalidServerHandlerCall("loader", route);
                    if (isHydrationRequest) {
                      if (hasInitialData) {
                        return initialData;
                      }
                      if (hasInitialError) {
                        throw initialError;
                      }
                    }
                    return fetchServerLoader(singleFetch);
                  }
                });
              });
              return result;
            } finally {
              isHydrationRequest = false;
            }
          };
          dataRoute.loader.hydrate = shouldHydrateRouteLoader(
            route.id,
            routeModule.clientLoader,
            route.hasLoader,
            isSpaMode
          );
          dataRoute.action = ({ request, params, context }, singleFetch) => {
            return prefetchStylesAndCallHandler(async () => {
              invariant2(
                routeModule,
                "No `routeModule` available for critical-route action"
              );
              if (!routeModule.clientAction) {
                if (isSpaMode) {
                  throw noActionDefinedError("clientAction", route.id);
                }
                return fetchServerAction(singleFetch);
              }
              return routeModule.clientAction({
                request,
                params,
                context,
                async serverAction() {
                  preventInvalidServerHandlerCall("action", route);
                  return fetchServerAction(singleFetch);
                }
              });
            });
          };
        } else {
          if (!route.hasClientLoader) {
            dataRoute.loader = (_, singleFetch) => prefetchStylesAndCallHandler(() => {
              return fetchServerLoader(singleFetch);
            });
          }
          if (!route.hasClientAction) {
            dataRoute.action = (_, singleFetch) => prefetchStylesAndCallHandler(() => {
              if (isSpaMode) {
                throw noActionDefinedError("clientAction", route.id);
              }
              return fetchServerAction(singleFetch);
            });
          }
          let lazyRoutePromise;
          async function getLazyRoute() {
            if (lazyRoutePromise) {
              return await lazyRoutePromise;
            }
            lazyRoutePromise = (async () => {
              if (route.clientLoaderModule || route.clientActionModule) {
                await new Promise((resolve) => setTimeout(resolve, 0));
              }
              let routeModulePromise = loadRouteModuleWithBlockingLinks(
                route,
                routeModulesCache
              );
              prefetchRouteModuleChunks(route);
              return await routeModulePromise;
            })();
            return await lazyRoutePromise;
          }
          dataRoute.lazy = {
            loader: route.hasClientLoader ? async () => {
              let { clientLoader } = route.clientLoaderModule ? await import(
                /* @vite-ignore */
                /* webpackIgnore: true */
                route.clientLoaderModule
              ) : await getLazyRoute();
              invariant2(clientLoader, "No `clientLoader` export found");
              return (args, singleFetch) => clientLoader({
                ...args,
                async serverLoader() {
                  preventInvalidServerHandlerCall("loader", route);
                  return fetchServerLoader(singleFetch);
                }
              });
            } : void 0,
            action: route.hasClientAction ? async () => {
              let clientActionPromise = route.clientActionModule ? import(
                /* @vite-ignore */
                /* webpackIgnore: true */
                route.clientActionModule
              ) : getLazyRoute();
              prefetchRouteModuleChunks(route);
              let { clientAction } = await clientActionPromise;
              invariant2(clientAction, "No `clientAction` export found");
              return (args, singleFetch) => clientAction({
                ...args,
                async serverAction() {
                  preventInvalidServerHandlerCall("action", route);
                  return fetchServerAction(singleFetch);
                }
              });
            } : void 0,
            unstable_middleware: route.hasClientMiddleware ? async () => {
              let { unstable_clientMiddleware } = route.clientMiddlewareModule ? await import(
                /* @vite-ignore */
                /* webpackIgnore: true */
                route.clientMiddlewareModule
              ) : await getLazyRoute();
              invariant2(
                unstable_clientMiddleware,
                "No `unstable_clientMiddleware` export found"
              );
              return unstable_clientMiddleware;
            } : void 0,
            shouldRevalidate: async () => {
              let lazyRoute = await getLazyRoute();
              return getShouldRevalidateFunction(
                dataRoute.path,
                lazyRoute,
                route,
                ssr,
                needsRevalidation
              );
            },
            handle: async () => (await getLazyRoute()).handle,
            // No need to wrap these in layout since the root route is never
            // loaded via route.lazy()
            Component: async () => (await getLazyRoute()).Component,
            ErrorBoundary: route.hasErrorBoundary ? async () => (await getLazyRoute()).ErrorBoundary : void 0
          };
        }
        let children = createClientRoutes(
          manifest,
          routeModulesCache,
          initialState48,
          ssr,
          isSpaMode,
          route.id,
          routesByParentId,
          needsRevalidation
        );
        if (children.length > 0) dataRoute.children = children;
        return dataRoute;
      });
    }
    function getShouldRevalidateFunction(path, route, manifestRoute, ssr, needsRevalidation) {
      if (needsRevalidation) {
        return wrapShouldRevalidateForHdr(
          manifestRoute.id,
          route.shouldRevalidate,
          needsRevalidation
        );
      }
      if (!ssr && manifestRoute.hasLoader && !manifestRoute.hasClientLoader) {
        let myParams = path ? compilePath(path)[1].map((p) => p.paramName) : [];
        const didParamsChange = (opts) => myParams.some((p) => opts.currentParams[p] !== opts.nextParams[p]);
        if (route.shouldRevalidate) {
          let fn = route.shouldRevalidate;
          return (opts) => fn({
            ...opts,
            defaultShouldRevalidate: didParamsChange(opts)
          });
        } else {
          return (opts) => didParamsChange(opts);
        }
      }
      if (ssr && route.shouldRevalidate) {
        let fn = route.shouldRevalidate;
        return (opts) => fn({ ...opts, defaultShouldRevalidate: true });
      }
      return route.shouldRevalidate;
    }
    function wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {
      let handledRevalidation = false;
      return (arg) => {
        if (!handledRevalidation) {
          handledRevalidation = true;
          return needsRevalidation.has(routeId);
        }
        return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;
      };
    }
    async function loadRouteModuleWithBlockingLinks(route, routeModules) {
      let routeModulePromise = loadRouteModule(route, routeModules);
      let prefetchRouteCssPromise = prefetchRouteCss(route);
      let routeModule = await routeModulePromise;
      await Promise.all([
        prefetchRouteCssPromise,
        prefetchStyleLinks(route, routeModule)
      ]);
      return {
        Component: getRouteModuleComponent(routeModule),
        ErrorBoundary: routeModule.ErrorBoundary,
        unstable_clientMiddleware: routeModule.unstable_clientMiddleware,
        clientAction: routeModule.clientAction,
        clientLoader: routeModule.clientLoader,
        handle: routeModule.handle,
        links: routeModule.links,
        meta: routeModule.meta,
        shouldRevalidate: routeModule.shouldRevalidate
      };
    }
    function getRouteModuleComponent(routeModule) {
      if (routeModule.default == null) return void 0;
      let isEmptyObject = typeof routeModule.default === "object" && Object.keys(routeModule.default).length === 0;
      if (!isEmptyObject) {
        return routeModule.default;
      }
    }
    function shouldHydrateRouteLoader(routeId, clientLoader, hasLoader, isSpaMode) {
      return isSpaMode && routeId !== "root" || clientLoader != null && (clientLoader.hydrate === true || hasLoader !== true);
    }
    var nextPaths = /* @__PURE__ */ new Set();
    var discoveredPathsMaxSize = 1e3;
    var discoveredPaths = /* @__PURE__ */ new Set();
    var URL_LIMIT = 7680;
    function isFogOfWarEnabled(routeDiscovery, ssr) {
      return routeDiscovery.mode === "lazy" && ssr === true;
    }
    function getPartialManifest({ sri, ...manifest }, router) {
      let routeIds = new Set(router.state.matches.map((m) => m.route.id));
      let segments = router.state.location.pathname.split("/").filter(Boolean);
      let paths = ["/"];
      segments.pop();
      while (segments.length > 0) {
        paths.push(`/${segments.join("/")}`);
        segments.pop();
      }
      paths.forEach((path) => {
        let matches = matchRoutes(router.routes, path, router.basename);
        if (matches) {
          matches.forEach((m) => routeIds.add(m.route.id));
        }
      });
      let initialRoutes = [...routeIds].reduce(
        (acc, id) => Object.assign(acc, { [id]: manifest.routes[id] }),
        {}
      );
      return {
        ...manifest,
        routes: initialRoutes,
        sri: sri ? true : void 0
      };
    }
    function getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, routeDiscovery, isSpaMode, basename) {
      if (!isFogOfWarEnabled(routeDiscovery, ssr)) {
        return void 0;
      }
      return async ({ path, patch, signal, fetcherKey }) => {
        if (discoveredPaths.has(path)) {
          return;
        }
        await fetchAndApplyManifestPatches(
          [path],
          fetcherKey ? window.location.href : path,
          manifest,
          routeModules,
          ssr,
          isSpaMode,
          basename,
          routeDiscovery.manifestPath,
          patch,
          signal
        );
      };
    }
    function useFogOFWarDiscovery(router, manifest, routeModules, ssr, routeDiscovery, isSpaMode) {
      React8.useEffect(() => {
        var _a, _b;
        if (!isFogOfWarEnabled(routeDiscovery, ssr) || // @ts-expect-error - TS doesn't know about this yet
        ((_b = (_a = window.navigator) == null ? void 0 : _a.connection) == null ? void 0 : _b.saveData) === true) {
          return;
        }
        function registerElement(el) {
          let path = el.tagName === "FORM" ? el.getAttribute("action") : el.getAttribute("href");
          if (!path) {
            return;
          }
          let pathname = el.tagName === "A" ? el.pathname : new URL(path, window.location.origin).pathname;
          if (!discoveredPaths.has(pathname)) {
            nextPaths.add(pathname);
          }
        }
        async function fetchPatches() {
          document.querySelectorAll("a[data-discover], form[data-discover]").forEach(registerElement);
          let lazyPaths = Array.from(nextPaths.keys()).filter((path) => {
            if (discoveredPaths.has(path)) {
              nextPaths.delete(path);
              return false;
            }
            return true;
          });
          if (lazyPaths.length === 0) {
            return;
          }
          try {
            await fetchAndApplyManifestPatches(
              lazyPaths,
              null,
              manifest,
              routeModules,
              ssr,
              isSpaMode,
              router.basename,
              routeDiscovery.manifestPath,
              router.patchRoutes
            );
          } catch (e) {
            console.error("Failed to fetch manifest patches", e);
          }
        }
        let debouncedFetchPatches = debounce(fetchPatches, 100);
        fetchPatches();
        let observer = new MutationObserver(() => debouncedFetchPatches());
        observer.observe(document.documentElement, {
          subtree: true,
          childList: true,
          attributes: true,
          attributeFilter: ["data-discover", "href", "action"]
        });
        return () => observer.disconnect();
      }, [ssr, isSpaMode, manifest, routeModules, router, routeDiscovery]);
    }
    function getManifestPath(_manifestPath, basename) {
      let manifestPath = _manifestPath || "/__manifest";
      if (basename == null) {
        return manifestPath;
      }
      return `${basename}${manifestPath}`.replace(/\/+/g, "/");
    }
    var MANIFEST_VERSION_STORAGE_KEY = "react-router-manifest-version";
    async function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, manifestPath, patchRoutes, signal) {
      let url = new URL(
        getManifestPath(manifestPath, basename),
        window.location.origin
      );
      paths.sort().forEach((path) => url.searchParams.append("p", path));
      url.searchParams.set("version", manifest.version);
      if (url.toString().length > URL_LIMIT) {
        nextPaths.clear();
        return;
      }
      let serverPatches;
      try {
        let res = await fetch(url, { signal });
        if (!res.ok) {
          throw new Error(`${res.status} ${res.statusText}`);
        } else if (res.status === 204 && res.headers.has("X-Remix-Reload-Document")) {
          if (!errorReloadPath) {
            console.warn(
              "Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest."
            );
            return;
          }
          if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {
            console.error(
              "Unable to discover routes due to manifest version mismatch."
            );
            return;
          }
          sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);
          window.location.href = errorReloadPath;
          console.warn("Detected manifest version mismatch, reloading...");
          await new Promise(() => {
          });
        } else if (res.status >= 400) {
          throw new Error(await res.text());
        }
        sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);
        serverPatches = await res.json();
      } catch (e) {
        if (signal == null ? void 0 : signal.aborted) return;
        throw e;
      }
      let knownRoutes = new Set(Object.keys(manifest.routes));
      let patches = Object.values(serverPatches).reduce((acc, route) => {
        if (route && !knownRoutes.has(route.id)) {
          acc[route.id] = route;
        }
        return acc;
      }, {});
      Object.assign(manifest.routes, patches);
      paths.forEach((p) => addToFifoQueue(p, discoveredPaths));
      let parentIds = /* @__PURE__ */ new Set();
      Object.values(patches).forEach((patch) => {
        if (patch && (!patch.parentId || !patches[patch.parentId])) {
          parentIds.add(patch.parentId);
        }
      });
      parentIds.forEach(
        (parentId) => patchRoutes(
          parentId || null,
          createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)
        )
      );
    }
    function addToFifoQueue(path, queue) {
      if (queue.size >= discoveredPathsMaxSize) {
        let first = queue.values().next().value;
        queue.delete(first);
      }
      queue.add(path);
    }
    function debounce(callback, wait) {
      let timeoutId;
      return (...args) => {
        window.clearTimeout(timeoutId);
        timeoutId = window.setTimeout(() => callback(...args), wait);
      };
    }
    function useDataRouterContext2() {
      let context = React9.useContext(DataRouterContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterContext.Provider> element"
      );
      return context;
    }
    function useDataRouterStateContext() {
      let context = React9.useContext(DataRouterStateContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterStateContext.Provider> element"
      );
      return context;
    }
    var FrameworkContext = React9.createContext(void 0);
    FrameworkContext.displayName = "FrameworkContext";
    function useFrameworkContext() {
      let context = React9.useContext(FrameworkContext);
      invariant2(
        context,
        "You must render this element inside a <HydratedRouter> element"
      );
      return context;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
      let frameworkContext = React9.useContext(FrameworkContext);
      let [maybePrefetch, setMaybePrefetch] = React9.useState(false);
      let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);
      let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
      let ref2 = React9.useRef(null);
      React9.useEffect(() => {
        if (prefetch === "render") {
          setShouldPrefetch(true);
        }
        if (prefetch === "viewport") {
          let callback = (entries) => {
            entries.forEach((entry) => {
              setShouldPrefetch(entry.isIntersecting);
            });
          };
          let observer = new IntersectionObserver(callback, { threshold: 0.5 });
          if (ref2.current) observer.observe(ref2.current);
          return () => {
            observer.disconnect();
          };
        }
      }, [prefetch]);
      React9.useEffect(() => {
        if (maybePrefetch) {
          let id = setTimeout(() => {
            setShouldPrefetch(true);
          }, 100);
          return () => {
            clearTimeout(id);
          };
        }
      }, [maybePrefetch]);
      let setIntent = () => {
        setMaybePrefetch(true);
      };
      let cancelIntent = () => {
        setMaybePrefetch(false);
        setShouldPrefetch(false);
      };
      if (!frameworkContext) {
        return [false, ref2, {}];
      }
      if (prefetch !== "intent") {
        return [shouldPrefetch, ref2, {}];
      }
      return [
        shouldPrefetch,
        ref2,
        {
          onFocus: composeEventHandlers(onFocus, setIntent),
          onBlur: composeEventHandlers(onBlur, cancelIntent),
          onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
          onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
          onTouchStart: composeEventHandlers(onTouchStart, setIntent)
        }
      ];
    }
    function composeEventHandlers(theirHandler, ourHandler) {
      return (event) => {
        theirHandler && theirHandler(event);
        if (!event.defaultPrevented) {
          ourHandler(event);
        }
      };
    }
    function getActiveMatches(matches, errors, isSpaMode) {
      if (isSpaMode && !isHydrated) {
        return [matches[0]];
      }
      if (errors) {
        let errorIdx = matches.findIndex((m) => errors[m.route.id] !== void 0);
        return matches.slice(0, errorIdx + 1);
      }
      return matches;
    }
    function Links() {
      let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();
      let { errors, matches: routerMatches } = useDataRouterStateContext();
      let matches = getActiveMatches(routerMatches, errors, isSpaMode);
      let keyedLinks = React9.useMemo(
        () => getKeyedLinksForMatches(matches, routeModules, manifest),
        [matches, routeModules, manifest]
      );
      return React9.createElement(React9.Fragment, null, typeof criticalCss === "string" ? React9.createElement("style", { dangerouslySetInnerHTML: { __html: criticalCss } }) : null, typeof criticalCss === "object" ? React9.createElement("link", { rel: "stylesheet", href: criticalCss.href }) : null, keyedLinks.map(
        ({ key, link }) => isPageLinkDescriptor(link) ? React9.createElement(PrefetchPageLinks, { key, ...link }) : React9.createElement("link", { key, ...link })
      ));
    }
    function PrefetchPageLinks({
      page,
      ...dataLinkProps
    }) {
      let { router } = useDataRouterContext2();
      let matches = React9.useMemo(
        () => matchRoutes(router.routes, page, router.basename),
        [router.routes, page, router.basename]
      );
      if (!matches) {
        return null;
      }
      return React9.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps });
    }
    function useKeyedPrefetchLinks(matches) {
      let { manifest, routeModules } = useFrameworkContext();
      let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);
      React9.useEffect(() => {
        let interrupted = false;
        void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
          (links) => {
            if (!interrupted) {
              setKeyedPrefetchLinks(links);
            }
          }
        );
        return () => {
          interrupted = true;
        };
      }, [matches, manifest, routeModules]);
      return keyedPrefetchLinks;
    }
    function PrefetchPageLinksImpl({
      page,
      matches: nextMatches,
      ...linkProps
    }) {
      let location = useLocation();
      let { manifest, routeModules } = useFrameworkContext();
      let { basename } = useDataRouterContext2();
      let { loaderData, matches } = useDataRouterStateContext();
      let newMatchesForData = React9.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches,
          manifest,
          location,
          "data"
        ),
        [page, nextMatches, matches, manifest, location]
      );
      let newMatchesForAssets = React9.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches,
          manifest,
          location,
          "assets"
        ),
        [page, nextMatches, matches, manifest, location]
      );
      let dataHrefs = React9.useMemo(() => {
        if (page === location.pathname + location.search + location.hash) {
          return [];
        }
        let routesParams = /* @__PURE__ */ new Set();
        let foundOptOutRoute = false;
        nextMatches.forEach((m) => {
          var _a;
          let manifestRoute = manifest.routes[m.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return;
          }
          if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && ((_a = routeModules[m.route.id]) == null ? void 0 : _a.shouldRevalidate)) {
            foundOptOutRoute = true;
          } else if (manifestRoute.hasClientLoader) {
            foundOptOutRoute = true;
          } else {
            routesParams.add(m.route.id);
          }
        });
        if (routesParams.size === 0) {
          return [];
        }
        let url = singleFetchUrl(page, basename);
        if (foundOptOutRoute && routesParams.size > 0) {
          url.searchParams.set(
            "_routes",
            nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
          );
        }
        return [url.pathname + url.search];
      }, [
        basename,
        loaderData,
        location,
        manifest,
        newMatchesForData,
        nextMatches,
        page,
        routeModules
      ]);
      let moduleHrefs = React9.useMemo(
        () => getModuleLinkHrefs(newMatchesForAssets, manifest),
        [newMatchesForAssets, manifest]
      );
      let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
      return React9.createElement(React9.Fragment, null, dataHrefs.map((href2) => React9.createElement("link", { key: href2, rel: "prefetch", as: "fetch", href: href2, ...linkProps })), moduleHrefs.map((href2) => React9.createElement("link", { key: href2, rel: "modulepreload", href: href2, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
        // these don't spread `linkProps` because they are full link descriptors
        // already with their own props
        React9.createElement("link", { key, ...link })
      )));
    }
    function Meta() {
      let { isSpaMode, routeModules } = useFrameworkContext();
      let {
        errors,
        matches: routerMatches,
        loaderData
      } = useDataRouterStateContext();
      let location = useLocation();
      let _matches = getActiveMatches(routerMatches, errors, isSpaMode);
      let error = null;
      if (errors) {
        error = errors[_matches[_matches.length - 1].route.id];
      }
      let meta = [];
      let leafMeta = null;
      let matches = [];
      for (let i = 0; i < _matches.length; i++) {
        let _match = _matches[i];
        let routeId = _match.route.id;
        let data2 = loaderData[routeId];
        let params = _match.params;
        let routeModule = routeModules[routeId];
        let routeMeta = [];
        let match = {
          id: routeId,
          data: data2,
          meta: [],
          params: _match.params,
          pathname: _match.pathname,
          handle: _match.route.handle,
          error
        };
        matches[i] = match;
        if (routeModule == null ? void 0 : routeModule.meta) {
          routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
            data: data2,
            params,
            location,
            matches,
            error
          }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;
        } else if (leafMeta) {
          routeMeta = [...leafMeta];
        }
        routeMeta = routeMeta || [];
        if (!Array.isArray(routeMeta)) {
          throw new Error(
            "The route at " + _match.route.path + " returns an invalid value. All route meta functions must return an array of meta objects.\n\nTo reference the meta function API, see https://remix.run/route/meta"
          );
        }
        match.meta = routeMeta;
        matches[i] = match;
        meta = [...routeMeta];
        leafMeta = meta;
      }
      return React9.createElement(React9.Fragment, null, meta.flat().map((metaProps) => {
        if (!metaProps) {
          return null;
        }
        if ("tagName" in metaProps) {
          let { tagName, ...rest } = metaProps;
          if (!isValidMetaTag(tagName)) {
            console.warn(
              `A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`
            );
            return null;
          }
          let Comp = tagName;
          return React9.createElement(Comp, { key: JSON.stringify(rest), ...rest });
        }
        if ("title" in metaProps) {
          return React9.createElement("title", { key: "title" }, String(metaProps.title));
        }
        if ("charset" in metaProps) {
          metaProps.charSet ?? (metaProps.charSet = metaProps.charset);
          delete metaProps.charset;
        }
        if ("charSet" in metaProps && metaProps.charSet != null) {
          return typeof metaProps.charSet === "string" ? React9.createElement("meta", { key: "charSet", charSet: metaProps.charSet }) : null;
        }
        if ("script:ld+json" in metaProps) {
          try {
            let json = JSON.stringify(metaProps["script:ld+json"]);
            return React9.createElement(
              "script",
              {
                key: `script:ld+json:${json}`,
                type: "application/ld+json",
                dangerouslySetInnerHTML: { __html: json }
              }
            );
          } catch (err) {
            return null;
          }
        }
        return React9.createElement("meta", { key: JSON.stringify(metaProps), ...metaProps });
      }));
    }
    function isValidMetaTag(tagName) {
      return typeof tagName === "string" && /^(meta|link)$/.test(tagName);
    }
    var isHydrated = false;
    function Scripts(props) {
      let {
        manifest,
        serverHandoffString,
        isSpaMode,
        renderMeta,
        routeDiscovery,
        ssr
      } = useFrameworkContext();
      let { router, static: isStatic, staticContext } = useDataRouterContext2();
      let { matches: routerMatches } = useDataRouterStateContext();
      let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);
      if (renderMeta) {
        renderMeta.didRenderScripts = true;
      }
      let matches = getActiveMatches(routerMatches, null, isSpaMode);
      React9.useEffect(() => {
        isHydrated = true;
      }, []);
      let initialScripts = React9.useMemo(() => {
        var _a;
        let streamScript = "window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());";
        let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : " ";
        let routeModulesScript = !isStatic ? " " : `${((_a = manifest.hmr) == null ? void 0 : _a.runtime) ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : ""};
${matches.map((match, routeIndex) => {
          let routeVarName = `route${routeIndex}`;
          let manifestEntry = manifest.routes[match.route.id];
          invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);
          let {
            clientActionModule,
            clientLoaderModule,
            clientMiddlewareModule,
            hydrateFallbackModule,
            module: module2
          } = manifestEntry;
          let chunks = [
            ...clientActionModule ? [
              {
                module: clientActionModule,
                varName: `${routeVarName}_clientAction`
              }
            ] : [],
            ...clientLoaderModule ? [
              {
                module: clientLoaderModule,
                varName: `${routeVarName}_clientLoader`
              }
            ] : [],
            ...clientMiddlewareModule ? [
              {
                module: clientMiddlewareModule,
                varName: `${routeVarName}_clientMiddleware`
              }
            ] : [],
            ...hydrateFallbackModule ? [
              {
                module: hydrateFallbackModule,
                varName: `${routeVarName}_HydrateFallback`
              }
            ] : [],
            { module: module2, varName: `${routeVarName}_main` }
          ];
          if (chunks.length === 1) {
            return `import * as ${routeVarName} from ${JSON.stringify(module2)};`;
          }
          let chunkImportsSnippet = chunks.map((chunk) => `import * as ${chunk.varName} from "${chunk.module}";`).join("\n");
          let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk) => `...${chunk.varName}`).join(",")}};`;
          return [chunkImportsSnippet, mergedChunksSnippet].join("\n");
        }).join("\n")}
  ${enableFogOfWar ? (
          // Inline a minimal manifest with the SSR matches
          `window.__reactRouterManifest = ${JSON.stringify(
            getPartialManifest(manifest, router),
            null,
            2
          )};`
        ) : ""}
  window.__reactRouterRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});`;
        return React9.createElement(React9.Fragment, null, React9.createElement(
          "script",
          {
            ...props,
            suppressHydrationWarning: true,
            dangerouslySetInnerHTML: createHtml(contextScript),
            type: void 0
          }
        ), React9.createElement(
          "script",
          {
            ...props,
            suppressHydrationWarning: true,
            dangerouslySetInnerHTML: createHtml(routeModulesScript),
            type: "module",
            async: true
          }
        ));
      }, []);
      let preloads = isHydrated ? [] : dedupe(
        manifest.entry.imports.concat(
          getModuleLinkHrefs(matches, manifest, {
            includeHydrateFallback: true
          })
        )
      );
      let sri = typeof manifest.sri === "object" ? manifest.sri : {};
      return isHydrated ? null : React9.createElement(React9.Fragment, null, typeof manifest.sri === "object" ? React9.createElement(
        "script",
        {
          "rr-importmap": "",
          type: "importmap",
          suppressHydrationWarning: true,
          dangerouslySetInnerHTML: {
            __html: JSON.stringify({
              integrity: sri
            })
          }
        }
      ) : null, !enableFogOfWar ? React9.createElement(
        "link",
        {
          rel: "modulepreload",
          href: manifest.url,
          crossOrigin: props.crossOrigin,
          integrity: sri[manifest.url],
          suppressHydrationWarning: true
        }
      ) : null, React9.createElement(
        "link",
        {
          rel: "modulepreload",
          href: manifest.entry.module,
          crossOrigin: props.crossOrigin,
          integrity: sri[manifest.entry.module],
          suppressHydrationWarning: true
        }
      ), preloads.map((path) => React9.createElement(
        "link",
        {
          key: path,
          rel: "modulepreload",
          href: path,
          crossOrigin: props.crossOrigin,
          integrity: sri[path],
          suppressHydrationWarning: true
        }
      )), initialScripts);
    }
    function dedupe(array) {
      return [...new Set(array)];
    }
    function mergeRefs(...refs) {
      return (value) => {
        refs.forEach((ref2) => {
          if (typeof ref2 === "function") {
            ref2(value);
          } else if (ref2 != null) {
            ref2.current = value;
          }
        });
      };
    }
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    try {
      if (isBrowser) {
        window.__reactRouterVersion = "7.6.0";
      }
    } catch (e) {
    }
    function createBrowserRouter(routes, opts) {
      return createRouter({
        basename: opts == null ? void 0 : opts.basename,
        unstable_getContext: opts == null ? void 0 : opts.unstable_getContext,
        future: opts == null ? void 0 : opts.future,
        history: createBrowserHistory({ window: opts == null ? void 0 : opts.window }),
        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
        routes,
        mapRouteProperties,
        hydrationRouteProperties,
        dataStrategy: opts == null ? void 0 : opts.dataStrategy,
        patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,
        window: opts == null ? void 0 : opts.window
      }).initialize();
    }
    function createHashRouter(routes, opts) {
      return createRouter({
        basename: opts == null ? void 0 : opts.basename,
        unstable_getContext: opts == null ? void 0 : opts.unstable_getContext,
        future: opts == null ? void 0 : opts.future,
        history: createHashHistory({ window: opts == null ? void 0 : opts.window }),
        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
        routes,
        mapRouteProperties,
        hydrationRouteProperties,
        dataStrategy: opts == null ? void 0 : opts.dataStrategy,
        patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,
        window: opts == null ? void 0 : opts.window
      }).initialize();
    }
    function parseHydrationData() {
      let state = window == null ? void 0 : window.__staticRouterHydrationData;
      if (state && state.errors) {
        state = {
          ...state,
          errors: deserializeErrors(state.errors)
        };
      }
      return state;
    }
    function deserializeErrors(errors) {
      if (!errors) return null;
      let entries = Object.entries(errors);
      let serialized = {};
      for (let [key, val] of entries) {
        if (val && val.__type === "RouteErrorResponse") {
          serialized[key] = new ErrorResponseImpl(
            val.status,
            val.statusText,
            val.data,
            val.internal === true
          );
        } else if (val && val.__type === "Error") {
          if (val.__subType) {
            let ErrorConstructor = window[val.__subType];
            if (typeof ErrorConstructor === "function") {
              try {
                let error = new ErrorConstructor(val.message);
                error.stack = "";
                serialized[key] = error;
              } catch (e) {
              }
            }
          }
          if (serialized[key] == null) {
            let error = new Error(val.message);
            error.stack = "";
            serialized[key] = error;
          }
        } else {
          serialized[key] = val;
        }
      }
      return serialized;
    }
    function BrowserRouter({
      basename,
      children,
      window: window2
    }) {
      let historyRef = React10.useRef();
      if (historyRef.current == null) {
        historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = React10.useState({
        action: history.action,
        location: history.location
      });
      let setState = React10.useCallback(
        (newState) => {
          React10.startTransition(() => setStateImpl(newState));
        },
        [setStateImpl]
      );
      React10.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return React10.createElement(
        Router,
        {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        }
      );
    }
    function HashRouter({ basename, children, window: window2 }) {
      let historyRef = React10.useRef();
      if (historyRef.current == null) {
        historyRef.current = createHashHistory({ window: window2, v5Compat: true });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = React10.useState({
        action: history.action,
        location: history.location
      });
      let setState = React10.useCallback(
        (newState) => {
          React10.startTransition(() => setStateImpl(newState));
        },
        [setStateImpl]
      );
      React10.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return React10.createElement(
        Router,
        {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        }
      );
    }
    function HistoryRouter({
      basename,
      children,
      history
    }) {
      let [state, setStateImpl] = React10.useState({
        action: history.action,
        location: history.location
      });
      let setState = React10.useCallback(
        (newState) => {
          React10.startTransition(() => setStateImpl(newState));
        },
        [setStateImpl]
      );
      React10.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return React10.createElement(
        Router,
        {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        }
      );
    }
    HistoryRouter.displayName = "unstable_HistoryRouter";
    var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var Link = React10.forwardRef(
      function LinkWithRef({
        onClick,
        discover = "render",
        prefetch = "none",
        relative,
        reloadDocument,
        replace: replace2,
        state,
        target,
        to,
        preventScrollReset,
        viewTransition,
        ...rest
      }, forwardedRef) {
        let { basename } = React10.useContext(NavigationContext);
        let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
        let absoluteHref;
        let isExternal = false;
        if (typeof to === "string" && isAbsolute) {
          absoluteHref = to;
          if (isBrowser) {
            try {
              let currentUrl = new URL(window.location.href);
              let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
              let path = stripBasename(targetUrl.pathname, basename);
              if (targetUrl.origin === currentUrl.origin && path != null) {
                to = path + targetUrl.search + targetUrl.hash;
              } else {
                isExternal = true;
              }
            } catch (e) {
              warning(
                false,
                `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
              );
            }
          }
        }
        let href2 = useHref(to, { relative });
        let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
          prefetch,
          rest
        );
        let internalOnClick = useLinkClickHandler(to, {
          replace: replace2,
          state,
          target,
          preventScrollReset,
          relative,
          viewTransition
        });
        function handleClick(event) {
          if (onClick) onClick(event);
          if (!event.defaultPrevented) {
            internalOnClick(event);
          }
        }
        let link = (
          // eslint-disable-next-line jsx-a11y/anchor-has-content
          React10.createElement(
            "a",
            {
              ...rest,
              ...prefetchHandlers,
              href: absoluteHref || href2,
              onClick: isExternal || reloadDocument ? onClick : handleClick,
              ref: mergeRefs(forwardedRef, prefetchRef),
              target,
              "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
            }
          )
        );
        return shouldPrefetch && !isAbsolute ? React10.createElement(React10.Fragment, null, link, React10.createElement(PrefetchPageLinks, { page: href2 })) : link;
      }
    );
    Link.displayName = "Link";
    var NavLink = React10.forwardRef(
      function NavLinkWithRef({
        "aria-current": ariaCurrentProp = "page",
        caseSensitive = false,
        className: classNameProp = "",
        end = false,
        style: styleProp,
        to,
        viewTransition,
        children,
        ...rest
      }, ref2) {
        let path = useResolvedPath(to, { relative: rest.relative });
        let location = useLocation();
        let routerState = React10.useContext(DataRouterStateContext);
        let { navigator, basename } = React10.useContext(NavigationContext);
        let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useViewTransitionState(path) && viewTransition === true;
        let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
        let locationPathname = location.pathname;
        let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
        if (!caseSensitive) {
          locationPathname = locationPathname.toLowerCase();
          nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
          toPathname = toPathname.toLowerCase();
        }
        if (nextLocationPathname && basename) {
          nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
        }
        const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
        let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
        let renderProps = {
          isActive,
          isPending,
          isTransitioning
        };
        let ariaCurrent = isActive ? ariaCurrentProp : void 0;
        let className;
        if (typeof classNameProp === "function") {
          className = classNameProp(renderProps);
        } else {
          className = [
            classNameProp,
            isActive ? "active" : null,
            isPending ? "pending" : null,
            isTransitioning ? "transitioning" : null
          ].filter(Boolean).join(" ");
        }
        let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
        return React10.createElement(
          Link,
          {
            ...rest,
            "aria-current": ariaCurrent,
            className,
            ref: ref2,
            style,
            to,
            viewTransition
          },
          typeof children === "function" ? children(renderProps) : children
        );
      }
    );
    NavLink.displayName = "NavLink";
    var Form = React10.forwardRef(
      ({
        discover = "render",
        fetcherKey,
        navigate,
        reloadDocument,
        replace: replace2,
        state,
        method = defaultMethod,
        action,
        onSubmit,
        relative,
        preventScrollReset,
        viewTransition,
        ...props
      }, forwardedRef) => {
        let submit = useSubmit();
        let formAction = useFormAction(action, { relative });
        let formMethod = method.toLowerCase() === "get" ? "get" : "post";
        let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
        let submitHandler = (event) => {
          onSubmit && onSubmit(event);
          if (event.defaultPrevented) return;
          event.preventDefault();
          let submitter = event.nativeEvent.submitter;
          let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
          submit(submitter || event.currentTarget, {
            fetcherKey,
            method: submitMethod,
            navigate,
            replace: replace2,
            state,
            relative,
            preventScrollReset,
            viewTransition
          });
        };
        return React10.createElement(
          "form",
          {
            ref: forwardedRef,
            method: formMethod,
            action: formAction,
            onSubmit: reloadDocument ? onSubmit : submitHandler,
            ...props,
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          }
        );
      }
    );
    Form.displayName = "Form";
    function ScrollRestoration({
      getKey,
      storageKey,
      ...props
    }) {
      let remixContext = React10.useContext(FrameworkContext);
      let { basename } = React10.useContext(NavigationContext);
      let location = useLocation();
      let matches = useMatches();
      useScrollRestoration({ getKey, storageKey });
      let ssrKey = React10.useMemo(
        () => {
          if (!remixContext || !getKey) return null;
          let userKey = getScrollRestorationKey(
            location,
            matches,
            basename,
            getKey
          );
          return userKey !== location.key ? userKey : null;
        },
        // Nah, we only need this the first time for the SSR render
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      );
      if (!remixContext || remixContext.isSpaMode) {
        return null;
      }
      let restoreScroll = ((storageKey2, restoreKey) => {
        if (!window.history.state || !window.history.state.key) {
          let key = Math.random().toString(32).slice(2);
          window.history.replaceState({ key }, "");
        }
        try {
          let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
          let storedY = positions[restoreKey || window.history.state.key];
          if (typeof storedY === "number") {
            window.scrollTo(0, storedY);
          }
        } catch (error) {
          console.error(error);
          sessionStorage.removeItem(storageKey2);
        }
      }).toString();
      return React10.createElement(
        "script",
        {
          ...props,
          suppressHydrationWarning: true,
          dangerouslySetInnerHTML: {
            __html: `(${restoreScroll})(${JSON.stringify(
              storageKey || SCROLL_RESTORATION_STORAGE_KEY
            )}, ${JSON.stringify(ssrKey)})`
          }
        }
      );
    }
    ScrollRestoration.displayName = "ScrollRestoration";
    function getDataRouterConsoleError2(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext3(hookName) {
      let ctx = React10.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError2(hookName));
      return ctx;
    }
    function useDataRouterState2(hookName) {
      let state = React10.useContext(DataRouterStateContext);
      invariant(state, getDataRouterConsoleError2(hookName));
      return state;
    }
    function useLinkClickHandler(to, {
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative,
      viewTransition
    } = {}) {
      let navigate = useNavigate();
      let location = useLocation();
      let path = useResolvedPath(to, { relative });
      return React10.useCallback(
        (event) => {
          if (shouldProcessLinkClick(event, target)) {
            event.preventDefault();
            let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
            navigate(to, {
              replace: replace2,
              state,
              preventScrollReset,
              relative,
              viewTransition
            });
          }
        },
        [
          location,
          navigate,
          path,
          replaceProp,
          state,
          target,
          to,
          preventScrollReset,
          relative,
          viewTransition
        ]
      );
    }
    function useSearchParams(defaultInit) {
      warning(
        typeof URLSearchParams !== "undefined",
        `You cannot use the \`useSearchParams\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`
      );
      let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));
      let hasSetSearchParamsRef = React10.useRef(false);
      let location = useLocation();
      let searchParams = React10.useMemo(
        () => (
          // Only merge in the defaults if we haven't yet called setSearchParams.
          // Once we call that we want those to take precedence, otherwise you can't
          // remove a param with setSearchParams({}) if it has an initial value
          getSearchParamsForLocation(
            location.search,
            hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current
          )
        ),
        [location.search]
      );
      let navigate = useNavigate();
      let setSearchParams = React10.useCallback(
        (nextInit, navigateOptions) => {
          const newSearchParams = createSearchParams(
            typeof nextInit === "function" ? nextInit(searchParams) : nextInit
          );
          hasSetSearchParamsRef.current = true;
          navigate("?" + newSearchParams, navigateOptions);
        },
        [navigate, searchParams]
      );
      return [searchParams, setSearchParams];
    }
    var fetcherId = 0;
    var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
    function useSubmit() {
      let { router } = useDataRouterContext3(
        "useSubmit"
        /* UseSubmit */
      );
      let { basename } = React10.useContext(NavigationContext);
      let currentRouteId = useRouteId();
      return React10.useCallback(
        async (target, options = {}) => {
          let { action, method, encType, formData, body } = getFormSubmissionInfo(
            target,
            basename
          );
          if (options.navigate === false) {
            let key = options.fetcherKey || getUniqueFetcherId();
            await router.fetch(key, currentRouteId, options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              flushSync: options.flushSync
            });
          } else {
            await router.navigate(options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              replace: options.replace,
              state: options.state,
              fromRouteId: currentRouteId,
              flushSync: options.flushSync,
              viewTransition: options.viewTransition
            });
          }
        },
        [router, basename, currentRouteId]
      );
    }
    function useFormAction(action, { relative } = {}) {
      let { basename } = React10.useContext(NavigationContext);
      let routeContext = React10.useContext(RouteContext);
      invariant(routeContext, "useFormAction must be used inside a RouteContext");
      let [match] = routeContext.matches.slice(-1);
      let path = { ...useResolvedPath(action ? action : ".", { relative }) };
      let location = useLocation();
      if (action == null) {
        path.search = location.search;
        let params = new URLSearchParams(path.search);
        let indexValues = params.getAll("index");
        let hasNakedIndexParam = indexValues.some((v) => v === "");
        if (hasNakedIndexParam) {
          params.delete("index");
          indexValues.filter((v) => v).forEach((v) => params.append("index", v));
          let qs = params.toString();
          path.search = qs ? `?${qs}` : "";
        }
      }
      if ((!action || action === ".") && match.route.index) {
        path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
      }
      if (basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      return createPath(path);
    }
    function useFetcher({
      key
    } = {}) {
      var _a;
      let { router } = useDataRouterContext3(
        "useFetcher"
        /* UseFetcher */
      );
      let state = useDataRouterState2(
        "useFetcher"
        /* UseFetcher */
      );
      let fetcherData = React10.useContext(FetchersContext);
      let route = React10.useContext(RouteContext);
      let routeId = (_a = route.matches[route.matches.length - 1]) == null ? void 0 : _a.route.id;
      invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);
      invariant(route, `useFetcher must be used inside a RouteContext`);
      invariant(
        routeId != null,
        `useFetcher can only be used on routes that contain a unique "id"`
      );
      let defaultKey = React10.useId();
      let [fetcherKey, setFetcherKey] = React10.useState(key || defaultKey);
      if (key && key !== fetcherKey) {
        setFetcherKey(key);
      }
      React10.useEffect(() => {
        router.getFetcher(fetcherKey);
        return () => router.deleteFetcher(fetcherKey);
      }, [router, fetcherKey]);
      let load = React10.useCallback(
        async (href2, opts) => {
          invariant(routeId, "No routeId available for fetcher.load()");
          await router.fetch(fetcherKey, routeId, href2, opts);
        },
        [fetcherKey, routeId, router]
      );
      let submitImpl = useSubmit();
      let submit = React10.useCallback(
        async (target, opts) => {
          await submitImpl(target, {
            ...opts,
            navigate: false,
            fetcherKey
          });
        },
        [fetcherKey, submitImpl]
      );
      let FetcherForm = React10.useMemo(() => {
        let FetcherForm2 = React10.forwardRef(
          (props, ref2) => {
            return React10.createElement(Form, { ...props, navigate: false, fetcherKey, ref: ref2 });
          }
        );
        FetcherForm2.displayName = "fetcher.Form";
        return FetcherForm2;
      }, [fetcherKey]);
      let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;
      let data2 = fetcherData.get(fetcherKey);
      let fetcherWithComponents = React10.useMemo(
        () => ({
          Form: FetcherForm,
          submit,
          load,
          ...fetcher,
          data: data2
        }),
        [FetcherForm, submit, load, fetcher, data2]
      );
      return fetcherWithComponents;
    }
    function useFetchers() {
      let state = useDataRouterState2(
        "useFetchers"
        /* UseFetchers */
      );
      return Array.from(state.fetchers.entries()).map(([key, fetcher]) => ({
        ...fetcher,
        key
      }));
    }
    var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
    var savedScrollPositions = {};
    function getScrollRestorationKey(location, matches, basename, getKey) {
      let key = null;
      if (getKey) {
        if (basename !== "/") {
          key = getKey(
            {
              ...location,
              pathname: stripBasename(location.pathname, basename) || location.pathname
            },
            matches
          );
        } else {
          key = getKey(location, matches);
        }
      }
      if (key == null) {
        key = location.key;
      }
      return key;
    }
    function useScrollRestoration({
      getKey,
      storageKey
    } = {}) {
      let { router } = useDataRouterContext3(
        "useScrollRestoration"
        /* UseScrollRestoration */
      );
      let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(
        "useScrollRestoration"
        /* UseScrollRestoration */
      );
      let { basename } = React10.useContext(NavigationContext);
      let location = useLocation();
      let matches = useMatches();
      let navigation = useNavigation();
      React10.useEffect(() => {
        window.history.scrollRestoration = "manual";
        return () => {
          window.history.scrollRestoration = "auto";
        };
      }, []);
      usePageHide(
        React10.useCallback(() => {
          if (navigation.state === "idle") {
            let key = getScrollRestorationKey(location, matches, basename, getKey);
            savedScrollPositions[key] = window.scrollY;
          }
          try {
            sessionStorage.setItem(
              storageKey || SCROLL_RESTORATION_STORAGE_KEY,
              JSON.stringify(savedScrollPositions)
            );
          } catch (error) {
            warning(
              false,
              `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`
            );
          }
          window.history.scrollRestoration = "auto";
        }, [navigation.state, getKey, basename, location, matches, storageKey])
      );
      if (typeof document !== "undefined") {
        React10.useLayoutEffect(() => {
          try {
            let sessionPositions = sessionStorage.getItem(
              storageKey || SCROLL_RESTORATION_STORAGE_KEY
            );
            if (sessionPositions) {
              savedScrollPositions = JSON.parse(sessionPositions);
            }
          } catch (e) {
          }
        }, [storageKey]);
        React10.useLayoutEffect(() => {
          let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(
            savedScrollPositions,
            () => window.scrollY,
            getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0
          );
          return () => disableScrollRestoration && disableScrollRestoration();
        }, [router, basename, getKey]);
        React10.useLayoutEffect(() => {
          if (restoreScrollPosition === false) {
            return;
          }
          if (typeof restoreScrollPosition === "number") {
            window.scrollTo(0, restoreScrollPosition);
            return;
          }
          if (location.hash) {
            let el = document.getElementById(
              decodeURIComponent(location.hash.slice(1))
            );
            if (el) {
              el.scrollIntoView();
              return;
            }
          }
          if (preventScrollReset === true) {
            return;
          }
          window.scrollTo(0, 0);
        }, [location, restoreScrollPosition, preventScrollReset]);
      }
    }
    function useBeforeUnload(callback, options) {
      let { capture } = options || {};
      React10.useEffect(() => {
        let opts = capture != null ? { capture } : void 0;
        window.addEventListener("beforeunload", callback, opts);
        return () => {
          window.removeEventListener("beforeunload", callback, opts);
        };
      }, [callback, capture]);
    }
    function usePageHide(callback, options) {
      let { capture } = options || {};
      React10.useEffect(() => {
        let opts = capture != null ? { capture } : void 0;
        window.addEventListener("pagehide", callback, opts);
        return () => {
          window.removeEventListener("pagehide", callback, opts);
        };
      }, [callback, capture]);
    }
    function usePrompt({
      when,
      message
    }) {
      let blocker = useBlocker(when);
      React10.useEffect(() => {
        if (blocker.state === "blocked") {
          let proceed = window.confirm(message);
          if (proceed) {
            setTimeout(blocker.proceed, 0);
          } else {
            blocker.reset();
          }
        }
      }, [blocker, message]);
      React10.useEffect(() => {
        if (blocker.state === "blocked" && !when) {
          blocker.reset();
        }
      }, [blocker, when]);
    }
    function useViewTransitionState(to, opts = {}) {
      let vtContext = React10.useContext(ViewTransitionContext);
      invariant(
        vtContext != null,
        "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
      );
      let { basename } = useDataRouterContext3(
        "useViewTransitionState"
        /* useViewTransitionState */
      );
      let path = useResolvedPath(to, { relative: opts.relative });
      if (!vtContext.isTransitioning) {
        return false;
      }
      let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
      let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
      return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
    }
    var React11 = __toESM2(require_react());
    function StaticRouter({
      basename,
      children,
      location: locationProp = "/"
    }) {
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let action = "POP";
      let location = {
        pathname: locationProp.pathname || "/",
        search: locationProp.search || "",
        hash: locationProp.hash || "",
        state: locationProp.state != null ? locationProp.state : null,
        key: locationProp.key || "default"
      };
      let staticNavigator = getStatelessNavigator();
      return React11.createElement(
        Router,
        {
          basename,
          children,
          location,
          navigationType: action,
          navigator: staticNavigator,
          static: true
        }
      );
    }
    function StaticRouterProvider({
      context,
      router,
      hydrate: hydrate2 = true,
      nonce
    }) {
      invariant(
        router && context,
        "You must provide `router` and `context` to <StaticRouterProvider>"
      );
      let dataRouterContext = {
        router,
        navigator: getStatelessNavigator(),
        static: true,
        staticContext: context,
        basename: context.basename || "/"
      };
      let fetchersContext = /* @__PURE__ */ new Map();
      let hydrateScript = "";
      if (hydrate2 !== false) {
        let data2 = {
          loaderData: context.loaderData,
          actionData: context.actionData,
          errors: serializeErrors(context.errors)
        };
        let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));
        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;
      }
      let { state } = dataRouterContext.router;
      return React11.createElement(React11.Fragment, null, React11.createElement(DataRouterContext.Provider, { value: dataRouterContext }, React11.createElement(DataRouterStateContext.Provider, { value: state }, React11.createElement(FetchersContext.Provider, { value: fetchersContext }, React11.createElement(ViewTransitionContext.Provider, { value: { isTransitioning: false } }, React11.createElement(
        Router,
        {
          basename: dataRouterContext.basename,
          location: state.location,
          navigationType: state.historyAction,
          navigator: dataRouterContext.navigator,
          static: dataRouterContext.static
        },
        React11.createElement(
          DataRoutes2,
          {
            routes: router.routes,
            future: router.future,
            state
          }
        )
      ))))), hydrateScript ? React11.createElement(
        "script",
        {
          suppressHydrationWarning: true,
          nonce,
          dangerouslySetInnerHTML: { __html: hydrateScript }
        }
      ) : null);
    }
    function DataRoutes2({
      routes,
      future,
      state
    }) {
      return useRoutesImpl(routes, void 0, state, future);
    }
    function serializeErrors(errors) {
      if (!errors) return null;
      let entries = Object.entries(errors);
      let serialized = {};
      for (let [key, val] of entries) {
        if (isRouteErrorResponse(val)) {
          serialized[key] = { ...val, __type: "RouteErrorResponse" };
        } else if (val instanceof Error) {
          serialized[key] = {
            message: val.message,
            __type: "Error",
            // If this is a subclass (i.e., ReferenceError), send up the type so we
            // can re-create the same type during hydration.
            ...val.name !== "Error" ? {
              __subType: val.name
            } : {}
          };
        } else {
          serialized[key] = val;
        }
      }
      return serialized;
    }
    function getStatelessNavigator() {
      return {
        createHref,
        encodeLocation,
        push(to) {
          throw new Error(
            `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`
          );
        },
        replace(to) {
          throw new Error(
            `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`
          );
        },
        go(delta) {
          throw new Error(
            `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`
          );
        },
        back() {
          throw new Error(
            `You cannot use navigator.back() on the server because it is a stateless environment.`
          );
        },
        forward() {
          throw new Error(
            `You cannot use navigator.forward() on the server because it is a stateless environment.`
          );
        }
      };
    }
    function createStaticHandler2(routes, opts) {
      return createStaticHandler(routes, {
        ...opts,
        mapRouteProperties
      });
    }
    function createStaticRouter(routes, context, opts = {}) {
      let manifest = {};
      let dataRoutes = convertRoutesToDataRoutes(
        routes,
        mapRouteProperties,
        void 0,
        manifest
      );
      let matches = context.matches.map((match) => {
        let route = manifest[match.route.id] || match.route;
        return {
          ...match,
          route
        };
      });
      let msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;
      return {
        get basename() {
          return context.basename;
        },
        get future() {
          return {
            unstable_middleware: false,
            ...opts == null ? void 0 : opts.future
          };
        },
        get state() {
          return {
            historyAction: "POP",
            location: context.location,
            matches,
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: context.errors,
            initialized: true,
            navigation: IDLE_NAVIGATION,
            restoreScrollPosition: null,
            preventScrollReset: false,
            revalidation: "idle",
            fetchers: /* @__PURE__ */ new Map(),
            blockers: /* @__PURE__ */ new Map()
          };
        },
        get routes() {
          return dataRoutes;
        },
        get window() {
          return void 0;
        },
        initialize() {
          throw msg("initialize");
        },
        subscribe() {
          throw msg("subscribe");
        },
        enableScrollRestoration() {
          throw msg("enableScrollRestoration");
        },
        navigate() {
          throw msg("navigate");
        },
        fetch() {
          throw msg("fetch");
        },
        revalidate() {
          throw msg("revalidate");
        },
        createHref,
        encodeLocation,
        getFetcher() {
          return IDLE_FETCHER;
        },
        deleteFetcher() {
          throw msg("deleteFetcher");
        },
        dispose() {
          throw msg("dispose");
        },
        getBlocker() {
          return IDLE_BLOCKER;
        },
        deleteBlocker() {
          throw msg("deleteBlocker");
        },
        patchRoutes() {
          throw msg("patchRoutes");
        },
        _internalFetchControllers: /* @__PURE__ */ new Map(),
        _internalSetRoutes() {
          throw msg("_internalSetRoutes");
        }
      };
    }
    function createHref(to) {
      return typeof to === "string" ? to : createPath(to);
    }
    function encodeLocation(to) {
      let href2 = typeof to === "string" ? to : createPath(to);
      href2 = href2.replace(/ $/, "%20");
      let encoded = ABSOLUTE_URL_REGEX3.test(href2) ? new URL(href2) : new URL(href2, "http://localhost");
      return {
        pathname: encoded.pathname,
        search: encoded.search,
        hash: encoded.hash
      };
    }
    var ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var ESCAPE_LOOKUP2 = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    var ESCAPE_REGEX2 = /[&><\u2028\u2029]/g;
    function htmlEscape(str) {
      return str.replace(ESCAPE_REGEX2, (match) => ESCAPE_LOOKUP2[match]);
    }
    var React12 = __toESM2(require_react());
    function ServerRouter({
      context,
      url,
      nonce
    }) {
      if (typeof url === "string") {
        url = new URL(url);
      }
      let { manifest, routeModules, criticalCss, serverHandoffString } = context;
      let routes = createServerRoutes(
        manifest.routes,
        routeModules,
        context.future,
        context.isSpaMode
      );
      context.staticHandlerContext.loaderData = {
        ...context.staticHandlerContext.loaderData
      };
      for (let match of context.staticHandlerContext.matches) {
        let routeId = match.route.id;
        let route = routeModules[routeId];
        let manifestRoute = context.manifest.routes[routeId];
        if (route && manifestRoute && shouldHydrateRouteLoader(
          routeId,
          route.clientLoader,
          manifestRoute.hasLoader,
          context.isSpaMode
        ) && (route.HydrateFallback || !manifestRoute.hasLoader)) {
          delete context.staticHandlerContext.loaderData[routeId];
        }
      }
      let router = createStaticRouter(routes, context.staticHandlerContext);
      return React12.createElement(React12.Fragment, null, React12.createElement(
        FrameworkContext.Provider,
        {
          value: {
            manifest,
            routeModules,
            criticalCss,
            serverHandoffString,
            future: context.future,
            ssr: context.ssr,
            isSpaMode: context.isSpaMode,
            routeDiscovery: context.routeDiscovery,
            serializeError: context.serializeError,
            renderMeta: context.renderMeta
          }
        },
        React12.createElement(RemixErrorBoundary, { location: router.state.location }, React12.createElement(
          StaticRouterProvider,
          {
            router,
            context: context.staticHandlerContext,
            hydrate: false
          }
        ))
      ), context.serverHandoffStream ? React12.createElement(React12.Suspense, null, React12.createElement(
        StreamTransfer,
        {
          context,
          identifier: 0,
          reader: context.serverHandoffStream.getReader(),
          textDecoder: new TextDecoder(),
          nonce
        }
      )) : null);
    }
    var React13 = __toESM2(require_react());
    function createRoutesStub(routes, unstable_getContext) {
      return function RoutesTestStub({
        initialEntries,
        initialIndex,
        hydrationData,
        future
      }) {
        let routerRef = React13.useRef();
        let remixContextRef = React13.useRef();
        if (routerRef.current == null) {
          remixContextRef.current = {
            future: {
              unstable_subResourceIntegrity: (future == null ? void 0 : future.unstable_subResourceIntegrity) === true,
              unstable_middleware: (future == null ? void 0 : future.unstable_middleware) === true
            },
            manifest: {
              routes: {},
              entry: { imports: [], module: "" },
              url: "",
              version: ""
            },
            routeModules: {},
            ssr: false,
            isSpaMode: false,
            routeDiscovery: { mode: "lazy", manifestPath: "/__manifest" }
          };
          let patched = processRoutes(
            // @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`
            // types compared to `AgnosticRouteObject`
            convertRoutesToDataRoutes(routes, (r) => r),
            remixContextRef.current.manifest,
            remixContextRef.current.routeModules
          );
          routerRef.current = createMemoryRouter(patched, {
            unstable_getContext,
            initialEntries,
            initialIndex,
            hydrationData
          });
        }
        return React13.createElement(FrameworkContext.Provider, { value: remixContextRef.current }, React13.createElement(RouterProvider2, { router: routerRef.current }));
      };
    }
    function withComponentProps(Component4) {
      return function Wrapped() {
        return React13.createElement(Component4, {
          params: useParams(),
          loaderData: useLoaderData(),
          actionData: useActionData(),
          matches: useMatches()
        });
      };
    }
    function withHydrateFallbackProps(HydrateFallback) {
      return function Wrapped() {
        const props = {
          params: useParams(),
          loaderData: useLoaderData(),
          actionData: useActionData()
        };
        return React13.createElement(HydrateFallback, props);
      };
    }
    function withErrorBoundaryProps(ErrorBoundary) {
      return function Wrapped() {
        const props = {
          params: useParams(),
          loaderData: useLoaderData(),
          actionData: useActionData(),
          error: useRouteError()
        };
        return React13.createElement(ErrorBoundary, props);
      };
    }
    function processRoutes(routes, manifest, routeModules, parentId) {
      return routes.map((route) => {
        if (!route.id) {
          throw new Error(
            "Expected a route.id in @remix-run/testing processRoutes() function"
          );
        }
        let newRoute = {
          id: route.id,
          path: route.path,
          index: route.index,
          Component: route.Component ? withComponentProps(route.Component) : void 0,
          HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,
          ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,
          action: route.action,
          loader: route.loader,
          handle: route.handle,
          shouldRevalidate: route.shouldRevalidate
        };
        let entryRoute = {
          id: route.id,
          path: route.path,
          index: route.index,
          parentId,
          hasAction: route.action != null,
          hasLoader: route.loader != null,
          // When testing routes, you should be stubbing loader/action/middleware,
          // not trying to re-implement the full loader/clientLoader/SSR/hydration
          // flow. That is better tested via E2E tests.
          hasClientAction: false,
          hasClientLoader: false,
          hasClientMiddleware: false,
          hasErrorBoundary: route.ErrorBoundary != null,
          // any need for these?
          module: "build/stub-path-to-module.js",
          clientActionModule: void 0,
          clientLoaderModule: void 0,
          clientMiddlewareModule: void 0,
          hydrateFallbackModule: void 0
        };
        manifest.routes[newRoute.id] = entryRoute;
        routeModules[route.id] = {
          default: newRoute.Component || Outlet,
          ErrorBoundary: newRoute.ErrorBoundary || void 0,
          handle: route.handle,
          links: route.links,
          meta: route.meta,
          shouldRevalidate: route.shouldRevalidate
        };
        if (route.children) {
          newRoute.children = processRoutes(
            route.children,
            manifest,
            routeModules,
            newRoute.id
          );
        }
        return newRoute;
      });
    }
    var import_cookie = require_dist2();
    var encoder = new TextEncoder();
    var sign = async (value, secret) => {
      let data2 = encoder.encode(value);
      let key = await createKey2(secret, ["sign"]);
      let signature = await crypto.subtle.sign("HMAC", key, data2);
      let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(
        /=+$/,
        ""
      );
      return value + "." + hash;
    };
    var unsign = async (cookie, secret) => {
      let index = cookie.lastIndexOf(".");
      let value = cookie.slice(0, index);
      let hash = cookie.slice(index + 1);
      let data2 = encoder.encode(value);
      let key = await createKey2(secret, ["verify"]);
      let signature = byteStringToUint8Array(atob(hash));
      let valid = await crypto.subtle.verify("HMAC", key, signature, data2);
      return valid ? value : false;
    };
    var createKey2 = async (secret, usages) => crypto.subtle.importKey(
      "raw",
      encoder.encode(secret),
      { name: "HMAC", hash: "SHA-256" },
      false,
      usages
    );
    function byteStringToUint8Array(byteString) {
      let array = new Uint8Array(byteString.length);
      for (let i = 0; i < byteString.length; i++) {
        array[i] = byteString.charCodeAt(i);
      }
      return array;
    }
    var createCookie = (name, cookieOptions = {}) => {
      let { secrets = [], ...options } = {
        path: "/",
        sameSite: "lax",
        ...cookieOptions
      };
      warnOnceAboutExpiresCookie(name, options.expires);
      return {
        get name() {
          return name;
        },
        get isSigned() {
          return secrets.length > 0;
        },
        get expires() {
          return typeof options.maxAge !== "undefined" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
        },
        async parse(cookieHeader, parseOptions) {
          if (!cookieHeader) return null;
          let cookies = (0, import_cookie.parse)(cookieHeader, { ...options, ...parseOptions });
          if (name in cookies) {
            let value = cookies[name];
            if (typeof value === "string" && value !== "") {
              let decoded = await decodeCookieValue(value, secrets);
              return decoded;
            } else {
              return "";
            }
          } else {
            return null;
          }
        },
        async serialize(value, serializeOptions) {
          return (0, import_cookie.serialize)(
            name,
            value === "" ? "" : await encodeCookieValue(value, secrets),
            {
              ...options,
              ...serializeOptions
            }
          );
        }
      };
    };
    var isCookie = (object) => {
      return object != null && typeof object.name === "string" && typeof object.isSigned === "boolean" && typeof object.parse === "function" && typeof object.serialize === "function";
    };
    async function encodeCookieValue(value, secrets) {
      let encoded = encodeData(value);
      if (secrets.length > 0) {
        encoded = await sign(encoded, secrets[0]);
      }
      return encoded;
    }
    async function decodeCookieValue(value, secrets) {
      if (secrets.length > 0) {
        for (let secret of secrets) {
          let unsignedValue = await unsign(value, secret);
          if (unsignedValue !== false) {
            return decodeData(unsignedValue);
          }
        }
        return null;
      }
      return decodeData(value);
    }
    function encodeData(value) {
      return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
    }
    function decodeData(value) {
      try {
        return JSON.parse(decodeURIComponent(myEscape(atob(value))));
      } catch (error) {
        return {};
      }
    }
    function myEscape(value) {
      let str = value.toString();
      let result = "";
      let index = 0;
      let chr, code;
      while (index < str.length) {
        chr = str.charAt(index++);
        if (/[\w*+\-./@]/.exec(chr)) {
          result += chr;
        } else {
          code = chr.charCodeAt(0);
          if (code < 256) {
            result += "%" + hex(code, 2);
          } else {
            result += "%u" + hex(code, 4).toUpperCase();
          }
        }
      }
      return result;
    }
    function hex(code, length) {
      let result = code.toString(16);
      while (result.length < length) result = "0" + result;
      return result;
    }
    function myUnescape(value) {
      let str = value.toString();
      let result = "";
      let index = 0;
      let chr, part;
      while (index < str.length) {
        chr = str.charAt(index++);
        if (chr === "%") {
          if (str.charAt(index) === "u") {
            part = str.slice(index + 1, index + 5);
            if (/^[\da-f]{4}$/i.exec(part)) {
              result += String.fromCharCode(parseInt(part, 16));
              index += 5;
              continue;
            }
          } else {
            part = str.slice(index, index + 2);
            if (/^[\da-f]{2}$/i.exec(part)) {
              result += String.fromCharCode(parseInt(part, 16));
              index += 2;
              continue;
            }
          }
        }
        result += chr;
      }
      return result;
    }
    function warnOnceAboutExpiresCookie(name, expires) {
      warnOnce(
        !expires,
        `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`
      );
    }
    function createEntryRouteModules(manifest) {
      return Object.keys(manifest).reduce((memo2, routeId) => {
        let route = manifest[routeId];
        if (route) {
          memo2[routeId] = route.module;
        }
        return memo2;
      }, {});
    }
    var ServerMode = ((ServerMode2) => {
      ServerMode2["Development"] = "development";
      ServerMode2["Production"] = "production";
      ServerMode2["Test"] = "test";
      return ServerMode2;
    })(ServerMode || {});
    function isServerMode(value) {
      return value === "development" || value === "production" || value === "test";
    }
    function sanitizeError(error, serverMode) {
      if (error instanceof Error && serverMode !== "development") {
        let sanitized = new Error("Unexpected Server Error");
        sanitized.stack = void 0;
        return sanitized;
      }
      return error;
    }
    function sanitizeErrors(errors, serverMode) {
      return Object.entries(errors).reduce((acc, [routeId, error]) => {
        return Object.assign(acc, { [routeId]: sanitizeError(error, serverMode) });
      }, {});
    }
    function serializeError(error, serverMode) {
      let sanitized = sanitizeError(error, serverMode);
      return {
        message: sanitized.message,
        stack: sanitized.stack
      };
    }
    function serializeErrors2(errors, serverMode) {
      if (!errors) return null;
      let entries = Object.entries(errors);
      let serialized = {};
      for (let [key, val] of entries) {
        if (isRouteErrorResponse(val)) {
          serialized[key] = { ...val, __type: "RouteErrorResponse" };
        } else if (val instanceof Error) {
          let sanitized = sanitizeError(val, serverMode);
          serialized[key] = {
            message: sanitized.message,
            stack: sanitized.stack,
            __type: "Error",
            // If this is a subclass (i.e., ReferenceError), send up the type so we
            // can re-create the same type during hydration.  This will only apply
            // in dev mode since all production errors are sanitized to normal
            // Error instances
            ...sanitized.name !== "Error" ? {
              __subType: sanitized.name
            } : {}
          };
        } else {
          serialized[key] = val;
        }
      }
      return serialized;
    }
    function matchServerRoutes(routes, pathname, basename) {
      let matches = matchRoutes(
        routes,
        pathname,
        basename
      );
      if (!matches) return null;
      return matches.map((match) => ({
        params: match.params,
        pathname: match.pathname,
        route: match.route
      }));
    }
    async function callRouteHandler(handler, args) {
      let result = await handler({
        request: stripRoutesParam(stripIndexParam2(args.request)),
        params: args.params,
        context: args.context
      });
      if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {
        throw new Response(null, result.init);
      }
      return result;
    }
    function stripIndexParam2(request) {
      let url = new URL(request.url);
      let indexValues = url.searchParams.getAll("index");
      url.searchParams.delete("index");
      let indexValuesToKeep = [];
      for (let indexValue of indexValues) {
        if (indexValue) {
          indexValuesToKeep.push(indexValue);
        }
      }
      for (let toKeep of indexValuesToKeep) {
        url.searchParams.append("index", toKeep);
      }
      let init = {
        method: request.method,
        body: request.body,
        headers: request.headers,
        signal: request.signal
      };
      if (init.body) {
        init.duplex = "half";
      }
      return new Request(url.href, init);
    }
    function stripRoutesParam(request) {
      let url = new URL(request.url);
      url.searchParams.delete("_routes");
      let init = {
        method: request.method,
        body: request.body,
        headers: request.headers,
        signal: request.signal
      };
      if (init.body) {
        init.duplex = "half";
      }
      return new Request(url.href, init);
    }
    function invariant3(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        console.error(
          "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
        );
        throw new Error(message);
      }
    }
    var globalDevServerHooksKey = "__reactRouterDevServerHooks";
    function setDevServerHooks(devServerHooks) {
      globalThis[globalDevServerHooksKey] = devServerHooks;
    }
    function getDevServerHooks() {
      return globalThis[globalDevServerHooksKey];
    }
    function getBuildTimeHeader(request, headerName) {
      var _a;
      if (typeof process !== "undefined") {
        try {
          if (((_a = process.env) == null ? void 0 : _a.IS_RR_BUILD_REQUEST) === "yes") {
            return request.headers.get(headerName);
          }
        } catch (e) {
        }
      }
      return null;
    }
    function groupRoutesByParentId2(manifest) {
      let routes = {};
      Object.values(manifest).forEach((route) => {
        if (route) {
          let parentId = route.parentId || "";
          if (!routes[parentId]) {
            routes[parentId] = [];
          }
          routes[parentId].push(route);
        }
      });
      return routes;
    }
    function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => ({
        ...route,
        children: createRoutes(manifest, route.id, routesByParentId)
      }));
    }
    function createStaticHandlerDataRoutes(manifest, future, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => {
        let commonRoute = {
          // Always include root due to default boundaries
          hasErrorBoundary: route.id === "root" || route.module.ErrorBoundary != null,
          id: route.id,
          path: route.path,
          unstable_middleware: route.module.unstable_middleware,
          // Need to use RR's version in the param typed here to permit the optional
          // context even though we know it'll always be provided in remix
          loader: route.module.loader ? async (args) => {
            let preRenderedData = getBuildTimeHeader(
              args.request,
              "X-React-Router-Prerender-Data"
            );
            if (preRenderedData != null) {
              let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;
              invariant3(encoded, "Missing prerendered data for route");
              let uint8array = new TextEncoder().encode(encoded);
              let stream = new ReadableStream({
                start(controller) {
                  controller.enqueue(uint8array);
                  controller.close();
                }
              });
              let decoded = await decodeViaTurboStream(stream, global);
              let data2 = decoded.value;
              if (data2 && SingleFetchRedirectSymbol in data2) {
                let result = data2[SingleFetchRedirectSymbol];
                let init = { status: result.status };
                if (result.reload) {
                  throw redirectDocument(result.redirect, init);
                } else if (result.replace) {
                  throw replace(result.redirect, init);
                } else {
                  throw redirect(result.redirect, init);
                }
              } else {
                invariant3(
                  data2 && route.id in data2,
                  "Unable to decode prerendered data"
                );
                let result = data2[route.id];
                invariant3(
                  "data" in result,
                  "Unable to process prerendered data"
                );
                return result.data;
              }
            }
            let val = await callRouteHandler(route.module.loader, args);
            return val;
          } : void 0,
          action: route.module.action ? (args) => callRouteHandler(route.module.action, args) : void 0,
          handle: route.module.handle
        };
        return route.index ? {
          index: true,
          ...commonRoute
        } : {
          caseSensitive: route.caseSensitive,
          children: createStaticHandlerDataRoutes(
            manifest,
            future,
            route.id,
            routesByParentId
          ),
          ...commonRoute
        };
      });
    }
    var ESCAPE_LOOKUP3 = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    var ESCAPE_REGEX3 = /[&><\u2028\u2029]/g;
    function escapeHtml2(html) {
      return html.replace(ESCAPE_REGEX3, (match) => ESCAPE_LOOKUP3[match]);
    }
    function createServerHandoffString(serverHandoff) {
      return escapeHtml2(JSON.stringify(serverHandoff));
    }
    var import_set_cookie_parser = require_set_cookie();
    function getDocumentHeaders(build, context) {
      let boundaryIdx = context.errors ? context.matches.findIndex((m) => context.errors[m.route.id]) : -1;
      let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;
      let errorHeaders;
      if (boundaryIdx >= 0) {
        let { actionHeaders, actionData, loaderHeaders, loaderData } = context;
        context.matches.slice(boundaryIdx).some((match) => {
          let id = match.route.id;
          if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {
            errorHeaders = actionHeaders[id];
          } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {
            errorHeaders = loaderHeaders[id];
          }
          return errorHeaders != null;
        });
      }
      return matches.reduce((parentHeaders, match, idx) => {
        let { id } = match.route;
        let route = build.routes[id];
        invariant3(route, `Route with id "${id}" not found in build`);
        let routeModule = route.module;
        let loaderHeaders = context.loaderHeaders[id] || new Headers();
        let actionHeaders = context.actionHeaders[id] || new Headers();
        let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;
        let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;
        if (routeModule.headers == null) {
          let headers2 = new Headers(parentHeaders);
          if (includeErrorCookies) {
            prependCookies(errorHeaders, headers2);
          }
          prependCookies(actionHeaders, headers2);
          prependCookies(loaderHeaders, headers2);
          return headers2;
        }
        let headers = new Headers(
          routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
            loaderHeaders,
            parentHeaders,
            actionHeaders,
            errorHeaders: includeErrorHeaders ? errorHeaders : void 0
          }) : routeModule.headers : void 0
        );
        if (includeErrorCookies) {
          prependCookies(errorHeaders, headers);
        }
        prependCookies(actionHeaders, headers);
        prependCookies(loaderHeaders, headers);
        prependCookies(parentHeaders, headers);
        return headers;
      }, new Headers());
    }
    function prependCookies(parentHeaders, childHeaders) {
      let parentSetCookieString = parentHeaders.get("Set-Cookie");
      if (parentSetCookieString) {
        let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);
        let childCookies = new Set(childHeaders.getSetCookie());
        cookies.forEach((cookie) => {
          if (!childCookies.has(cookie)) {
            childHeaders.append("Set-Cookie", cookie);
          }
        });
      }
    }
    var SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([
      ...NO_BODY_STATUS_CODES,
      304
    ]);
    async function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {
      try {
        let respond2 = function(context) {
          let headers = getDocumentHeaders(build, context);
          if (isRedirectStatusCode(context.statusCode) && headers.has("Location")) {
            return generateSingleFetchResponse(request, build, serverMode, {
              result: getSingleFetchRedirect(
                context.statusCode,
                headers,
                build.basename
              ),
              headers,
              status: SINGLE_FETCH_REDIRECT_STATUS
            });
          }
          if (context.errors) {
            Object.values(context.errors).forEach((err) => {
              if (!isRouteErrorResponse(err) || err.error) {
                handleError(err);
              }
            });
            context.errors = sanitizeErrors(context.errors, serverMode);
          }
          let singleFetchResult;
          if (context.errors) {
            singleFetchResult = { error: Object.values(context.errors)[0] };
          } else {
            singleFetchResult = {
              data: Object.values(context.actionData || {})[0]
            };
          }
          return generateSingleFetchResponse(request, build, serverMode, {
            result: singleFetchResult,
            headers,
            status: context.statusCode
          });
        };
        var respond = respond2;
        let handlerRequest = new Request(handlerUrl, {
          method: request.method,
          body: request.body,
          headers: request.headers,
          signal: request.signal,
          ...request.body ? { duplex: "half" } : void 0
        });
        let result = await staticHandler.query(handlerRequest, {
          requestContext: loadContext,
          skipLoaderErrorBubbling: true,
          skipRevalidation: true,
          unstable_respond: respond2
        });
        if (!isResponse(result)) {
          result = respond2(result);
        }
        if (isRedirectResponse(result)) {
          return generateSingleFetchResponse(request, build, serverMode, {
            result: getSingleFetchRedirect(
              result.status,
              result.headers,
              build.basename
            ),
            headers: result.headers,
            status: SINGLE_FETCH_REDIRECT_STATUS
          });
        }
        return result;
      } catch (error) {
        handleError(error);
        return generateSingleFetchResponse(request, build, serverMode, {
          result: { error },
          headers: new Headers(),
          status: 500
        });
      }
    }
    async function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {
      try {
        let respond2 = function(context) {
          let headers = getDocumentHeaders(build, context);
          if (isRedirectStatusCode(context.statusCode) && headers.has("Location")) {
            return generateSingleFetchResponse(request, build, serverMode, {
              result: {
                [SingleFetchRedirectSymbol]: getSingleFetchRedirect(
                  context.statusCode,
                  headers,
                  build.basename
                )
              },
              headers,
              status: SINGLE_FETCH_REDIRECT_STATUS
            });
          }
          if (context.errors) {
            Object.values(context.errors).forEach((err) => {
              if (!isRouteErrorResponse(err) || err.error) {
                handleError(err);
              }
            });
            context.errors = sanitizeErrors(context.errors, serverMode);
          }
          let results = {};
          let loadedMatches = new Set(
            context.matches.filter(
              (m) => loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null
            ).map((m) => m.route.id)
          );
          if (context.errors) {
            for (let [id, error] of Object.entries(context.errors)) {
              results[id] = { error };
            }
          }
          for (let [id, data2] of Object.entries(context.loaderData)) {
            if (!(id in results) && loadedMatches.has(id)) {
              results[id] = { data: data2 };
            }
          }
          return generateSingleFetchResponse(request, build, serverMode, {
            result: results,
            headers,
            status: context.statusCode
          });
        };
        var respond = respond2;
        let handlerRequest = new Request(handlerUrl, {
          headers: request.headers,
          signal: request.signal
        });
        let routesParam = new URL(request.url).searchParams.get("_routes");
        let loadRouteIds = routesParam ? new Set(routesParam.split(",")) : null;
        let result = await staticHandler.query(handlerRequest, {
          requestContext: loadContext,
          filterMatchesToLoad: (m) => !loadRouteIds || loadRouteIds.has(m.route.id),
          skipLoaderErrorBubbling: true,
          unstable_respond: respond2
        });
        if (!isResponse(result)) {
          result = respond2(result);
        }
        if (isRedirectResponse(result)) {
          return generateSingleFetchResponse(request, build, serverMode, {
            result: {
              [SingleFetchRedirectSymbol]: getSingleFetchRedirect(
                result.status,
                result.headers,
                build.basename
              )
            },
            headers: result.headers,
            status: SINGLE_FETCH_REDIRECT_STATUS
          });
        }
        return result;
      } catch (error) {
        handleError(error);
        return generateSingleFetchResponse(request, build, serverMode, {
          result: { root: { error } },
          headers: new Headers(),
          status: 500
        });
      }
    }
    function generateSingleFetchResponse(request, build, serverMode, {
      result,
      headers,
      status
    }) {
      let resultHeaders = new Headers(headers);
      resultHeaders.set("X-Remix-Response", "yes");
      if (SERVER_NO_BODY_STATUS_CODES.has(status)) {
        return new Response(null, { status, headers: resultHeaders });
      }
      resultHeaders.set("Content-Type", "text/x-script");
      return new Response(
        encodeViaTurboStream(
          result,
          request.signal,
          build.entry.module.streamTimeout,
          serverMode
        ),
        {
          status: status || 200,
          headers: resultHeaders
        }
      );
    }
    function getSingleFetchRedirect(status, headers, basename) {
      let redirect2 = headers.get("Location");
      if (basename) {
        redirect2 = stripBasename(redirect2, basename) || redirect2;
      }
      return {
        redirect: redirect2,
        status,
        revalidate: (
          // Technically X-Remix-Revalidate isn't needed here - that was an implementation
          // detail of ?_data requests as our way to tell the front end to revalidate when
          // we didn't have a response body to include that information in.
          // With single fetch, we tell the front end via this revalidate boolean field.
          // However, we're respecting it for now because it may be something folks have
          // used in their own responses
          // TODO(v3): Consider removing or making this official public API
          headers.has("X-Remix-Revalidate") || headers.has("Set-Cookie")
        ),
        reload: headers.has("X-Remix-Reload-Document"),
        replace: headers.has("X-Remix-Replace")
      };
    }
    function encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {
      let controller = new AbortController();
      let timeoutId = setTimeout(
        () => controller.abort(new Error("Server Timeout")),
        typeof streamTimeout === "number" ? streamTimeout : 4950
      );
      requestSignal.addEventListener("abort", () => clearTimeout(timeoutId));
      return encode(data2, {
        signal: controller.signal,
        plugins: [
          (value) => {
            if (value instanceof Error) {
              let { name, message, stack } = serverMode === "production" ? sanitizeError(value, serverMode) : value;
              return ["SanitizedError", name, message, stack];
            }
            if (value instanceof ErrorResponseImpl) {
              let { data: data3, status, statusText } = value;
              return ["ErrorResponse", data3, status, statusText];
            }
            if (value && typeof value === "object" && SingleFetchRedirectSymbol in value) {
              return ["SingleFetchRedirect", value[SingleFetchRedirectSymbol]];
            }
          }
        ],
        postPlugins: [
          (value) => {
            if (!value) return;
            if (typeof value !== "object") return;
            return [
              "SingleFetchClassInstance",
              Object.fromEntries(Object.entries(value))
            ];
          },
          () => ["SingleFetchFallback"]
        ]
      });
    }
    function derive(build, mode) {
      let routes = createRoutes(build.routes);
      let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);
      let serverMode = isServerMode(mode) ? mode : "production";
      let staticHandler = createStaticHandler(dataRoutes, {
        basename: build.basename
      });
      let errorHandler2 = build.entry.module.handleError || ((error, { request }) => {
        if (serverMode !== "test" && !request.signal.aborted) {
          console.error(
            // @ts-expect-error This is "private" from users but intended for internal use
            isRouteErrorResponse(error) && error.error ? error.error : error
          );
        }
      });
      return {
        routes,
        dataRoutes,
        serverMode,
        staticHandler,
        errorHandler: errorHandler2
      };
    }
    var createRequestHandler = (build, mode) => {
      let _build;
      let routes;
      let serverMode;
      let staticHandler;
      let errorHandler2;
      return async function requestHandler(request, initialContext) {
        var _a, _b, _c;
        _build = typeof build === "function" ? await build() : build;
        if (typeof build === "function") {
          let derived = derive(_build, mode);
          routes = derived.routes;
          serverMode = derived.serverMode;
          staticHandler = derived.staticHandler;
          errorHandler2 = derived.errorHandler;
        } else if (!routes || !serverMode || !staticHandler || !errorHandler2) {
          let derived = derive(_build, mode);
          routes = derived.routes;
          serverMode = derived.serverMode;
          staticHandler = derived.staticHandler;
          errorHandler2 = derived.errorHandler;
        }
        let params = {};
        let loadContext;
        let handleError = (error) => {
          var _a2, _b2;
          if (mode === "development") {
            (_b2 = (_a2 = getDevServerHooks()) == null ? void 0 : _a2.processRequestError) == null ? void 0 : _b2.call(_a2, error);
          }
          errorHandler2(error, {
            context: loadContext,
            params,
            request
          });
        };
        if (_build.future.unstable_middleware) {
          if (initialContext == null) {
            loadContext = new unstable_RouterContextProvider();
          } else {
            try {
              loadContext = new unstable_RouterContextProvider(
                initialContext
              );
            } catch (e) {
              let error = new Error(
                `Unable to create initial \`unstable_RouterContextProvider\` instance. Please confirm you are returning an instance of \`Map<unstable_routerContext, unknown>\` from your \`getLoadContext\` function.

Error: ${e instanceof Error ? e.toString() : e}`
              );
              handleError(error);
              return returnLastResortErrorResponse(error, serverMode);
            }
          }
        } else {
          loadContext = initialContext || {};
        }
        let url = new URL(request.url);
        let normalizedBasename = _build.basename || "/";
        let normalizedPath = url.pathname;
        if (stripBasename(normalizedPath, normalizedBasename) === "/_root.data") {
          normalizedPath = normalizedBasename;
        } else if (normalizedPath.endsWith(".data")) {
          normalizedPath = normalizedPath.replace(/\.data$/, "");
        }
        if (stripBasename(normalizedPath, normalizedBasename) !== "/" && normalizedPath.endsWith("/")) {
          normalizedPath = normalizedPath.slice(0, -1);
        }
        let isSpaMode = getBuildTimeHeader(request, "X-React-Router-SPA-Mode") === "yes";
        if (!_build.ssr) {
          if (_build.prerender.length === 0) {
            isSpaMode = true;
          } else if (!_build.prerender.includes(normalizedPath) && !_build.prerender.includes(normalizedPath + "/")) {
            if (url.pathname.endsWith(".data")) {
              errorHandler2(
                new ErrorResponseImpl(
                  404,
                  "Not Found",
                  `Refusing to SSR the path \`${normalizedPath}\` because \`ssr:false\` is set and the path is not included in the \`prerender\` config, so in production the path will be a 404.`
                ),
                {
                  context: loadContext,
                  params,
                  request
                }
              );
              return new Response("Not Found", {
                status: 404,
                statusText: "Not Found"
              });
            } else {
              isSpaMode = true;
            }
          }
        }
        let manifestUrl = getManifestPath(
          _build.routeDiscovery.manifestPath,
          normalizedBasename
        );
        if (url.pathname === manifestUrl) {
          try {
            let res = await handleManifestRequest(_build, routes, url);
            return res;
          } catch (e) {
            handleError(e);
            return new Response("Unknown Server Error", { status: 500 });
          }
        }
        let matches = matchServerRoutes(routes, normalizedPath, _build.basename);
        if (matches && matches.length > 0) {
          Object.assign(params, matches[0].params);
        }
        let response;
        if (url.pathname.endsWith(".data")) {
          let handlerUrl = new URL(request.url);
          handlerUrl.pathname = normalizedPath;
          let singleFetchMatches = matchServerRoutes(
            routes,
            handlerUrl.pathname,
            _build.basename
          );
          response = await handleSingleFetchRequest(
            serverMode,
            _build,
            staticHandler,
            request,
            handlerUrl,
            loadContext,
            handleError
          );
          if (_build.entry.module.handleDataRequest) {
            response = await _build.entry.module.handleDataRequest(response, {
              context: loadContext,
              params: singleFetchMatches ? singleFetchMatches[0].params : {},
              request
            });
            if (isRedirectResponse(response)) {
              let result = getSingleFetchRedirect(
                response.status,
                response.headers,
                _build.basename
              );
              if (request.method === "GET") {
                result = {
                  [SingleFetchRedirectSymbol]: result
                };
              }
              let headers = new Headers(response.headers);
              headers.set("Content-Type", "text/x-script");
              return new Response(
                encodeViaTurboStream(
                  result,
                  request.signal,
                  _build.entry.module.streamTimeout,
                  serverMode
                ),
                {
                  status: SINGLE_FETCH_REDIRECT_STATUS,
                  headers
                }
              );
            }
          }
        } else if (!isSpaMode && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {
          response = await handleResourceRequest(
            serverMode,
            _build,
            staticHandler,
            matches.slice(-1)[0].route.id,
            request,
            loadContext,
            handleError
          );
        } else {
          let { pathname } = url;
          let criticalCss = void 0;
          if (_build.unstable_getCriticalCss) {
            criticalCss = await _build.unstable_getCriticalCss({ pathname });
          } else if (mode === "development" && ((_a = getDevServerHooks()) == null ? void 0 : _a.getCriticalCss)) {
            criticalCss = await ((_c = (_b = getDevServerHooks()) == null ? void 0 : _b.getCriticalCss) == null ? void 0 : _c.call(_b, pathname));
          }
          response = await handleDocumentRequest(
            serverMode,
            _build,
            staticHandler,
            request,
            loadContext,
            handleError,
            isSpaMode,
            criticalCss
          );
        }
        if (request.method === "HEAD") {
          return new Response(null, {
            headers: response.headers,
            status: response.status,
            statusText: response.statusText
          });
        }
        return response;
      };
    };
    async function handleManifestRequest(build, routes, url) {
      if (build.assets.version !== url.searchParams.get("version")) {
        return new Response(null, {
          status: 204,
          headers: {
            "X-Remix-Reload-Document": "true"
          }
        });
      }
      let patches = {};
      if (url.searchParams.has("p")) {
        let paths = /* @__PURE__ */ new Set();
        url.searchParams.getAll("p").forEach((path) => {
          if (!path.startsWith("/")) {
            path = `/${path}`;
          }
          let segments = path.split("/").slice(1);
          segments.forEach((_, i) => {
            let partialPath = segments.slice(0, i + 1).join("/");
            paths.add(`/${partialPath}`);
          });
        });
        for (let path of paths) {
          let matches = matchServerRoutes(routes, path, build.basename);
          if (matches) {
            for (let match of matches) {
              let routeId = match.route.id;
              let route = build.assets.routes[routeId];
              if (route) {
                patches[routeId] = route;
              }
            }
          }
        }
        return Response.json(patches, {
          headers: {
            "Cache-Control": "public, max-age=31536000, immutable"
          }
        });
      }
      return new Response("Invalid Request", { status: 400 });
    }
    async function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {
      let response = request.method !== "GET" ? await singleFetchAction(
        build,
        serverMode,
        staticHandler,
        request,
        handlerUrl,
        loadContext,
        handleError
      ) : await singleFetchLoaders(
        build,
        serverMode,
        staticHandler,
        request,
        handlerUrl,
        loadContext,
        handleError
      );
      return response;
    }
    async function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {
      try {
        let response = await staticHandler.query(request, {
          requestContext: loadContext,
          unstable_respond: build.future.unstable_middleware ? (ctx) => renderHtml(ctx, isSpaMode) : void 0
        });
        return isResponse(response) ? response : renderHtml(response, isSpaMode);
      } catch (error) {
        handleError(error);
        return new Response(null, { status: 500 });
      }
      async function renderHtml(context, isSpaMode2) {
        if (isResponse(context)) {
          return context;
        }
        let headers = getDocumentHeaders(build, context);
        if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {
          return new Response(null, { status: context.statusCode, headers });
        }
        if (context.errors) {
          Object.values(context.errors).forEach((err) => {
            if (!isRouteErrorResponse(err) || err.error) {
              handleError(err);
            }
          });
          context.errors = sanitizeErrors(context.errors, serverMode);
        }
        let state = {
          loaderData: context.loaderData,
          actionData: context.actionData,
          errors: serializeErrors2(context.errors, serverMode)
        };
        let baseServerHandoff = {
          basename: build.basename,
          future: build.future,
          routeDiscovery: build.routeDiscovery,
          ssr: build.ssr,
          isSpaMode: isSpaMode2
        };
        let entryContext = {
          manifest: build.assets,
          routeModules: createEntryRouteModules(build.routes),
          staticHandlerContext: context,
          criticalCss,
          serverHandoffString: createServerHandoffString({
            ...baseServerHandoff,
            criticalCss
          }),
          serverHandoffStream: encodeViaTurboStream(
            state,
            request.signal,
            build.entry.module.streamTimeout,
            serverMode
          ),
          renderMeta: {},
          future: build.future,
          ssr: build.ssr,
          routeDiscovery: build.routeDiscovery,
          isSpaMode: isSpaMode2,
          serializeError: (err) => serializeError(err, serverMode)
        };
        let handleDocumentRequestFunction = build.entry.module.default;
        try {
          return await handleDocumentRequestFunction(
            request,
            context.statusCode,
            headers,
            entryContext,
            loadContext
          );
        } catch (error) {
          handleError(error);
          let errorForSecondRender = error;
          if (isResponse(error)) {
            try {
              let data2 = await unwrapResponse(error);
              errorForSecondRender = new ErrorResponseImpl(
                error.status,
                error.statusText,
                data2
              );
            } catch (e) {
            }
          }
          context = getStaticContextFromError(
            staticHandler.dataRoutes,
            context,
            errorForSecondRender
          );
          if (context.errors) {
            context.errors = sanitizeErrors(context.errors, serverMode);
          }
          let state2 = {
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: serializeErrors2(context.errors, serverMode)
          };
          entryContext = {
            ...entryContext,
            staticHandlerContext: context,
            serverHandoffString: createServerHandoffString(baseServerHandoff),
            serverHandoffStream: encodeViaTurboStream(
              state2,
              request.signal,
              build.entry.module.streamTimeout,
              serverMode
            ),
            renderMeta: {}
          };
          try {
            return await handleDocumentRequestFunction(
              request,
              context.statusCode,
              headers,
              entryContext,
              loadContext
            );
          } catch (error2) {
            handleError(error2);
            return returnLastResortErrorResponse(error2, serverMode);
          }
        }
      }
    }
    async function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {
      try {
        let response = await staticHandler.queryRoute(request, {
          routeId,
          requestContext: loadContext,
          unstable_respond: build.future.unstable_middleware ? (ctx) => ctx : void 0
        });
        if (isResponse(response)) {
          return response;
        }
        if (typeof response === "string") {
          return new Response(response);
        }
        return Response.json(response);
      } catch (error) {
        if (isResponse(error)) {
          error.headers.set("X-Remix-Catch", "yes");
          return error;
        }
        if (isRouteErrorResponse(error)) {
          if (error) {
            handleError(error);
          }
          return errorResponseToJson(error, serverMode);
        }
        if (error instanceof Error && error.message === "Expected a response from queryRoute") {
          let newError = new Error(
            "Expected a Response to be returned from resource route handler"
          );
          handleError(newError);
          return returnLastResortErrorResponse(newError, serverMode);
        }
        handleError(error);
        return returnLastResortErrorResponse(error, serverMode);
      }
    }
    function errorResponseToJson(errorResponse, serverMode) {
      return Response.json(
        serializeError(
          // @ts-expect-error This is "private" from users but intended for internal use
          errorResponse.error || new Error("Unexpected Server Error"),
          serverMode
        ),
        {
          status: errorResponse.status,
          statusText: errorResponse.statusText,
          headers: {
            "X-Remix-Error": "yes"
          }
        }
      );
    }
    function returnLastResortErrorResponse(error, serverMode) {
      let message = "Unexpected Server Error";
      if (serverMode !== "production") {
        message += `

${String(error)}`;
      }
      return new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
    function unwrapResponse(response) {
      let contentType = response.headers.get("Content-Type");
      return contentType && /\bapplication\/json\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();
    }
    function flash(name) {
      return `__flash_${name}__`;
    }
    var createSession = (initialData = {}, id = "") => {
      let map = new Map(Object.entries(initialData));
      return {
        get id() {
          return id;
        },
        get data() {
          return Object.fromEntries(map);
        },
        has(name) {
          return map.has(name) || map.has(flash(name));
        },
        get(name) {
          if (map.has(name)) return map.get(name);
          let flashName = flash(name);
          if (map.has(flashName)) {
            let value = map.get(flashName);
            map.delete(flashName);
            return value;
          }
          return void 0;
        },
        set(name, value) {
          map.set(name, value);
        },
        flash(name, value) {
          map.set(flash(name), value);
        },
        unset(name) {
          map.delete(name);
        }
      };
    };
    var isSession = (object) => {
      return object != null && typeof object.id === "string" && typeof object.data !== "undefined" && typeof object.has === "function" && typeof object.get === "function" && typeof object.set === "function" && typeof object.flash === "function" && typeof object.unset === "function";
    };
    function createSessionStorage({
      cookie: cookieArg,
      createData,
      readData,
      updateData,
      deleteData
    }) {
      let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      warnOnceAboutSigningSessionCookie(cookie);
      return {
        async getSession(cookieHeader, options) {
          let id = cookieHeader && await cookie.parse(cookieHeader, options);
          let data2 = id && await readData(id);
          return createSession(data2 || {}, id || "");
        },
        async commitSession(session, options) {
          let { id, data: data2 } = session;
          let expires = (options == null ? void 0 : options.maxAge) != null ? new Date(Date.now() + options.maxAge * 1e3) : (options == null ? void 0 : options.expires) != null ? options.expires : cookie.expires;
          if (id) {
            await updateData(id, data2, expires);
          } else {
            id = await createData(data2, expires);
          }
          return cookie.serialize(id, options);
        },
        async destroySession(session, options) {
          await deleteData(session.id);
          return cookie.serialize("", {
            ...options,
            maxAge: void 0,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    }
    function warnOnceAboutSigningSessionCookie(cookie) {
      warnOnce(
        cookie.isSigned,
        `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`
      );
    }
    function createCookieSessionStorage({ cookie: cookieArg } = {}) {
      let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      warnOnceAboutSigningSessionCookie(cookie);
      return {
        async getSession(cookieHeader, options) {
          return createSession(
            cookieHeader && await cookie.parse(cookieHeader, options) || {}
          );
        },
        async commitSession(session, options) {
          let serializedCookie = await cookie.serialize(session.data, options);
          if (serializedCookie.length > 4096) {
            throw new Error(
              "Cookie length will exceed browser maximum. Length: " + serializedCookie.length
            );
          }
          return serializedCookie;
        },
        async destroySession(_session, options) {
          return cookie.serialize("", {
            ...options,
            maxAge: void 0,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    }
    function createMemorySessionStorage({ cookie } = {}) {
      let map = /* @__PURE__ */ new Map();
      return createSessionStorage({
        cookie,
        async createData(data2, expires) {
          let id = Math.random().toString(36).substring(2, 10);
          map.set(id, { data: data2, expires });
          return id;
        },
        async readData(id) {
          if (map.has(id)) {
            let { data: data2, expires } = map.get(id);
            if (!expires || expires > /* @__PURE__ */ new Date()) {
              return data2;
            }
            if (expires) map.delete(id);
          }
          return null;
        },
        async updateData(id, data2, expires) {
          map.set(id, { data: data2, expires });
        },
        async deleteData(id) {
          map.delete(id);
        }
      });
    }
    function href(path, ...args) {
      let params = args[0];
      return path.split("/").map((segment) => {
        const match = segment.match(/^:([\w-]+)(\?)?/);
        if (!match) return segment;
        const param = match[1];
        const value = params ? params[param] : void 0;
        const isRequired = match[2] === void 0;
        if (isRequired && value === void 0) {
          throw Error(
            `Path '${path}' requires param '${param}' but it was not provided`
          );
        }
        return value;
      }).filter((segment) => segment !== void 0).join("/");
    }
    function deserializeErrors2(errors) {
      if (!errors) return null;
      let entries = Object.entries(errors);
      let serialized = {};
      for (let [key, val] of entries) {
        if (val && val.__type === "RouteErrorResponse") {
          serialized[key] = new ErrorResponseImpl(
            val.status,
            val.statusText,
            val.data,
            val.internal === true
          );
        } else if (val && val.__type === "Error") {
          if (val.__subType) {
            let ErrorConstructor = window[val.__subType];
            if (typeof ErrorConstructor === "function") {
              try {
                let error = new ErrorConstructor(val.message);
                error.stack = val.stack;
                serialized[key] = error;
              } catch (e) {
              }
            }
          }
          if (serialized[key] == null) {
            let error = new Error(val.message);
            error.stack = val.stack;
            serialized[key] = error;
          }
        } else {
          serialized[key] = val;
        }
      }
      return serialized;
    }
    function getHydrationData(state, routes, getRouteInfo, location, basename, isSpaMode) {
      let hydrationData = {
        ...state,
        loaderData: { ...state.loaderData }
      };
      let initialMatches = matchRoutes(routes, location, basename);
      if (initialMatches) {
        for (let match of initialMatches) {
          let routeId = match.route.id;
          let routeInfo = getRouteInfo(routeId);
          if (shouldHydrateRouteLoader(
            routeId,
            routeInfo.clientLoader,
            routeInfo.hasLoader,
            isSpaMode
          ) && (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {
            delete hydrationData.loaderData[routeId];
          } else if (!routeInfo.hasLoader) {
            hydrationData.loaderData[routeId] = null;
          }
        }
      }
      return hydrationData;
    }
  }
});

// node_modules/react-router/dist/development/dom-export.js
var require_dom_export = __commonJS({
  "node_modules/react-router/dist/development/dom-export.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var dom_export_exports = {};
    __export2(dom_export_exports, {
      HydratedRouter: () => HydratedRouter2,
      RouterProvider: () => RouterProvider2
    });
    module.exports = __toCommonJS2(dom_export_exports);
    var React5 = __toESM2(require_react());
    var ReactDOM2 = __toESM2(require_react_dom());
    var import_react_router = require_development();
    function RouterProvider2(props) {
      return React5.createElement(import_react_router.RouterProvider, { flushSync: ReactDOM2.flushSync, ...props });
    }
    var React22 = __toESM2(require_react());
    var import_react_router2 = require_development();
    var ssrInfo = null;
    var router = null;
    function initSsrInfo() {
      if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {
        if (window.__reactRouterManifest.sri === true) {
          const importMap = document.querySelector("script[rr-importmap]");
          if (importMap == null ? void 0 : importMap.textContent) {
            try {
              window.__reactRouterManifest.sri = JSON.parse(
                importMap.textContent
              ).integrity;
            } catch (err) {
              console.error("Failed to parse import map", err);
            }
          }
        }
        ssrInfo = {
          context: window.__reactRouterContext,
          manifest: window.__reactRouterManifest,
          routeModules: window.__reactRouterRouteModules,
          stateDecodingPromise: void 0,
          router: void 0,
          routerInitialized: false
        };
      }
    }
    function createHydratedRouter({
      unstable_getContext
    }) {
      var _a, _b;
      initSsrInfo();
      if (!ssrInfo) {
        throw new Error(
          "You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`"
        );
      }
      let localSsrInfo = ssrInfo;
      if (!ssrInfo.stateDecodingPromise) {
        let stream = ssrInfo.context.stream;
        (0, import_react_router2.UNSAFE_invariant)(stream, "No stream found for single fetch decoding");
        ssrInfo.context.stream = void 0;
        ssrInfo.stateDecodingPromise = (0, import_react_router2.UNSAFE_decodeViaTurboStream)(stream, window).then((value) => {
          ssrInfo.context.state = value.value;
          localSsrInfo.stateDecodingPromise.value = true;
        }).catch((e) => {
          localSsrInfo.stateDecodingPromise.error = e;
        });
      }
      if (ssrInfo.stateDecodingPromise.error) {
        throw ssrInfo.stateDecodingPromise.error;
      }
      if (!ssrInfo.stateDecodingPromise.value) {
        throw ssrInfo.stateDecodingPromise;
      }
      let routes = (0, import_react_router2.UNSAFE_createClientRoutes)(
        ssrInfo.manifest.routes,
        ssrInfo.routeModules,
        ssrInfo.context.state,
        ssrInfo.context.ssr,
        ssrInfo.context.isSpaMode
      );
      let hydrationData = void 0;
      if (ssrInfo.context.isSpaMode) {
        let { loaderData } = ssrInfo.context.state;
        if (((_a = ssrInfo.manifest.routes.root) == null ? void 0 : _a.hasLoader) && loaderData && "root" in loaderData) {
          hydrationData = {
            loaderData: {
              root: loaderData.root
            }
          };
        }
      } else {
        hydrationData = (0, import_react_router2.UNSAFE_getHydrationData)(
          ssrInfo.context.state,
          routes,
          (routeId) => {
            var _a2, _b2, _c;
            return {
              clientLoader: (_a2 = ssrInfo.routeModules[routeId]) == null ? void 0 : _a2.clientLoader,
              hasLoader: ((_b2 = ssrInfo.manifest.routes[routeId]) == null ? void 0 : _b2.hasLoader) === true,
              hasHydrateFallback: ((_c = ssrInfo.routeModules[routeId]) == null ? void 0 : _c.HydrateFallback) != null
            };
          },
          window.location,
          (_b = window.__reactRouterContext) == null ? void 0 : _b.basename,
          ssrInfo.context.isSpaMode
        );
        if (hydrationData && hydrationData.errors) {
          hydrationData.errors = (0, import_react_router2.UNSAFE_deserializeErrors)(hydrationData.errors);
        }
      }
      let router2 = (0, import_react_router2.UNSAFE_createRouter)({
        routes,
        history: (0, import_react_router2.UNSAFE_createBrowserHistory)(),
        basename: ssrInfo.context.basename,
        unstable_getContext,
        hydrationData,
        hydrationRouteProperties: import_react_router2.UNSAFE_hydrationRouteProperties,
        mapRouteProperties: import_react_router2.UNSAFE_mapRouteProperties,
        future: {
          unstable_middleware: ssrInfo.context.future.unstable_middleware
        },
        dataStrategy: (0, import_react_router2.UNSAFE_getTurboStreamSingleFetchDataStrategy)(
          () => router2,
          ssrInfo.manifest,
          ssrInfo.routeModules,
          ssrInfo.context.ssr,
          ssrInfo.context.basename
        ),
        patchRoutesOnNavigation: (0, import_react_router2.UNSAFE_getPatchRoutesOnNavigationFunction)(
          ssrInfo.manifest,
          ssrInfo.routeModules,
          ssrInfo.context.ssr,
          ssrInfo.context.routeDiscovery,
          ssrInfo.context.isSpaMode,
          ssrInfo.context.basename
        )
      });
      ssrInfo.router = router2;
      if (router2.state.initialized) {
        ssrInfo.routerInitialized = true;
        router2.initialize();
      }
      router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */
      import_react_router2.UNSAFE_createClientRoutesWithHMRRevalidationOptOut;
      window.__reactRouterDataRouter = router2;
      return router2;
    }
    function HydratedRouter2(props) {
      if (!router) {
        router = createHydratedRouter({
          unstable_getContext: props.unstable_getContext
        });
      }
      let [criticalCss, setCriticalCss] = React22.useState(
        true ? ssrInfo == null ? void 0 : ssrInfo.context.criticalCss : void 0
      );
      if (true) {
        if (ssrInfo) {
          window.__reactRouterClearCriticalCss = () => setCriticalCss(void 0);
        }
      }
      let [location, setLocation] = React22.useState(router.state.location);
      React22.useLayoutEffect(() => {
        if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {
          ssrInfo.routerInitialized = true;
          ssrInfo.router.initialize();
        }
      }, []);
      React22.useLayoutEffect(() => {
        if (ssrInfo && ssrInfo.router) {
          return ssrInfo.router.subscribe((newState) => {
            if (newState.location !== location) {
              setLocation(newState.location);
            }
          });
        }
      }, [location]);
      (0, import_react_router2.UNSAFE_invariant)(ssrInfo, "ssrInfo unavailable for HydratedRouter");
      (0, import_react_router2.UNSAFE_useFogOFWarDiscovery)(
        router,
        ssrInfo.manifest,
        ssrInfo.routeModules,
        ssrInfo.context.ssr,
        ssrInfo.context.routeDiscovery,
        ssrInfo.context.isSpaMode
      );
      return (
        // This fragment is important to ensure we match the <ServerRouter> JSX
        // structure so that useId values hydrate correctly
        React22.createElement(React22.Fragment, null, React22.createElement(
          import_react_router2.UNSAFE_FrameworkContext.Provider,
          {
            value: {
              manifest: ssrInfo.manifest,
              routeModules: ssrInfo.routeModules,
              future: ssrInfo.context.future,
              criticalCss,
              ssr: ssrInfo.context.ssr,
              isSpaMode: ssrInfo.context.isSpaMode,
              routeDiscovery: ssrInfo.context.routeDiscovery
            }
          },
          React22.createElement(import_react_router2.UNSAFE_RemixErrorBoundary, { location }, React22.createElement(RouterProvider2, { router }))
        ), React22.createElement(React22.Fragment, null))
      );
    }
  }
});

// node_modules/react-router-dom/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/react-router-dom/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var react_router_dom_exports = {};
    __export2(react_router_dom_exports, {
      HydratedRouter: () => import_dom.HydratedRouter,
      RouterProvider: () => import_dom.RouterProvider
    });
    module.exports = __toCommonJS2(react_router_dom_exports);
    var import_dom = require_dom_export();
    __reExport(react_router_dom_exports, require_development(), module.exports);
  }
});

// node_modules/react/package.json
var require_package = __commonJS({
  "node_modules/react/package.json"(exports, module) {
    module.exports = {
      name: "react",
      description: "React is a JavaScript library for building user interfaces.",
      keywords: [
        "react"
      ],
      version: "19.1.0",
      homepage: "https://react.dev/",
      bugs: "https://github.com/facebook/react/issues",
      license: "MIT",
      files: [
        "LICENSE",
        "README.md",
        "index.js",
        "cjs/",
        "compiler-runtime.js",
        "jsx-runtime.js",
        "jsx-runtime.react-server.js",
        "jsx-dev-runtime.js",
        "jsx-dev-runtime.react-server.js",
        "react.react-server.js"
      ],
      main: "index.js",
      exports: {
        ".": {
          "react-server": "./react.react-server.js",
          default: "./index.js"
        },
        "./package.json": "./package.json",
        "./jsx-runtime": {
          "react-server": "./jsx-runtime.react-server.js",
          default: "./jsx-runtime.js"
        },
        "./jsx-dev-runtime": {
          "react-server": "./jsx-dev-runtime.react-server.js",
          default: "./jsx-dev-runtime.js"
        },
        "./compiler-runtime": {
          "react-server": "./compiler-runtime.js",
          default: "./compiler-runtime.js"
        }
      },
      repository: {
        type: "git",
        url: "https://github.com/facebook/react.git",
        directory: "packages/react"
      },
      engines: {
        node: ">=0.10.0"
      }
    };
  }
});

// node_modules/@frontegg/react/index.js
var require_react2 = __commonJS({
  "node_modules/@frontegg/react/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var React5 = require_react();
    var React__default = _interopDefault(React5);
    var js = (init_js(), __toCommonJS(js_exports));
    var reactHooks = (init_react_hooks(), __toCommonJS(react_hooks_exports));
    var ReactRouterDom = require_dist3();
    var restApi = (init_rest_api(), __toCommonJS(rest_api_exports));
    var AppHolder2 = (init_AppHolder(), __toCommonJS(AppHolder_exports));
    var reduxStore = (init_redux_store(), __toCommonJS(redux_store_exports));
    var ReactPkg = _interopDefault(require_package());
    var types = (init_types(), __toCommonJS(types_exports));
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    }
    var BrowserRouter = ReactRouterDom.BrowserRouter;
    var useHistory = function() {
      var _a, _b, _c;
      var navigate = ((_a = ReactRouterDom.useInRouterContext) === null || _a === void 0 ? void 0 : _a.call(ReactRouterDom)) ? (_b = ReactRouterDom.useNavigate) === null || _b === void 0 ? void 0 : _b.call(ReactRouterDom) : null;
      var history = (_c = ReactRouterDom.useHistory) === null || _c === void 0 ? void 0 : _c.call(ReactRouterDom);
      if (navigate) {
        var push = function(path, state) {
          if (state) {
            navigate(path, { state });
          } else {
            navigate(path);
          }
        };
        var replace = function(path, state) {
          navigate(path, { state, replace: true });
        };
        return { push, replace };
      }
      return history;
    };
    var sdkVersion = { version: "7.7.2" };
    var removeRedirectUrlFromQuery = function(query) {
      var q = new URLSearchParams(query);
      q.delete("redirectUrl");
      return q.toString();
    };
    var useQueryKeeper = function(_a) {
      var routes = _a.routes, history = _a.history;
      var queryParams = React5.useRef();
      var prevPathname = React5.useRef();
      var _b = ReactRouterDom.useLocation(), pathname = _b.pathname, search = _b.search;
      React5.useEffect(function() {
        if (!!search) {
          queryParams.current = search;
          prevPathname.current = pathname;
        }
      }, []);
      React5.useEffect(function() {
        var shouldKeepQuery = !!Object.values(routes).find(function(route) {
          return route === prevPathname.current;
        });
        if (!search && !!queryParams.current && shouldKeepQuery) {
          var query = removeRedirectUrlFromQuery(queryParams.current);
          history.push(pathname + ("?" + query));
        }
        prevPathname.current = pathname;
      }, [pathname, search, routes]);
    };
    var QueryKeeperWrapper = function(_a) {
      var history = _a.history;
      var signUpUrl = reactHooks.useAuthRoutes().signUpUrl;
      useQueryKeeper({ routes: { signUpUrl }, history });
      return React__default.createElement(React__default.Fragment, null);
    };
    var AlwaysRenderInProvider = function(_a) {
      var isExternalHistory = _a.isExternalHistory, app = _a.app, themeOptions = _a.themeOptions, history = _a.history;
      return React__default.createElement(
        React__default.Fragment,
        null,
        React__default.createElement(reactHooks.CustomComponentRegister, { app, themeOptions }),
        !isExternalHistory && React__default.createElement(QueryKeeperWrapper, { history })
      );
    };
    var ConnectorHistory = function(props) {
      var history = useHistory();
      return React__default.createElement(Connector, __assign({ history }, props));
    };
    function isBypassReactRoute(path, routes) {
      var stepUpUrl = (routes === null || routes === void 0 ? void 0 : routes.stepUpUrl) || reduxStore.defaultFronteggRoutes.stepUpUrl;
      return stepUpUrl && path.startsWith(stepUpUrl);
    }
    var Connector = function(_a) {
      var _b, _c;
      var history = _a.history, appName = _a.appName, _d = _a.isExternalHistory, isExternalHistory = _d === void 0 ? false : _d, props = __rest(_a, ["history", "appName", "isExternalHistory"]);
      var isSSR = typeof window === "undefined";
      var version = "@frontegg/react@" + sdkVersion.version;
      var baseName = (_b = props.basename) !== null && _b !== void 0 ? _b : "";
      var isAuthRouteRef = React5.useRef(function() {
        return false;
      });
      React5.useEffect(function() {
        isAuthRouteRef.current = function(path) {
          var _a2;
          return reduxStore.isAuthRoute(path, (_a2 = props.authOptions) === null || _a2 === void 0 ? void 0 : _a2.routes);
        };
      }, [(_c = props.authOptions) === null || _c === void 0 ? void 0 : _c.routes]);
      var onRedirectTo = React5.useCallback(function(_path, opts) {
        var _a2, _b2;
        var path = _path;
        if (baseName && typeof baseName === "string" && baseName.length > 0 && path.startsWith(baseName)) {
          path = path.substring(baseName.length);
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.preserveQueryParams) || isAuthRouteRef.current(path)) {
          path = "" + path + window.location.search;
        }
        if (isBypassReactRoute(path, (_a2 = props.authOptions) === null || _a2 === void 0 ? void 0 : _a2.routes)) {
          (_b2 = window === null || window === void 0 ? void 0 : window.history) === null || _b2 === void 0 ? void 0 : _b2.pushState(null, "", path);
          return;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.refresh) && !isSSR) {
          window.Cypress && !props.hostedRuntime ? history.push(path) : window.location.href = path;
        } else {
          (opts === null || opts === void 0 ? void 0 : opts.replace) ? history.replace(path) : history.push(path);
        }
      }, []);
      var app = React5.useMemo(function() {
        var _a2;
        try {
          return AppHolder2.AppHolder.getInstance(appName !== null && appName !== void 0 ? appName : "default");
        } catch (e) {
          return js.initialize(__assign(__assign({}, props), { basename: (_a2 = props.basename) !== null && _a2 !== void 0 ? _a2 : baseName, contextOptions: __assign({ requestCredentials: "include", metadataHeaders: {
            //TODO: remove this ts-ignore after updating rest-api context options type to accept string.
            //@ts-ignore
            framework: restApi.FronteggFrameworks.React + "@" + ReactPkg.version,
            fronteggSdkVersion: version
          } }, props.contextOptions), onRedirectTo }), appName !== null && appName !== void 0 ? appName : "default");
        }
      }, []);
      restApi.ContextHolder.setOnRedirectTo(onRedirectTo);
      return React__default.createElement(reactHooks.FronteggStoreProvider, __assign({}, __assign(__assign({}, props), { app }), { alwaysVisibleChildren: React__default.createElement(AlwaysRenderInProvider, { app, themeOptions: props.themeOptions, history, isExternalHistory }) }));
    };
    var FronteggProvider = function(props) {
      var history = useHistory();
      if (props.history || history) {
        return React__default.createElement(Connector, __assign({ history: props.history || history, isExternalHistory: !!props.history }, props), props.children);
      }
      return React__default.createElement(
        BrowserRouter,
        { basename: props.basename },
        React__default.createElement(ConnectorHistory, __assign({}, props), props.children)
      );
    };
    var AuthorizedContent = function(props) {
      var _a, _b;
      var isAuthorized = true;
      var user = reactHooks.useAuthUserOrNull();
      if (!(user === null || user === void 0 ? void 0 : user.superUser)) {
        if (props.requiredPermissions) {
          isAuthorized = false;
          var _loop_1 = function(permission2) {
            if ((_a = user === null || user === void 0 ? void 0 : user.permissions) === null || _a === void 0 ? void 0 : _a.find(function(_a2) {
              var key = _a2.key;
              return key === permission2;
            })) {
              isAuthorized = true;
            }
          };
          for (var _i = 0, _c = props.requiredPermissions; _i < _c.length; _i++) {
            var permission = _c[_i];
            _loop_1(permission);
          }
        }
        if (props.requiredRoles) {
          isAuthorized = false;
          var _loop_2 = function(role2) {
            if ((_b = user === null || user === void 0 ? void 0 : user.roles) === null || _b === void 0 ? void 0 : _b.find(function(_a2) {
              var key = _a2.key;
              return key === role2;
            })) {
              isAuthorized = true;
            }
          };
          for (var _d = 0, _e = props.requiredRoles; _d < _e.length; _d++) {
            var role = _e[_d];
            _loop_2(role);
          }
        }
      }
      if (typeof props.render === "function") {
        return React__default.createElement(React__default.Fragment, null, props.render(isAuthorized));
      }
      return isAuthorized ? React__default.createElement(React__default.Fragment, null, props.children) : null;
    };
    var useCheckoutDialog = function(appName) {
      if (appName === void 0) {
        appName = "default";
      }
      var _a = React5.useState({
        open: false,
        error: null,
        success: false
      }), _b = _a[0], open = _b.open, error = _b.error, success = _b.success, setState = _a[1];
      var handleError = React5.useCallback(function(error2) {
        setState({
          open: true,
          success: false,
          error: error2
        });
      }, []);
      var handleSuccess = React5.useCallback(function() {
        setState({
          open: false,
          success: true,
          error: null
        });
      }, []);
      var showDialog = React5.useCallback(function(plan) {
        js.CheckoutDialog.show({
          plan,
          onClose: hideDialog,
          onError: handleError,
          onSuccess: handleSuccess
        }, appName);
        setState({
          open: true,
          success: false,
          error: null
        });
      }, [appName]);
      var hideDialog = React5.useCallback(function() {
        js.CheckoutDialog.hide(appName);
        setState({
          open: false,
          error: null,
          success: false
        });
      }, [appName]);
      return React5.useMemo(function() {
        return {
          open,
          showDialog,
          hideDialog,
          error,
          success
        };
      }, [open, showDialog, hideDialog, error, success]);
    };
    var SteppedUpContent = function(props) {
      var isAuthenticated = reactHooks.useIsAuthenticated();
      if (!isAuthenticated)
        return null;
      return React__default.createElement(SteppedUpContentInternal, __assign({}, props));
    };
    var SteppedUpContentInternal = function(_a) {
      var maxAge = _a.maxAge, preventSteppingUp = _a.preventSteppingUp, render = _a.render, children = _a.children;
      var isSteppedUp2 = reactHooks.useIsSteppedUp({ maxAge });
      var stepUp = reactHooks.useStepUp();
      var isStepUpCalled = React5.useRef(false);
      React5.useEffect(function() {
        if (isSteppedUp2) {
          isStepUpCalled.current = false;
          return;
        }
        if (isStepUpCalled.current)
          return;
        if (!preventSteppingUp) {
          stepUp({ maxAge });
        }
        isStepUpCalled.current = true;
      }, [isSteppedUp2, maxAge, preventSteppingUp, stepUp]);
      if (typeof render === "function") {
        return React__default.createElement(React__default.Fragment, null, render(isSteppedUp2));
      }
      return isSteppedUp2 ? React__default.createElement(React__default.Fragment, null, children) : null;
    };
    Object.keys(reactHooks).forEach(function(k) {
      if (k !== "default") Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return reactHooks[k];
        }
      });
    });
    Object.keys(types).forEach(function(k) {
      if (k !== "default") Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return types[k];
        }
      });
    });
    Object.defineProperty(exports, "AdminPortal", {
      enumerable: true,
      get: function() {
        return js.AdminPortal;
      }
    });
    Object.defineProperty(exports, "CheckoutDialog", {
      enumerable: true,
      get: function() {
        return js.CheckoutDialog;
      }
    });
    Object.defineProperty(exports, "HostedLogin", {
      enumerable: true,
      get: function() {
        return js.HostedLogin;
      }
    });
    Object.defineProperty(exports, "ContextHolder", {
      enumerable: true,
      get: function() {
        return restApi.ContextHolder;
      }
    });
    exports.AuthorizedContent = AuthorizedContent;
    exports.Connector = Connector;
    exports.ConnectorHistory = ConnectorHistory;
    exports.FronteggProvider = FronteggProvider;
    exports.SteppedUpContent = SteppedUpContent;
    exports.useCheckoutDialog = useCheckoutDialog;
  }
});
export default require_react2();
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)

@frontegg/rest-api/index.js:
@frontegg/redux-store/index.js:
@frontegg/types/index.js:
@frontegg/js/index.js:
@frontegg/react-hooks/index.js:
  (** @license Frontegg v7.69.0
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

get-value/index.js:
  (*!
   * get-value <https://github.com/jonschlinkert/get-value>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-primitive/index.js:
  (*!
   * is-primitive <https://github.com/jonschlinkert/is-primitive>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

set-value/index.js:
  (*!
   * set-value <https://github.com/jonschlinkert/set-value>
   *
   * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).
   * Released under the MIT License.
   *)

@frontegg/redux-store/helpers/sha256.js:
  (**
   *
   * THIS IS CUSTOM VERSION OF JS-SHA256 that will be used only
   * on non-secure domain due to the native `crypto.subtle.digest`
   * isn't accessible from non-secure domains.
   *
   * NOTE: Changes from 0.9.0:
   * - Remove any usage of eval scripts
   * - Remove support for UMD and AMD exports
   * - Remove support for CommonJS
   * - Make it typescript
   *
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.9.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-router/dist/development/index.js:
react-router/dist/development/dom-export.js:
  (**
   * react-router v7.6.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * react-router-dom v7.6.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@frontegg/react/index.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@frontegg_react.js.map
